{
  "explanation": "The code used edges.sort() which sorts edges in ascending order, so Kruskal's loop picks the smallest available edges and computes the cost of a minimum spanning tree. The intended result was to pick the largest edges (a maximum spanning tree), so the single-line fix is to sort edges in descending order using edges.sort(reverse=True).",
  "fixed_code": "from atcoder.dsu import DSU\nfrom heapq import heappop, heappush\nfrom collections import deque\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\nG = [[0] * N for _ in range(N)]\nfor i in range(N):\n    for j in range(i+1, N):\n        G[i][j] = (pow(A[i], A[j], M) + pow(A[j], A[i], M)) % M\n        G[j][i] = G[i][j]\n\nedges = []\nfor i in range(N):\n    for j in range(i+1, N):\n        edges.append(((pow(A[i], A[j], M) + pow(A[j], A[i], M)) % M, i, j))\nedges.sort(reverse=True)\n\nans = 0\nuf = DSU(N)\nfor p, i, j in edges:\n    if uf.same(i, j): continue\n    ans += p\n    uf.merge(i, j)\nprint(ans)"
}