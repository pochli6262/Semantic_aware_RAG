{
  "explanation": "The bug was that di was initialized with defaultdict(int), which returns 0 for unseen keys. The code uses di[x] != 0 and di[x] <= cnt to prune revisits; because unseen states returned 0, they were treated as already-visited with cost 0, which broke the pruning logic and allowed incorrect overwrites or extra revisits (especially for the start value). I fixed it by making di default to a large INF instead of 0 (di = defaultdict(lambda: 1 << 60)). This preserves the existing conditional check and ensures unseen states compare properly against cnt.",
  "fixed_code": "import sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import gcd,log,sqrt\nfrom atcoder.modint import ModContext, Modint\n\nModContext(1).context.append(998244353)\nsys.setrecursionlimit(1000000)\n\ninput = lambda :sys.stdin.readline().rstrip()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\na, N = mi()\nans = 1 << 60\ndi = defaultdict(lambda: 1 << 60)\ndef change(x, cnt):\n    # print(x, cnt)\n    if di[x] != 0 and di[x] <= cnt:\n        return\n    di[x] = cnt\n    global ans\n    if x == 1:\n        ans = min(ans, cnt)\n        return\n    if x % a == 0:\n        change(x // a, cnt + 1)\n    d = sum(c.isdigit() for c in str(x))\n    if d == 1:\n        return\n    nx = (x % (10 ** (d - 1))) * 10 + x // (10 ** (d-1))\n    change(nx, cnt + 1)\n    return\nchange(N, 0)\nif ans == 1 << 60:\n    print(-1)\nelse:\n    print(ans)\n"
}