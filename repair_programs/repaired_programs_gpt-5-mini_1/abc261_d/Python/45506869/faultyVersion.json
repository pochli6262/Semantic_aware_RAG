{
  "explanation": "The bug was in the line that updates dp[i+1][0]. It used dp[i][j], which can refer to states where more than 0 items were selected in the previous step — those cannot transition to selecting 0 items now. The correct previous state to carry over is dp[i][0]. I fixed the line to use dp[i][0] instead of dp[i][j]. No other lines were changed.",
  "fixed_code": "import sys\nimport re\nfrom math import ceil, floor, sqrt, pi, factorial, gcd\nfrom copy import deepcopy\nfrom collections import Counter, deque, defaultdict\nfrom heapq import heapify, heappop, heappush\nfrom itertools import accumulate, product, combinations, combinations_with_replacement, permutations\nfrom bisect import bisect, bisect_left, bisect_right\nfrom functools import reduce\nfrom decimal import Decimal, getcontext\n\n\ndef input(): return sys.stdin.readline().strip()\ndef i_input(): return int(input())\ndef i_map(): return map(int, input().split())\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input() for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\ndef lcm(a, b): return a * b // gcd(a, b)\ndef rotate90(S): return list(zip(*S[::-1]))\ndef rotate180(S): return list(zip(*list(zip(*S[::-1]))[::-1]))\ndef rotate270(S): return list(zip(*S))[::-1]\n\n\nsys.setrecursionlimit(10 ** 6)\nINF = float('inf')\nMOD = 10 ** 9 + 7\nDIRECTION = [\n    (1, 0),\n    (1, 1),\n    (0, 1),\n    (-1, 1),\n    (-1, 0),\n    (-1, -1),\n    (0, -1),\n    (1, -1),\n]\n\n\ndef main():\n    N, M = i_map()\n    X = i_list()\n    CY = i_row_list(M)\n\n    Y = [0 for _ in range(N+1)]\n    for c, y in CY:\n        Y[c] = y\n    # print(Y)\n\n    dp = [[-MOD for _ in range(N+1)] for _ in range(N+1)]\n\n    dp[0][0] = 0\n\n    for i in range(N):\n        for j in range(N):\n            # 0のとき\n            dp[i+1][0] = max(dp[i][0], dp[i+1][0])\n\n            # 1のとき\n            dp[i+1][j+1] = max(dp[i][j]+X[i]+Y[j+1], dp[i+1][j+1])\n\n    # for d in dp:\n    #     print(d)\n\n    print(max(dp[-1]))\n\n\nif __name__ == '__main__':\n    main()\n"
}