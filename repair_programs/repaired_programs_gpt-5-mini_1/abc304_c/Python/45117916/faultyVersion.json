{
  "explanation": "The code checked membership against dict[0], assuming the root of the component containing node 0 is always 0. But after unions the representative (root) of node 0 may be a different index. I changed that single line to check membership in the component keyed by uf.find(0), i.e. dict[uf.find(0)], so we correctly test whether each node is in the same connected component as node 0.",
  "fixed_code": "# Python3/Pypy3テンプレート集\n\n#ライブラリ-------------------------------------------------------------------\nfrom bisect import *\nimport heapq\nimport collections\nfrom collections import deque\nfrom queue import Queue\nfrom itertools import groupby\nimport itertools\nimport math\nimport array\nimport string\nimport copy\nfrom decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN\nfrom functools import reduce\nfrom operator import and_, or_, xor\n\n#便利スクリプト---------------------------------------------------------------\nINF = 10**20\nmod = 998244353\nMOD = 10**9+7\ndef YesNo(b): print(\"Yes\") if b else print(\"No\")\ndef YESNO(b): print(\"YES\") if b else print(\"NO\")\n\n#標準入力---------------------------------------------------------------------\nimport sys\nsys.setrecursionlimit(10 ** 5 + 10000)\ninput = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\ndef II(): return int(input())\ndef MI(): return map(int, input().split())\ndef MI1(): return map(int1, input().split())\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LIS(): return list(map(int, SI()))\ndef LA(f): return list(map(f, input().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return input().strip('\\n')\ndef MS(): return input().split()\ndef LS(): return list(input().strip('\\n'))\ndef LLS(rows_number): return [LS() for _ in range(rows_number)]\ndef LMS(rows_number): return [MS() for _ in range(rows_number)]\n\n#関数------------------------------------------------------------------------\n###標準ライブラリ###\ndef ceil(a,b): #切り捨て\n    return (a+b-1)//b\n\ndef inv(a,p): #aのpを法とする逆元(aとpは互いに素)\n    return pow(a,p-2,p)%p\n\ndef transpose(A): #二次元配列の転置\n    A_t = []\n    for i in range(len(A[0])) :\n        tmp = []\n        for v in A :\n            tmp.append(v[i])\n        A_t.append(tmp)\n    return A_t\n\ndef rotate_matrix(A): #グリッドを時計回りに90度回転\n    return transpose(A[::-1])\n\ndef removeDuplicates_2D(A): #二次元配列の重複削除\n    return list(map(list, set(map(tuple, A))))\n\ndef convert(S,c): # グリッドをの 黒 マスの点集合に変換する | S: グリッド c:黒マスがなにか(ex #,1)\n    s = set()\n    h = len(S)\n    w = len(S[0])\n    for i in range(h):\n        for j in range(w):\n            if S[i][j] == c:\n                s.add((i, j))\n    return s\n\ndef normalize(s): # グリッドの # マスの点集合を与えると最小の x 座標と最小の y 座標がともに 0 となるように平行移動して返す\n    mi = min(i for (i, j) in s)\n    mj = min(j for (i, j) in s)\n    return set((i - mi, j - mj) for (i, j) in s)\n\ndef cumulativeSum_1D(A): #配列Aの累積和\n  return list(itertools.accumulate(A))\n\ndef cumulativeSum_2D(S): #二次元配列Sの累積和 => 二次元リスト\n    h = len(S)\n    w = len(S[0])\n    CS = [[0 for _ in range(w)]for _ in range(h)]\n    CCS = [[0 for _ in range(w)]for _ in range(h)]\n    for i in range(h):\n        for j in range(w):\n            if(j==0):\n                CS[i][0] = S[i][0]\n            else:\n                CS[i][j] = CS[i][j-1] + S[i][j]\n    for i in range(h):\n        for j in range(w):\n            if(i==0):\n                CCS[0][j] = CS[0][j]\n            else:\n                CCS[i][j] = CCS[i-1][j] + CS[i][j]\n    return CCS\n\ndef string_to_runLength(S: str): #文字列/リストからラングレス圧縮\n    grouped = groupby(S)\n    res = []\n    for k, v in grouped:\n        res.append((k, int(len(list(v)))))\n    return res\n\ndef runLength_to_string(L: \"list[tuple]\"): #ラングレス圧縮から文字列 => 文字だけ\n    res = \"\"\n    for c, n in L:\n        res += c * int(n)\n    return res\n\ndef bfs(i,G): # i:始点\n    n = len(G)\n    dist = [-1] * n\n    pre = [-1] * n\n    que = deque()\n    dist[i] = 0\n    que.append(i)\n    while not len(que)==0:\n            v = que.popleft()\n            for next_v in G[v]:\n                    if dist[next_v] != -1:\n                        continue\n                    dist[next_v] = dist[v] + 1\n                    pre[next_v] = v\n                    que.append(next_v)\n    return dist,pre\n\ndef bfs01(s, G): # i:始点 => dist\n    N = len(G)\n    dist = [INF] * N\n    S = deque([s])\n    T = deque()\n    dist[s] = 0\n    \n    d = 0\n    while S:\n        while S:\n            v = S.popleft()\n            for c, w in G[v]:\n                if d+c < dist[w]:\n                    dist[w] = d+c\n                    if c:\n                        T.append(w)\n                    else:\n                        S.append(w)\n        S, T = T, S\n        d += 1\n    return dist\n\ndef dijkstra(s,G): #s:始点 => cost,pre | G:タプルの中身(コスト,行先)\n    n = len(G)\n    hq = [(0, s)]\n    heapq.heapify(hq)\n    cost = [INF]*n\n    cost[s]= 0\n    pre = [-1] * n\n    while hq:\n        c,v = heapq.heappop(hq)\n        if c > cost[v]:\n            continue\n        for d,u in G[v]:\n            tmp = d+cost[v]\n            if tmp < cost[u]:\n                cost[u] = tmp\n                pre[u] = v\n                heapq.heappush(hq,(tmp,u))\n    return cost, pre\n\ndef coordinates(A): # 変換表(元の値 : 座標圧縮の値),変換表2(座標圧縮の値: 元の値), 圧縮後配列\n    B = sorted(set(A))\n    C = { v: i for i, v in enumerate(B) }\n    D = { i: v for i, v in enumerate(B) }\n    E = list(map(lambda v: C[v], A))\n    return C, D, E\n\ndef eng_L(): return list(string.ascii_lowercase)\n\ndef ENG_L(): return list(string.ascii_uppercase)\n\ndef bit_len(n): #bit長\n    return n.bit_length()\n\ndef bit_cnt(n): # bitにしたときの1の数\n    cnt = 0\n    for i in range(bit_len(n)+1):\n        cnt += n>>i & 1\n    return cnt\n\ndef idx_le(A, x): # x 以下の最大の要素位置 / なければ \"No\"\n    return bisect_right(A, x)-1 if bisect_right(A, x)-1 != -1 else \"No\"\n\ndef idx_lt(A, x):  # x 未満の最大の要素位置 / なければ \"No\"\n    return bisect_left(A, x)-1 if bisect_right(A, x)-1 != -1 else \"No\"\n\ndef idx_ge(A, x): # x 以上の最小の要素位置 / なければ \"No\"\n    return bisect_left(A, x) if bisect_left(A, x) != len(A) else \"No\"\n\ndef idx_gt(A, x): # x 超過の最小の要素位置 / なければ \"No\"\n    return bisect_right(A, x) if bisect_right(A, x) != len(A) else \"No\"\n\ndef cnt_le(A, x): # x 以下の要素の個数\n    if(idx_le(A, x) == \"No\"): return 0\n    return idx_le(A, x) + 1\n\ndef cnt_lt(A, x): # x 未満の要素の個数\n    if(idx_lt(A, x) == \"No\"): return 0\n    return idx_lt(A, x) + 1\n\ndef cnt_ge(A, x): # x 以上の要素の個数\n    return len(A) - cnt_lt(A, x)\n\ndef cnt_gt(A, x): # x 超過の要素の個数\n    return len(A) - cnt_le(A, x)\n\n###数学ライブラリ###\ndef allAND(A): # 配列Aの総AND\n    return reduce(and_, A)\n\ndef allOR(A): # 配列Aの総OR\n    return reduce(or_, A)\n\ndef allXOR(A): # 配列Aの総XOR\n    return reduce(xor, A)\n\ndef allGCD(A): # 配列Aの総GCD\n    if(len(A)==1):\n        return A[0]\n    g = math.gcd(A[0],A[1])\n    for i in range(1,len(A)):\n        g = math.gcd(g, A[i])\n    return g\n\ndef mex(A): #配列Aのmexを求める\n    B = set()\n    for a in A:\n        if(a>=0):\n            B.add(a)\n    B = list(B)\n    B.sort()\n    if(len(B)==0):\n        return 0\n    if(B[0]!=0):\n        return 0\n    m = 0\n    for i in range(1,len(B)):\n        if(B[i]==B[i-1]+1):\n            m +=1\n        else:\n            break\n    return m +1\n\ndef gcd(a,b): #aとbの最大公約数を求める\n    return math.gcd(a,b)\n\ndef lcm(a,b): #aとbの最小公倍数を求める\n    return a*b//gcd(a,b)\n\ndef extgcd(a, b): # a,b =>ax+by=gcd(a,b)を満たす(g,x,y) a,bが互いに素のとき、xはaのbを法とする逆元\n    if b:\n        d, y, x = extgcd(b, a % b)\n        y -= (a // b)*x\n        return d, x, y\n    return a, 1, 0\n\ndef fact_L(n,mod): # [0!, 1! ..., n!] を返す\n    fact = [1]\n    p = 1\n    for i in range(1,n+1):\n        p *= i\n        p %= mod\n        fact.append(p)\n    return fact\n\ndef bitCount_L(n): # n以下のそれぞれのbitカウントを返す\n    bitcount = [0] * (n+1)\n    for i in range(1,n+1):\n        bitcount[i] = bitcount[i//2] + i%2\n    return bitcount\n\ndef factorial(n, m=0): #nの階乗 | m:mod(デフォなし)\n    if(n<0):\n        return -1\n    elif(n==0):\n        return 1\n    P = 1\n    for i in range(1,n+1):\n        P *= i\n        if(m==0):\n          continue\n        P %= m\n    return P\n\ndef nPr(n, r, m=0): #順列nPr\n    if(n<=0 or r<0 or n<r):\n        return -1\n    if(r==0):\n        return 1\n    P = 1\n    for i in range(n,n-r,-1):\n        P *= i\n        if(m==0):\n          continue\n        P %= m\n    return P\n\ndef nCr(n, r, m=0): #組み合わせnCr\n    if(n<r):\n        return 0\n    if(n==r):\n        return 1\n    if(n<=0 or r<0 or n<r):\n        return -1\n    N = 1\n    for i in range(r):\n        N *= n-i\n        if(m==0):\n            continue\n        N %= m\n    R = factorial(r)\n    return N//R\n\ndef nCrm(n,r,m=mod): #逆元を用いた組み合わせnCr%mod\n    if(n<r):\n        return 0\n    if(n==r):\n        return 1\n    if(n<=0 or r<0 or n<r):\n        return -1\n    over=1\n    for i in range(n-r+1,n+1):\n        over *= i\n        over %= m\n    under=1\n    for i in range(1,r+1):\n        under *= i\n        under %= m\n    return over*pow(under,m-2,m)%m\n\ndef is_prime(n): #素数判定 => True/False\n    if n == 2:\n        return 1\n    if n == 1 or n%2 == 0:\n        return 0\n    m = n - 1\n    lsb = m & -m\n    s = lsb.bit_length()-1\n    d = m // lsb\n    test_numbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in test_numbers:\n        if a == n:\n            continue\n        x = pow(a,d,n)\n        r = 0\n        if x == 1:\n            continue\n        while x != m:\n            x = pow(x,2,n)\n            r += 1\n            if x == 1 or r == s:\n                return 0\n    return 1\n\ndef prime_L(n): #n以下の素数のリスト\n    is_prime = [True] * (n + 1)\n    is_prime[0] = False\n    is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if not is_prime[i]:\n            continue\n        for j in range(i * 2, n + 1, i):\n            is_prime[j] = False\n    return [i for i in range(n + 1) if is_prime[i]]\n\ndef find_prime_factor(n):\n    if n%2 == 0:\n        return 2\n    m = int(n**0.125)+1\n    for c in range(1,n):\n        f = lambda a: (pow(a,2,n)+c)%n\n        y = 0\n        g = q = r = 1\n        k = 0\n        while g == 1:\n            x = y\n            while k < 3*r//4:\n                y = f(y)\n                k += 1\n            while k < r and g == 1:\n                ys = y\n                for _ in range(min(m, r-k)):\n                    y = f(y)\n                    q = q*abs(x-y)%n\n                g = math.gcd(q,n)\n                k += m\n            k = r\n            r *= 2\n        if g == n:\n            g = 1\n            y = ys\n            while g == 1:\n                y = f(y)\n                g = math.gcd(abs(x-y),n)\n        if g == n:\n            continue\n        if is_prime(g):\n            return g\n        elif is_prime(n//g):\n            return n//g\n        else:\n            return find_prime_factor(g)\n\ndef primeFactorization_2L(n): #2以上の整数n => [[素因数, 指数], ...]の2次元リスト\n    if(n<=10**6):\n        arr = []\n        temp = n\n        for i in range(2, int(-(-n**0.5//1))+1):\n            if temp%i==0:\n                cnt=0\n                while temp%i==0:\n                    cnt+=1\n                    temp //= i\n                arr.append([i, cnt])\n        if temp!=1:\n            arr.append([temp, 1])\n        if arr==[]:\n            arr.append([n, 1])\n        return arr\n    else:\n        res = {}\n        while not is_prime(n) and n > 1:\n            p = find_prime_factor(n)\n            s = 0\n            while n%p == 0:\n                n //= p\n                s += 1\n            res[p] = s\n        if n > 1:\n            res[n] = 1\n        R = []\n        for r in res:\n            R.append([r,res[r]])\n        R.sort()\n        return R\n\ndef divisor_L(n): #nまでの約数のリスト\n    if(n==1):\n        return [1]\n    if(n<=10**6):\n        lower_divisors , upper_divisors = [], []\n        i = 1\n        while i*i <= n:\n            if n % i == 0:\n                lower_divisors.append(i)\n                if i != n // i:\n                    upper_divisors.append(n//i)\n            i += 1\n        return lower_divisors + upper_divisors[::-1]\n    else:\n        L = primeFactorization_2L(n)\n        E = [[]for i in range(len(L))]\n        for i in range(len(L)):\n            for j in range(L[i][1]+1):\n                E[i].append(L[i][0]**j)\n        D = []\n        for p in list(itertools.product(*E)):\n            s = 1\n            for v in p:\n                s *= v\n            D.append(s)\n        D.sort()\n        return D\n\ndef floorsqrt(n): # N => ⌊√N⌋\n\t# only for n <= 10 ** 18\n\tok = 10 ** 9 + 10\n\tng = 0\n\twhile ok - ng > 1:\n\t\tt = (ok + ng) // 2\n\t\tif t * t > n: ok = t\n\t\telse: ng = t\n\treturn ng\n\ndef decimal_to_nAry(num_10,n): #10進数からn進数へ変換する(n<=36) |int型 => str型\n    str_n = []\n    while num_10:\n        if num_10%n >= 10:\n            str_n.append(chr(num_10%n+55))\n        else:\n            str_n.append(str(num_10%n))\n        num_10 //= n\n    return \"\".join(str_n[::-1])\n\ndef nAry_to_decimal(X,n): #n進数から10進数へ変換する(n<=36) | str型 => int型\n    num = 0\n    X = X.upper()\n    X = list(X)\n    for i in range(len(X)):\n        if((\"0\"<=X[i]<=\"9\")==False):\n            X[i] = str(ord(X[i]) - 55)\n    for i in range(1,len(X)+1):\n        num += int(X[-i]) * pow(n, (i-1))\n    return num\n\ndef roundOff(x,d): #四捨五入する x:対象の数字, d:四捨五入する位(正|負) => float型の数値\n    return float(Decimal(x).quantize(Decimal(f\"1E{d}\"), rounding=ROUND_HALF_UP))\n\n###幾何ライブラリ###\ndef dsin(d): #度数法でsinを計算する\n    return math.sin(math.radians(d))\n\ndef dcos(d): #度数法でcosを計算する\n    return math.cos(math.radians(d))\n\ndef rotate(x,y,d,cx=0,cy=0): #P(x,y)をA(cx,cy)を中心としてに反時計回りにd°回転 => [x,y]\n  nx = (x-cx)*dcos(d)-(y-cy)*dsin(d)\n  ny = (x-cx)*dsin(d)+(y-cy)*dcos(d)\n  return [nx+cx,ny+cy]\n\ndef findAngle(O,A,B): #∠AOBを求める(弧度法)\n    s = [A[0]-O[0],A[1]-O[1]]\n    t = [B[0]-O[0],B[1]-O[1]]\n    u = s[0]*t[0]+s[1]*t[1]\n    l = (s[0]**2+s[1]**2)**(1/2) * (t[0]**2+t[1]**2)**(1/2)\n    v = u/l\n    t = math.degrees(math.acos(v))\n    return t\n\ndef outerProduct(Av,Bv): #二次元ベクトルの外積(=符号付面積)を求める(a×b)\n    return Av[0]*Bv[1] - Bv[0]*Av[1]\n\ndef CCW(O,A,B): #Oを中心として、Aから見たAとBの位置関係を求める。\n    # -1: 時計回り, 0: 一直線上, 1: 反時計回り\n    s = [A[0]-O[0],A[1]-O[1]]\n    t = [B[0]-O[0],B[1]-O[1]]\n    op = outerProduct(s,t)\n    if(op > 0): return 1\n    if(op < 0): return -1\n    if(op == 0): return 0\n\ndef matrixMultiplication_2D(a,b,m): #行列の掛け算(a×b) m:mod\n    I,J,K,L = len(a),len(b[0]),len(b),len(a[0])\n    if(L!=K):\n        return -1\n    c = [[0] * J for _ in range(I)]\n    for i in range(I) :\n        for j in range(J) :\n            for k in range(K) :\n                c[i][j] += a[i][k] * b[k][j]\n            c[i][j] %= m\n    return c\n\ndef matrixExponentiation_2D(x,n,m): #行列の累乗 (x^n) m:mod\n    y = [[0] * len(x) for _ in range(len(x))]\n    for i in range(len(x)):\n        y[i][i] = 1\n    while n > 0:\n        if n & 1:\n            y = matrixMultiplication_2D(x,y,m)\n        x = matrixMultiplication_2D(x,x,m)\n        n >>= 1\n    return y\n\ndef twoCircles(A,B): #二つの円の半径の位置関係 | 引数はそれぞれ[x,y(=座標),r(=半径)]\n    # 1 :　一方の円が他方の円を完全に含み、2 つの円は接していない\n    # 2 :　一方の円が他方の円を完全に含み、2 つの円は接している\n    # 3 :　2 つの円が互いに交差する\n    # 4 :　2 つの円の内部に共通部分は存在しないが、2 つの円は接している\n    # 5 :　2 つの円の内部に共通部分は存在せず、2 つの円は接していない\n    x1 = A[0]\n    x2 = B[0]\n    y1 = A[1]\n    y2 = B[1]\n    r1 = A[2]\n    r2 = B[2]\n    d = abs((x1-x2)+1j*(y1-y2))\n    if(abs(r2-r1)>d):\n        return 1\n    elif(abs(r2-r1)==d):\n        return 2\n    elif(r1+r2>d):\n        return 3\n    elif(r1+r2==d):\n        return 4\n    elif(r1+r2<d):\n        return 5\n\n###デバッグ用ライブラリ###\ndef TS(_str): #変数/リストに格納されている値を確認\n    print('{}: {}'.format(_str, eval(_str)))\n\ndef T2d(A): #二次元配列の確認用\n    for a in A:\n        print(*a)\n\ndef T3d(A): #三次元配列の確認用\n    for a in A:\n        T2d(a)\n        BR()\n\ndef BR(): #横線で区切りを入れる\n    print(\"---\")\n\n#クラス----------------------------------------------------------------------\nfrom collections import defaultdict\n \nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n \n        if x == y:\n            return\n \n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n \n    def size(self, x):\n        return -self.parents[self.find(x)]\n \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n \n    def group_count(self):\n        return len(self.roots())\n \n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n \n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\n\n#カンニングペーパー-----------------------------------------------------------\n'''\n###標準ライブラリ###\nceil(a,b): #切り捨て\ninv(a,p): #xのpを法とする逆元\ntranspose(A): #二次元配列の転置\nrotate_matrix(A): #グリッドを時計回りに90度回転\nremoveDuplicates_2D(A): #二次元配列の重複削除\nconvert(S, c): # グリッドをの 黒 マスの点集合に変換する | S: グリッド c:黒マスがなにか(ex #,1)\nnormalize(s): # グリッドの # マスの点集合を与えると最小の x 座標と最小の y 座標がともに 0 となるように平行移動して返す\n例)normalize(convert(h,w,A))\ncumulativeSum_1D(A) #配列Aの累積和\ncumulativeSum_2D(S): #二次元配列Sの累積和 => 二次元リスト\nstring_to_runLength(S: str) #文字列/リストからラングレス圧縮 => [(文字,個数), ...]の二次元リスト\nrunLength_to_string(L: \"list[tuple]\") #ラングレス圧縮 => 文字列\nbfs(i,G) # i:始点 => dist,pre\nbfs01(i,G) # i:始点 => dist\ndijkstra(s,G): #s:始点 => cost,pre | G:タプルの中身(コスト,行先)\ncoordinates(A) # 変換表(元の値 : 座標圧縮の値),変換表2(座標圧縮の値: 元の値), 圧縮後配列\neng_L() #英小文字のリスト\nENG_L() #英大文字のリスト\nbit_len(n): #bit長\nbit_cnt(n): # bitにしたときの1の数\nidx_le(A, x) # x 以下の最大の要素位置 / なければ \"No\"\nidx_lt(A, x) # x 未満の最大の要素位置 / なければ \"No\"\nidx_ge(A, x) # x 以上の最小の要素位置 / なければ \"No\"\nidx_gt(A, x) # x 超過の最小の要素位置 / なければ \"No\"\ncnt_le(A, x) # x 以下の要素の個数\ncnt_lt(A, x) # x 未満の要素の個数\ncnt_ge(A, x) # x 以上の要素の個数\ncnt_gt(A, x) # x 超過の要素の個数\n\n###数学ライブラリ###\nallAND(A): # 配列Aの総AND\nallOR(A): # 配列Aの総OR\nallXOR(A): # 配列Aの総XOR\nallGCD(A): # 配列Aの総GCD\nmex(A) #配列Aのmexを求める\ngcd(a,b) #aとbの最大公約数を求める\nlcm(a,b) #aとbの最小公倍数を求める\nextgcd(a, b): # a,b =>ax+by=gcd(a,b)を満たす(g,x,y) a,bが互いに素のとき、xはaのbを法とする逆元\nfact_L(n,mod): # [0!, 1! ..., n!] を返す\nbitCount_L(n): # n以下のそれぞれのbitカウントを返す\nfactorial(n,m) #nの階乗 | m:mod(デフォなし)\nnPr(n,r,m) #順列nPr | m:mod(デフォなし)\nnCr(n,r,m) #組み合わせ,nCr | m:mod(デフォなし)\nnCrm(n,r,m) #逆元を用いた組み合わせnCr%mod\ndivisor_L(n) #nの約数のリスト\nis_prime(n) #素数判定 => True/False\nprime_L(n) #nまでの素数のリスト\nprimeFactorization_2L(n) #2以上の整数n => [[素因数, 指数], ...]の2次元リスト\nfloorsqrt(n): # N => ⌊√N⌋\ndecimal_to_nAry(num_10,n) #10進数からn進数へ変換する(n<=36) |int型 => str型\nnAry_to_decimal(num_n,n) #n進数から10進数へ変換する(n<=36) | str型 => int型\nroundOff(x,d): #四捨五入する x:対象の数字, d:四捨五入する位(正|負) => float型の数値\n\n###幾何ライブラリ###\ndsin(d): #度数法でsinを計算する\ndcos(d): #度数法でcosを計算する\nrotate(x,y,d,cx,cy): #P(x,y)をA(cx,cy)を中心としてに反時計回りにd°回転(デフォ原点) => [x,y]\nfindAngle(O,A,B) #∠AOBを求める(弧度法) | 引数はそれぞれ[x,y(=座標)]\nouterProduct(Av,Bv) #二次元ベクトルの外積(=符号付面積)を求める(a×b) | 引数はそれぞれ[x,y(=座標)]\nCCW(O,A,B) #Oを中心として、Aから見たAとBの位置関係\n=> -1:時計回り, 0:一直線上, 1:反時計回り | 引数はそれぞれ[x,y(=座標)]\nmatrixMultiplication_2D(a,b,m) #行列の掛け算(a×b) m:mod | 引数は二次元リスト\nmatrixExponentiation_2D(x,n m)#行列の累乗 (x^n) m:mod | 引数は二次元リスト\ntwoCircles(A,B): #二つの円の半径の位置関係 | 引数はそれぞれ[x,y(=座標),r(=半径)]\n=> 1, 2, 3, 4, 5 各数字に対応する位置関係の説明は上記参照\n\n###デバッグ用ライブラリ###\nTS(_str) # 変数/リストに格納されている値を確認 => 〇〇:××\nT2d(A): # 二次元配列の確認用\nT3d(A): # 三次元配列の確認用\nBR() # 横線で区切りを入れる\n\n###文法チートシート###\n|S|<x => \"0\"*(x-|S|) + S : str(n).zfill(x)\n全部大文字に変換：str.upper()\n全部小文字に変換：str.lower()\n先頭のみ大文字に変換：str.capitalize()\n各単語の先頭のみ大文字に変換（タイトルケース）:str.title()\n大文字と小文字を入れ替える：str.swapcase()\n文字 → ASCIIコード ord(s)\nASCIIコード → 文字 chr(x)\nASCII表\n65:A ~ 90:Z\n97:a ~ 122:z\n'''\n\n#PyPyで再帰関数を用いる場合はコメントを外す----------------------------------\n# import pypyjit\n# pypyjit.set_param('max_unroll_recursion=-1')\n\n#----------------------------------------------------------------------------\nN, D = MI()\nA = LLI(N)\n\ndef isVirus(X1,Y1,X2,Y2):\n    return ((X1-X2)**2 + (Y1-Y2)**2)**(1/2) <= D\n\nuf = UnionFind(N)\n\nfor i in range(N):\n    for j in range(N):\n        if(isVirus(A[i][0],A[i][1],A[j][0],A[j][1])):\n            uf.union(i,j)\n            \ndict = uf.all_group_members()\n\n\nfor i in range(N):\n    if(i in dict[uf.find(0)]):\n        print('Yes')\n    else:\n        print('No')\n"
}