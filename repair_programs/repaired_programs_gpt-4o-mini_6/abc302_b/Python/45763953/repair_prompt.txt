You are a Python expert.

A user gives you the following Python program which is buggy.

## Problem Description (from dataset)
Score : 250 points

### Problem Statement

There is a grid with H horizontal rows and W vertical columns. Each cell has a lowercase English letter written on it.
We denote by (i, j) the cell at the i-th row from the top and j-th column from the left.

The letters written on the grid are represented by H strings S\_1,S\_2,\ldots, S\_H, each of length W.
The j-th letter of S\_i represents the letter written on (i, j).

There is a unique set of
**contiguous cells (going vertically, horizontally, or diagonally)** in the grid
with `s`, `n`, `u`, `k`, and `e` written on them in this order.  
Find the positions of such cells and print them in the format specified in the Output section.

A tuple of five cells (A\_1,A\_2,A\_3,A\_4,A\_5) is said to form
a set of **contiguous cells (going vertically, horizontally, or diagonally)** with `s`, `n`, `u`, `k`, and `e` written on them in this order
if and only if all of the following conditions are satisfied.

* A\_1,A\_2,A\_3,A\_4 and A\_5 have letters `s`, `n`, `u`, `k`, and `e` written on them, respectively.
* For all 1\leq i\leq 4, cells A\_i and A\_{i+1} share a corner or a side.
* The centers of A\_1,A\_2,A\_3,A\_4, and A\_5 are on a common line at regular intervals.

### Constraints

* 5\leq H\leq 100
* 5\leq W\leq 100
* H and W are integers.
* S\_i is a string of length W consisting of lowercase English letters.
* The given grid has a unique conforming set of cells.

---

### Input

The input is given from Standard Input in the following format:

```
H W
S_1
S_2
\vdots
S_H
```

### Output

Print five lines in the following format.

Let (R\_1,C\_1), (R\_2,C\_2)\ldots,(R\_5,C\_5) be the cells in the sought set with `s`, `n`, `u`, `k`, and `e` written on them, respectively.
The i-th line should contain R\_i and C\_i in this order, separated by a space.

In other words, print them in the following format:

```
R_1 C_1
R_2 C_2
\vdots
R_5 C_5
```

See also Sample Inputs and Outputs below.

---

### Sample Input 1

```
6 6
vgxgpu
amkxks
zhkbpp
hykink
esnuke
zplvfj
```

### Sample Output 1

```
5 2
5 3
5 4
5 5
5 6
```

Tuple (A\_1,A\_2,A\_3,A\_4,A\_5)=((5,2),(5,3),(5,4),(5,5),(5,6)) satisfies the conditions.  
Indeed, the letters written on them are `s`, `n`, `u`, `k`, and `e`;  
for all 1\leq i\leq 4, cells A\_i and A\_{i+1} share a side;  
and the centers of the cells are on a common line.

![](https://img.atcoder.jp/abc302/f0a6b1007df7fb00caa27a5f82a3afb1.png)

---

### Sample Input 2

```
5 5
ezzzz
zkzzz
ezuzs
zzznz
zzzzs
```

### Sample Output 2

```
5 5
4 4
3 3
2 2
1 1
```

Tuple (A\_1,A\_2,A\_3,A\_4,A\_5)=((5,5),(4,4),(3,3),(2,2),(1,1)) satisfies the conditions.  
However, for example, (A\_1,A\_2,A\_3,A\_4,A\_5)=((3,5),(4,4),(3,3),(2,2),(3,1)) violates the third condition because the centers of the cells are not on a common line, although it satisfies the first and second conditions.

---

### Sample Input 3

```
10 10
kseeusenuk
usesenesnn
kskekeeses
nesnusnkkn
snenuuenke
kukknkeuss
neunnennue
sknuessuku
nksneekknk
neeeuknenk
```

### Sample Output 3

```
9 3
8 3
7 3
6 3
5 3
```

## Your Analysis (1-sentence bug summary)
The program likely has an issue with correctly handling the conditions for checking diagonals, especially when verifying if the centers of the cells are on a common line at regular intervals.

## Buggy Program
import sys
input = lambda: sys.stdin.readline().strip()

h, w = map(int, input().split())
rc = [input() for _ in range(h)]
snuke = 'snuke'

# 横
for i in range(h):
    for j in range(w-4):
        if rc[i][j:j+5] == snuke:
           for k in range(j, j+5):
               print(i+1, k+1)
        if ''.join(list(reversed(rc[i][j:j+5]))) == snuke:
            for k in reversed(range(j, j+5)):
                print(i+1, k+1)

# 縦
for i in range(w):
    for j in range(h-4):
        if rc[j][i]+rc[j+1][i]+rc[j+2][i]+rc[j+3][i]+rc[j+4][i] == snuke:
            for k in range(5):
                print(j+k+1, i+1)
        if ''.join(list(reversed(rc[j][i]+rc[j+1][i]+rc[j+2][i]+rc[j+3][i]+rc[j+4][i]))) == snuke:
            for k in reversed(range(5)):
                print(j+k+1, i+1)

# 右下斜め
for i in range(h-4):
    for j in range(w-4):
        if rc[i][j]+rc[i+1][j+1]+rc[i+2][j+2]+rc[i+3][j+3]+rc[i+4][j+4] == snuke:
            for k in range(5):
                print(i+k+1, j+k+1) 
        if ''.join(list(reversed(rc[i][j]+rc[i+1][j+1]+rc[i+2][j+2]+rc[i+3][j+3]+rc[i+4][j+4]))) == snuke:
            for k in reversed(range(5)):
                print(i+k+1, j+k+1)

# 右上斜め
for i in range(5, h):
    for j in range(w-4):
        if rc[i][j]+rc[i-1][j+1]+rc[i-2][j+2]+rc[i-3][j+3]+rc[i-4][j+4] == snuke:
            for k in range(5):
                print(i-k+1, j+k+1)
        if ''.join(list(reversed(rc[i][j]+rc[i-1][j+1]+rc[i-2][j+2]+rc[i-3][j+3]+rc[i-4][j+4]))) == snuke:
            for k in reversed(range(5)):
                print(i-k+1, j+k+1)

## Related Known Fixes (retrieved diffs)
### Diff 1
--- 
+++ 
@@ -10,7 +10,7 @@
 for k in range(4):
   for i in range(7-2*k):
     for j in range(7-2*k):
-      if s[i+k+1][j]=="#" and s[i][j+k+1]=="#" and s[i+1][j+2*(k+1)]=="#" and s[i+2*(k+1)][j+k+1]=="#":
+      if s[i+k+1][j]=="#" and s[i][j+k+1]=="#" and s[i+k+1][j+2*(k+1)]=="#" and s[i+2*(k+1)][j+k+1]=="#":
         ans+=1
 for i in range(6):
   for j in range(6):

### Diff 2
--- 
+++ 
@@ -26,9 +26,10 @@
             if count == K:
                 print(*re(j, ind[i]))
                 exit()
-        #print(count, j + 1, i + 1)
+
         if count > K:
             count -= (((N - 2 - j) * (N - j - 1)) // 2)
             count -= N
             visit.add(i)
             break
+print(*A)

### Diff 3
--- 
+++ 
@@ -29,6 +29,8 @@
 for i in range(trial+1):
     for h in range(H):
         for w in range(W):
+            if dp[i][h][w] == -1:
+                continue
             maxv = max(maxv,dp[i][h][w]+A[h][w]*(K-i))
             
 print(maxv)

### Diff 4
--- 
+++ 
@@ -95,11 +95,11 @@
     g = 0
     for u, v in back:
         g = gcd(g, abs(depth[u]+1-depth[v]))
-    
+
     if g==0:
         print("No")
-        exit()
-    
+        return 
+
     while g%5 == 0: g //= 5
     print("Yes" if g == g & -g else "No")
 

### Diff 5
--- 
+++ 
@@ -26,4 +26,4 @@
     
 
 for t in range(H):
-    print(*grid[t])
+    print(*grid[t],sep="")

Your task:
1) Identify the single incorrect line according to the problem summary and the retrieved diffs.
2) Assume EXACTLY ONE line is wrong.
3) Provide the corrected version of the ENTIRE program, changing only that single line — all other lines must remain identical.
4) Do not restructure or rewrite unrelated code.
5) Respond ONLY in JSON format:

{
  "explanation": "Explain what was wrong in that single line and how you fixed it (mention which diff patterns inspired the fix if applicable).",
  "fixed_code": "The FULL program with only that ONE line corrected."
}