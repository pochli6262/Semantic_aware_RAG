You are a Python expert.

A user gives you the following Python program which is buggy.

## Problem Description (from dataset)
Score : 400 points

### Problem Statement

Takahashi will toss a coin N times.
He also has a counter, which initially shows 0.

Depending on the result of the i-th coin toss, the following happens:

* If it heads: Takahashi increases the counter's value by 1 and receives X\_i yen (Japanese currency).
* If it tails: he resets the counter's value to 0, without receiving money.

Additionally, there are M kinds of streak bonuses. The i-th kind of streak bonus awards Y\_i yen **each time** the counter shows C\_i.

Find the maximum amount of money that Takahashi can receive.

### Constraints

* 1\leq M\leq N\leq 5000
* 1\leq X\_i\leq 10^9
* 1\leq C\_i\leq N
* 1\leq Y\_i\leq 10^9
* C\_1,C\_2,\ldots,C\_M are all different.
* All values in input are integers.

---

### Input

Input is given from Standard Input in the following format:

```
N M
X_1 X_2 \ldots X_N
C_1 Y_1
C_2 Y_2
\vdots
C_M Y_M
```

### Output

Print the maximum amount of money that Takahashi can receive, as an integer.

---

### Sample Input 1

```
6 3
2 7 1 8 2 8
2 10
3 1
5 5
```

### Sample Output 1

```
48
```

If he gets head, head, tail, head, head, head, in this order, the following amounts of money are awarded.

* In the 1-st coin toss, the coin heads. Change the counter's value from 0 to 1 and receive 2 yen.
* In the 2-nd coin toss, the coin heads. Change the counter's value from 1 to 2 and receive 7 yen. Additionally, get 10 yen as a streak bonus.
* In the 3-rd coin toss, the coin tails. Change the counter's value from 2 to 0.
* In the 4-th coin toss, the coin heads. Change the counter's value from 0 to 1 and receive 8 yen.
* In the 5-th coin toss, the coin heads. Change the counter's value from 1 to 2 and receive 2 yen. Additionally, get 10 yen as a streak bonus.
* In the 6-th coin toss, the coin heads. Change the counter's value from 2 to 3 and receive 8 yen. Additionally, get 1 yen as a streak bonus.

In this case, Takahashi receives 2+(7+10)+0+8+(2+10)+(8+1)=48 yen in total, which is the maximum possible.  
Note that streak bonuses are awarded any number of times each time the counter shows C\_i.  
As a side note, if he gets head in all 6 coin tosses, he only receives 2+(7+10)+(1+1)+8+(2+5)+8=44 yen, which is not the maximum.

---

### Sample Input 2

```
3 2
1000000000 1000000000 1000000000
1 1000000000
3 1000000000
```

### Sample Output 2

```
5000000000
```

Note that the answer may not fit into a 32-bit integer type.

## Your Analysis (1-sentence bug summary)
The likely bug is that the program incorrectly initializes the dynamic programming table and handles the updates for non-zero counter states, leading to incorrect calculations of the maximum amount of money.

## Buggy Program
# ref: https://qiita.com/Kota-Y/items/396ab3c57830dad65cfb
import sys
import re
from math import ceil, floor, sqrt, pi, factorial, gcd
from copy import deepcopy
from collections import Counter, deque, defaultdict
from heapq import heapify, heappop, heappush
from itertools import accumulate, product, combinations, combinations_with_replacement, permutations
from bisect import bisect, bisect_left, bisect_right
from functools import reduce
from decimal import Decimal, getcontext


def input(): return sys.stdin.readline().strip()
def i_input(): return int(input())
def i_map(): return map(int, input().split())
def i_list(): return list(i_map())
def i_row(N): return [i_input() for _ in range(N)]
def i_row_list(N): return [i_list() for _ in range(N)]
def s_input(): return input()
def s_map(): return input().split()
def s_list(): return list(s_map())
def s_row(N): return [s_input() for _ in range(N)]
def s_row_str(N): return [s_list() for _ in range(N)]
def s_row_list(N): return [list(s_input()) for _ in range(N)]
def lcm(a, b): return a * b // gcd(a, b)
def rotate90(S): return list(zip(*S[::-1]))
def rotate180(S): return list(zip(*list(zip(*S[::-1]))[::-1]))
def rotate270(S): return list(zip(*S))[::-1]


sys.setrecursionlimit(10 ** 6)
INF = float('inf')
MOD = 10 ** 9 + 7
DIRECTION = [
    (1, 0),
    (1, 1),
    (0, 1),
    (-1, 1),
    (-1, 0),
    (-1, -1),
    (0, -1),
    (1, -1),
]


def main():
    N, M = i_map()
    X = i_list()
    CY = i_row_list(M)

    Y = [0 for _ in range(N+1)]
    for c, y in CY:
        Y[c] = y
    # print(Y)

    dp = [[-MOD for _ in range(N+1)] for _ in range(N+1)]

    dp[0][0] = 0

    for i in range(N):
        for j in range(N):
            # 0のとき
            dp[i+1][0] = max(dp[i][j], dp[i+1][0])

            # 1のとき
            dp[i+1][j+1] = max(dp[i][j]+X[i]+Y[j+1], dp[i+1][j+1])

    # for d in dp:
    #     print(d)

    print(max(dp[-1]))


if __name__ == '__main__':
    main()


## Related Known Fixes (retrieved diffs)
### Diff 1
--- 
+++ 
@@ -82,7 +82,7 @@
     for i in range(1, N+1):
         for a in A:
             if i - a >= 0:
-                dp[i] = a + (i - a) - dp[i-a]
+                dp[i] = max(dp[i], a + (i - a) - dp[i-a])
 
     # print(dp)
     print(dp[-1])

### Diff 2
--- 
+++ 
@@ -228,6 +228,8 @@
             else:
                 NOWLEN = 0
                 S = -1 
+                DICT = defaultdict(list)
+                X = set()
                 break
     DICT[a].append((S,NOWLEN))
     SUM += NOWLEN

### Diff 3
--- 
+++ 
@@ -41,5 +41,5 @@
     q-=1
     b = q * B
     if(mod > B):print(b + B)
-    else:print(b+mod)
+    else:print(max(0,b+mod))
 

### Diff 4
--- 
+++ 
@@ -30,7 +30,7 @@
     if m%2==1:
         yn(all(Cnt[i]==0 for i in Cnt.keys()),'Bob','Alice')
     else:
-        yn(all((Cnt[i]==1 and Cnt[(i+(m//2))%m]==1) or (Cnt[i]==0 and Cnt[(i+(m//2))%m]==0) for i in Cnt.keys()),'Bob','Alice')
+        yn(all((Cnt[i]==1 and Cnt[(i+(m//2))%m]==1) or (Cnt[i]==0 and Cnt[(i+(m//2))%m]==0) for i in Cnt.keys()) and sum(Cnt.values())%4==0,'Bob','Alice')
     
 
 

### Diff 5
--- 
+++ 
@@ -34,7 +34,7 @@
 under = [
     ["_" * j for j in i]
     for i in product(list(range(1, 16 - total_length + 1)), repeat=N - 1)
-    if 3 <= sum(i) <= 16 - total_length
+    if sum(i) <= 16 - total_length
 ]
 
 for i in permutations(S):

Your task:
1) Identify the single incorrect line according to the problem summary and the retrieved diffs.
2) Assume EXACTLY ONE line is wrong.
3) Provide the corrected version of the ENTIRE program, changing only that single line — all other lines must remain identical.
4) Do not restructure or rewrite unrelated code.
5) Respond ONLY in JSON format:

{
  "explanation": "Explain what was wrong in that single line and how you fixed it (mention which diff patterns inspired the fix if applicable).",
  "fixed_code": "The FULL program with only that ONE line corrected."
}