You are a Python expert.

A user gives you the following Python program which is buggy.

## Problem Description (from dataset)
Score : 475 points

### Problem Statement

There are N people numbered from 1 to N standing in a circle. Person 1 is to the right of person 2, person 2 is to the right of person 3, ..., and person N is to the right of person 1.

We will give each of the N people an integer between 0 and M-1, inclusive.  
Among the M^N ways to distribute integers, find the number, modulo 998244353, of such ways that no two adjacent people have the same integer.

### Constraints

* 2 \leq N,M \leq 10^6
* N and M are integers.

---

### Input

The input is given from Standard Input in the following format:

```
N M
```

### Output

Print the answer.

---

### Sample Input 1

```
3 3
```

### Sample Output 1

```
6
```

There are six desired ways, where the integers given to persons 1,2,3 are (0,1,2),(0,2,1),(1,0,2),(1,2,0),(2,0,1),(2,1,0).

---

### Sample Input 2

```
4 2
```

### Sample Output 2

```
2
```

There are two desired ways, where the integers given to persons 1,2,3,4 are (0,1,0,1),(1,0,1,0).

---

### Sample Input 3

```
987654 456789
```

### Sample Output 3

```
778634319
```

Be sure to find the number modulo 998244353.

## Your Analysis (1-sentence bug summary)
The likely bug in the program is that it incorrectly calculates the total number of valid configurations by not properly accounting for the circular arrangement of the people, resulting in wrong values for certain scenarios.

## Buggy Program
N,M=map(int,input().split())
mod=998244353

answer=(-1)**(N%2)*(M-1)+pow(M-1,N,mod)
print(answer)

## Related Known Fixes (retrieved diffs)
### Diff 1
--- 
+++ 
@@ -1,12 +1,13 @@
 N, M = map(int, input().split())
- 
+
 P = 1
 ans = 0
- 
+
 for y in range(2, N + 1):
   P = P * (N + 1 - y) % M
   f = P * pow(N, N - y, M)
- 
+
   ans += f * (y - 1) * y // 2
   ans %= M
-  print(ans * N % M)
+
+print(ans * N % M)

### Diff 2
--- 
+++ 
@@ -1,2 +1,2 @@
 N,M,P=map(int,input().split())
-print((N-M)//P+1 if N>M else 0)
+print((N-M)//P+1 if N>=M else 0)

### Diff 3
--- 
+++ 
@@ -2,7 +2,7 @@
 MOD = 998244353
 ret = 0
 for i in range(60):
-    if(M and 2**i):
+    if(M & 2**i):
         tmp = N // ((2**i)*2)
         ret = ret + tmp*(2**i)
         tmp = N % ((2**i)*2)

### Diff 4
--- 
+++ 
@@ -1,6 +1,6 @@
 N,M,P = map(int,input().split())
 count = 0
-while M < N:
+while M <= N:
   count += 1
   M += P
 print(count)

### Diff 5
--- 
+++ 
@@ -3,6 +3,6 @@
 ans = 0
 for i in range(60):
     if (M >> i) & 1:
-        ans += M // (1 << (i + 1)) * (1 << i) + max(0, (M % (1 << (i + 1))) - (1 << i) + 1)
+        ans += N // (1 << (i + 1)) * (1 << i) + max(0, (N % (1 << (i + 1))) - (1 << i) + 1)
         ans %= MOD
 print(ans)

Your task:
1) Identify the single incorrect line according to the problem summary and the retrieved diffs.
2) Assume EXACTLY ONE line is wrong.
3) Provide the corrected version of the ENTIRE program, changing only that single line â€” all other lines must remain identical.
4) Do not restructure or rewrite unrelated code.
5) Respond ONLY in JSON format:

{
  "explanation": "Explain what was wrong in that single line and how you fixed it (mention which diff patterns inspired the fix if applicable).",
  "fixed_code": "The FULL program with only that ONE line corrected."
}