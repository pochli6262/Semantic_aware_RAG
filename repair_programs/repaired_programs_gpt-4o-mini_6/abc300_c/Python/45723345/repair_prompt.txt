You are a Python expert.

A user gives you the following Python program which is buggy.

## Problem Description (from dataset)
Score : 300 points

### Problem Statement

We have a grid with H horizontal rows and W vertical columns. We denote by (i, j) the cell at the i-th row from the top and j-th column from the left of the grid.  
Each cell in the grid has a symbol `#` or `.` written on it. Let C[i][j] be the character written on (i, j). For integers i and j such that at least one of 1 \leq i \leq H and 1 \leq j \leq W is violated, we define C[i][j] to be `.`.

(4n+1) squares, consisting of (a, b) and (a+d,b+d),(a+d,b-d),(a-d,b+d),(a-d,b-d) (1 \leq d \leq n, 1 \leq n), are said to be a **cross of size n centered at (a,b)** if and only if all of the following conditions are satisfied:

* C[a][b] is `#`.
* C[a+d][b+d],C[a+d][b-d],C[a-d][b+d], and C[a-d][b-d] are all `#`, for all integers d such that 1 \leq d \leq n,
* At least one of C[a+n+1][b+n+1],C[a+n+1][b-n-1],C[a-n-1][b+n+1], and C[a-n-1][b-n-1] is `.`.

For example, the grid in the following figure has a cross of size 1 centered at (2, 2) and another of size 2 centered at (3, 7).

![image](https://img.atcoder.jp/ghi/abc300c_aa5161e20f55652dc61ad221348765bb002e4eed378c352bc0e44c7555148ebc.jpg)

The grid has some crosses. No `#` is written on the cells except for those comprising a cross.  
Additionally, no two squares that comprise two different crosses share a corner. The two grids in the following figure are the examples of grids where two squares that comprise different crosses share a corner; **such grids are not given as an input**. For example, the left grid is invalid because (3, 3) and (4, 4) share a corner.

![image2](https://img.atcoder.jp/ghi/abc300c2_796c45899f018c995738383146a76562824a9f6b7a3d931621da691d49d6f3cc.jpg)

Let N = \min(H, W), and S\_n be the number of crosses of size n. Find S\_1, S\_2, \dots, S\_N.

### Constraints

* 3 \leq H, W \leq 100
* C[i][j] is `#` or `.`.
* No two different squares that comprise two different crosses share a corner.
* H and W are integers.

---

### Input

The input is given from Standard Input in the following format:

```
H W
C[1][1]C[1][2]\dots C[1][W]
C[2][1]C[2][2]\dots C[2][W]
\vdots
C[H][1]C[H][2]\dots C[H][W]
```

### Output

Print S\_1, S\_2, \dots, and S\_N, separated by spaces.

---

### Sample Input 1

```
5 9
#.#.#...#
.#...#.#.
#.#...#..
.....#.#.
....#...#
```

### Sample Output 1

```
1 1 0 0 0
```

As described in the Problem Statement, there are a cross of size 1 centered at (2, 2) and another of size 2 centered at (3, 7).

---

### Sample Input 2

```
3 3
...
...
...
```

### Sample Output 2

```
0 0 0
```

There may be no cross.

---

### Sample Input 3

```
3 16
#.#.....#.#..#.#
.#.......#....#.
#.#.....#.#..#.#
```

### Sample Output 3

```
3 0 0
```

---

### Sample Input 4

```
15 20
#.#..#.............#
.#....#....#.#....#.
#.#....#....#....#..
........#..#.#..#...
#.....#..#.....#....
.#...#....#...#..#.#
..#.#......#.#....#.
...#........#....#.#
..#.#......#.#......
.#...#....#...#.....
#.....#..#.....#....
........#.......#...
#.#....#....#.#..#..
.#....#......#....#.
#.#..#......#.#....#
```

### Sample Output 4

```
5 0 1 0 0 0 1 0 0 0 0 0 0 0 0
```

## Your Analysis (1-sentence bug summary)
The bug likely occurs because the program does not correctly account for the condition that requires at least one of the specified surrounding cells to be `.` when determining the size of a cross, potentially leading to incorrect cross size calculations.

## Buggy Program
H,W = map(int,input().split())
C = []
for i in range(H):
    C.append(list(input()))

def check(y,x):
    size = 0
    while True:
        if  (y + (size + 1) < H and x + (size + 1) < W and C[y+(size+1)][x+(size+1)] == '#') and \
            (y + (size + 1) < H and x - (size + 1) >= 0 and C[y+(size+1)][x-(size+1)] == '#') and \
            (y - (size + 1) >= 0 and x + (size + 1) < W and C[y-(size+1)][x+(size+1)] == '#') and \
            (y - (size + 1) >= 0 and x - (size + 1) >= 0 and C[y-(size+1)][x-(size+1)] == '#'):
            size += 1
        else:
            break
    ans[size] += 1

ans = [0 for _ in range(H+1)]

for i in range(H):
    for j in range(W):
        if C[i][j] == '#':
            check(i,j)

print(*ans[1:])

## Related Known Fixes (retrieved diffs)
### Diff 1
--- 
+++ 
@@ -19,7 +19,7 @@
             s[i][j] = max(s[i][j-1], s[i-1][j])+1
         
         if s[i][j] == 1:
-            s[i][j] == 0
+            s[i][j] = 0
 
         if ans < s[i][j]:
              ans = s[i][j]

### Diff 2
--- 
+++ 
@@ -5,7 +5,7 @@
 for a in range(H-1):
 	for b in range(a+1, H):
 		for c in range(W-1):
-			for d in range(b+1, W):
+			for d in range(c+1, W):
 				if A[a][c] + A[b][d] > A[b][c] + A[a][d]:
 					Flag = False
 if Flag:

### Diff 3
--- 
+++ 
@@ -24,7 +24,7 @@
                 bool[H+dh][W+dw]=True
                 box.append((H+dh,W+dw))
 
-    if grid[h][w]:
+    if bool[h][w]:
         print('Yes')
     else:
         print('No')

### Diff 4
--- 
+++ 
@@ -44,7 +44,7 @@
     elif flg:
       S[h][w] = "*"
     h += 1
-  h = 0
+  h = H-1
   flg = False
   while h >= 0:
     if S[h][w] not in ("*", "."):

### Diff 5
--- 
+++ 
@@ -22,7 +22,7 @@
     gi = h - 1 - gi
     S = T
 
-if sj > gj:
+if (sj > gj) or (sj == gj == 1):
     T = [[""] * w for _ in range(h)]
     for i in range(h):
         for j in range(w):
@@ -30,6 +30,8 @@
     sj = w - 1 - sj
     gj = w - 1 - gj
     S = T
+
+
 
 rb = [[0] * w for _ in range(h)]
 

Your task:
1) Identify the single incorrect line according to the problem summary and the retrieved diffs.
2) Assume EXACTLY ONE line is wrong.
3) Provide the corrected version of the ENTIRE program, changing only that single line â€” all other lines must remain identical.
4) Do not restructure or rewrite unrelated code.
5) Respond ONLY in JSON format:

{
  "explanation": "Explain what was wrong in that single line and how you fixed it (mention which diff patterns inspired the fix if applicable).",
  "fixed_code": "The FULL program with only that ONE line corrected."
}