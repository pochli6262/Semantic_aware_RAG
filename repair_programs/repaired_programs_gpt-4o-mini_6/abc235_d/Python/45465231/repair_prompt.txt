You are a Python expert.

A user gives you the following Python program which is buggy.

## Problem Description (from dataset)
Score : 400 points

### Problem Statement

We have a positive integer a. Additionally, there is a blackboard with a number written in base 10.  
Let x be the number on the blackboard. Takahashi can do the operations below to change this number.

* Erase x and write x multiplied by a, in base 10.
* See x as a string and move the rightmost digit to the beginning.  
  This operation can only be done when x \geq 10 and x is not divisible by 10.

For example, when a = 2, x = 123, Takahashi can do one of the following.

* Erase x and write x \times a = 123 \times 2 = 246.
* See x as a string and move the rightmost digit `3` of `123` to the beginning, changing the number from 123 to 312.

The number on the blackboard is initially 1. What is the minimum number of operations needed to change the number on the blackboard to N? If there is no way to change the number to N, print -1.

### Constraints

* 2 \leq a \lt 10^6
* 2 \leq N \lt 10^6
* All values in input are integers.

---

### Input

Input is given from Standard Input in the following format:

```
a N
```

### Output

Print the answer.

---

### Sample Input 1

```
3 72
```

### Sample Output 1

```
4
```

We can change the number on the blackboard from 1 to 72 in four operations, as follows.

* Do the operation of the first type: 1 \to 3.
* Do the operation of the first type: 3 \to 9.
* Do the operation of the first type: 9 \to 27.
* Do the operation of the second type: 27 \to 72.

It is impossible to reach 72 in three or fewer operations, so the answer is 4.

---

### Sample Input 2

```
2 5
```

### Sample Output 2

```
-1
```

It is impossible to change the number on the blackboard to 5.

---

### Sample Input 3

```
2 611
```

### Sample Output 3

```
12
```

There is a way to change the number on the blackboard to 611 in 12 operations: 1 \to 2 \to 4 \to 8 \to 16 \to 32 \to 64 \to 46 \to 92 \to 29 \to 58 \to 116 \to 611, which is the minimum possible.

---

### Sample Input 4

```
2 767090
```

### Sample Output 4

```
111
```

## Your Analysis (1-sentence bug summary)
The likely bug in the program is that it improperly initializes or updates the tracking of the number of operations needed to reach the target number, which could lead to incorrect outputs.

## Buggy Program
import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import gcd,log,sqrt
from atcoder.modint import ModContext, Modint

ModContext(1).context.append(998244353)
sys.setrecursionlimit(1000000)

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

a, N = mi()
ans = 1 << 60
di = defaultdict(int)
def change(x, cnt):
    # print(x, cnt)
    if di[x] != 0 and di[x] <= cnt:
        return
    di[x] = cnt
    global ans
    if x == 1:
        ans = min(ans, cnt)
        return
    if x % a == 0:
        change(x // a, cnt + 1)
    d = sum(c.isdigit() for c in str(x))
    if d == 1:
        return
    nx = (x % (10 ** (d - 1))) * 10 + x // (10 ** (d-1))
    change(nx, cnt + 1)
    return
change(N, 0)
if ans == 1 << 60:
    print(-1)
else:
    print(ans)

## Related Known Fixes (retrieved diffs)
### Diff 1
--- 
+++ 
@@ -21,7 +21,7 @@
     P.append((r, l))
 P.sort()
 ans = 0
-x = -1000
+x = - 1e10
 for i in range(N):
     r, l = P[i]
     if l > x + D - 1:

### Diff 2
--- 
+++ 
@@ -14,7 +14,7 @@
     d[a[i]] += 1
 last = [1]
 tot = 1
-for i in range(1, 2*10**5+10):
+for i in range(1, 3*10**5+10):
     cnt = len(last) - 1
     new = []
     di = d[i]

### Diff 3
--- 
+++ 
@@ -38,7 +38,7 @@
     elif k == 3:
         t = 4
     else:
-        t = f[k-1] + f[k-3]
+        t = f[k-1-1] + f[k-3-1]
     ans *= t
     ans %= MOD
 print(ans) 

### Diff 4
--- 
+++ 
@@ -30,7 +30,7 @@
             print(i)
             exit()
 else:
-    cand = [12345678, 23456789, 76543210, 87654321, 98765432, 876543210, 987654321, 9876543210]
+    cand = [12345678, 23456789, 76543210, 87654321, 98765432, 876543210, 987654321, 9876543210, 123456789]
     cand.append(int(s[0] * len(s)))
     if s[0] == '9':
         cand.append(int('1' * (len(s) + 1)))

### Diff 5
--- 
+++ 
@@ -15,7 +15,7 @@
 
 for i in range(n):
 
-    if a[i]<i :
+    if a[i]<i or a[a[i]] != a[i]:
         print(0)
         exit()
 

Your task:
1) Identify the single incorrect line according to the problem summary and the retrieved diffs.
2) Assume EXACTLY ONE line is wrong.
3) Provide the corrected version of the ENTIRE program, changing only that single line â€” all other lines must remain identical.
4) Do not restructure or rewrite unrelated code.
5) Respond ONLY in JSON format:

{
  "explanation": "Explain what was wrong in that single line and how you fixed it (mention which diff patterns inspired the fix if applicable).",
  "fixed_code": "The FULL program with only that ONE line corrected."
}