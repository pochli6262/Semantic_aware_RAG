{
  "explanation": "The original code incorrectly processes bonus rooms by only allowing a single bonus to be added to the time limit when encountering a bonus room. The correct behavior requires the program to accommodate multiple bonus rooms that may be encountered in sequence without skipping any. This fix was inspired by Diff 1, which highlighted the need for proper boundary management when counting rooms in relation to bonuses.",
  "fixed_code": "N, M, T = map(int, input().split())\nA = list(map(int, input().split()))\nB = []\nfor i in range(M):\n    B.append(tuple(map(int, input().split())))\n\nfrom collections import deque\nqueA = deque(A)\nB.sort(key=lambda x: x[0])\nqueB = deque(B)\n\nans = \"Yes\"\nnowT = T\nnowP = 1\nS = set([row[0] for row in B])\n# print(S)\nfor i in range(N-1):\n    # print(nowT)\n    p = queA.popleft()\n    if nowP in S:\n        # print(\"inS\")\n        while queB and queB[0][0] == nowP:\n            pt = queB.popleft()\n            nowT += pt[1]\n\n    if nowT >= p:\n        nowT -= p\n        nowP += 1\n    else:\n        ans = \"No\"\n        break\n\nprint(ans)"
}