You are a Python repair assistant.

A user gives you the following buggy program.

## Buggy Program
N,X=map(int,input().split())
  
DP=[0]*(X+1) #DP[n]=現在n円払えるか
DP[0]=1
for i in range(N):
  a,b=map(int,input().split())
  for n in range(X+1):
    for c in range(1,b+1):
      if 0<=n-c*a and DP[n-c*a]:
        DP[n]=1
print("Yes" if DP[X] else "No")


## Related Example Fixes (retrieved from similar problems)
These examples are only references. 
They must NOT be copied directly, but can inspire how similar bugs were fixed.

### Example 1
--- Buggy Code ---
n = int(input())
a = list(map(int,input().split()))
ikeru = [[] for i in range(n)]
for i in range(n-1):
	u, v = map(int,input().split())
	u-=1; v-=1
	ikeru[u].append(v)
	ikeru[v].append(u)

def canreach(x):
	#x以上に到達可能か？
	#部分木DP
	mada = [~0, 0]
	tansaku = [0] * n
	tansaku[0] = 1
	dp = [0] * n
	while mada:
		i = mada.pop()
		if i >= 0:
			for j in ikeru[i]:
				if tansaku[j] == 0:
					tansaku[j] = 1
					mada.append(~j)
					mada.append(j)
		else:
			i = ~i
			tmp = 0
			for j in ikeru[i]:
				if tansaku[j] == 2:
					tmp += dp[j]
			tmp = max(0, tmp-1)
			if i >= 1:
				if a[i-1] >= x:
					tmp += 1
			dp[i] = tmp
			tansaku[i] = 2
	if dp[0] >= 1:
		return True
	return False
	

suki = 10**9 + 5
kirai = -1
while suki - kirai > 1:
	targ = (suki + kirai) // 2
	if canreach(targ):
		kirai = targ
	else:
		suki = targ

print(kirai)

--- Correct Code ---
n = int(input())
a = list(map(int,input().split()))
ikeru = [[] for i in range(n)]
for i in range(n-1):
	u, v = map(int,input().split())
	u-=1; v-=1
	ikeru[u].append(v)
	ikeru[v].append(u)

def canreach(x):
	#x以上に到達可能か？
	#部分木DP
	mada = [~0, 0]
	tansaku = [0] * n
	tansaku[0] = 1
	dp = [0] * n
	while mada:
		i = mada.pop()
		if i >= 0:
			for j in ikeru[i]:
				if tansaku[j] == 0:
					tansaku[j] = 1
					mada.append(~j)
					mada.append(j)
		else:
			i = ~i
			tmp = 0
			for j in ikeru[i]:
				if tansaku[j] == 2:
					tmp += dp[j]
			tmp = max(0, tmp-1)
			if i >= 1:
				if a[i-1] >= x:
					tmp += 1
			dp[i] = tmp
			tansaku[i] = 2
	if dp[0] >= 1:
		return True
	return False
	

suki = 10**9 + 5
kirai = 0
while suki - kirai > 1:
	targ = (suki + kirai) // 2
	if canreach(targ):
		kirai = targ
	else:
		suki = targ

print(kirai)


### Example 2
--- Buggy Code ---
n,k = map(int, input().split())
pq = []
p = list(map(int, input().split()))
q = list(map(int, input().split()))
for i in range(n):
  pq.append((p[i], q[i]))
pq.sort()

a = []
for i in range(n):
  a.append(pq[i][1])

#dp[i][j][m] = 数列のi番目まで考えて、今後jより大の数字はNGとなるようなもので数字をm個選んでいるような選び方
dp = [[[0]*(n+1) for _ in range(n+2)] for _ in range(n)]
mod = 998244353

for i in range(n):
  x = a[i]
  if i == 0:
    dp[i][n+1][1] = 1
    dp[i][x][0] = 1

  else:
    #xを採用する場合
    for j in range(x+1,n+2):
      for m in range(n):
        dp[i][j][m+1] += dp[i-1][j][m]
        dp[i][j][m+1] %= mod
    #xを採用しない場合
    for j in range(n+2):
      for m in range(n+1):
        dp[i][min(x,j)][m] += dp[i-1][j][m]  
        dp[i][min(x,j)][m] %= mod

ans = 0
for j in range(n+1):
  ans += dp[-1][j][k]
  ans %= mod

print(ans)



--- Correct Code ---
n,k = map(int, input().split())
pq = []
p = list(map(int, input().split()))
q = list(map(int, input().split()))
for i in range(n):
  pq.append((p[i], q[i]))
pq.sort()

a = []
for i in range(n):
  a.append(pq[i][1])

#dp[i][j][m] = 数列のi番目まで考えて、今後jより大の数字はNGとなるようなもので数字をm個選んでいるような選び方
dp = [[[0]*(n+1) for _ in range(n+2)] for _ in range(n)]
mod = 998244353

for i in range(n):
  x = a[i]
  if i == 0:
    dp[i][n+1][1] = 1
    dp[i][x][0] = 1

  else:
    #xを採用する場合
    for j in range(x+1,n+2):
      for m in range(n):
        dp[i][j][m+1] += dp[i-1][j][m]
        dp[i][j][m+1] %= mod
    #xを採用しない場合
    for j in range(n+2):
      for m in range(n+1):
        dp[i][min(x,j)][m] += dp[i-1][j][m]  
        dp[i][min(x,j)][m] %= mod

ans = 0
for j in range(n+2):
  ans += dp[-1][j][k]
  ans %= mod

print(ans)


### Example 3
--- Buggy Code ---
n,s=map(int, input().split())
c=[0]*n
d=[]
for i in range(n):
  a,b=map(int, input().split())
  if a<=b:
    d.append(b-a)
    s-=a
  else:
    c[i]=1
    d.append(a-b)
    s-=b

if s<=0:
  print("No")
  exit()

dp=[[0]*(s+1) for _ in range(n+1)]
dp[0][0]=1
for i in range(n):
  D=d[i]
  for j in range(s+1):
    if dp[i][j]==1:
      dp[i+1][j]=1
      if j+D<=s:
        dp[i+1][j+D]=1

if dp[-1][-1]==0:
  print("No")
  exit()

ans=""
e=["H","T"]
now=s
for i in reversed(range(n)):
  if dp[i][now]==1:
    ans+=e[c[i]]
  else:
    ans+=e[(c[i]+1)%2]
    now-=d[i]



ans=ans[::-1]
print("Yes")
print(ans)

--- Correct Code ---
n,s=map(int, input().split())
c=[0]*n
d=[]
for i in range(n):
  a,b=map(int, input().split())
  if a<=b:
    d.append(b-a)
    s-=a
  else:
    c[i]=1
    d.append(a-b)
    s-=b

if s<0:
  print("No")
  exit()

dp=[[0]*(s+1) for _ in range(n+1)]
dp[0][0]=1
for i in range(n):
  D=d[i]
  for j in range(s+1):
    if dp[i][j]==1:
      dp[i+1][j]=1
      if j+D<=s:
        dp[i+1][j+D]=1

if dp[-1][-1]==0:
  print("No")
  exit()

ans=""
e=["H","T"]
now=s
for i in reversed(range(n)):
  if dp[i][now]==1:
    ans+=e[c[i]]
  else:
    ans+=e[(c[i]+1)%2]
    now-=d[i]



ans=ans[::-1]
print("Yes")
print(ans)


Your task:
1) Identify the single incorrect line in the buggy program.
2) Assume EXACTLY ONE line is wrong.
3) Provide the corrected version of the ENTIRE program, changing only that single line.
4) Do not restructure or rewrite unrelated code.
5) Respond ONLY in JSON format:

{
  "explanation": "Explain the bug and how you fixed it.",
  "fixed_code": "The FULL program with only that ONE line corrected."
}