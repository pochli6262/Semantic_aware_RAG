You are a Python repair assistant.

A user gives you the following buggy program.

## Buggy Program
n = 10**12

def primes(n):
    ass = []
    is_prime = [True] * (n+1)
    is_prime[0] = False
    is_prime[1] = False
    for i in range(2, int(n**0.5)+1):
        if not is_prime[i]:
            continue
        for j in range(i*2, n+1, i):
            is_prime[j] = False
    for i in range(len(is_prime)):
        if is_prime[i]:
            ass.append(i)
    return ass

x = int((n/12)**0.5)
p = primes(x)
m = len(p)
ans = 0
for b in range(1,m-1):
    for c in range(b + 1, m):
        if p[b] * p[c]**2 > n:
            break
        for a in range(b):
            if p[a] **2 * p[b] * p[c]**2 > n:
                break

            else:
                ans += 1
print(ans)


## Related Example Fixes (retrieved from similar problems)
These examples are only references. 
They must NOT be copied directly, but can inspire how similar bugs were fixed.

### Example 1
--- Buggy Code ---
def enum_primes(n):
    prime_flag = [1] * (n + 1)
    prime_flag[0] = 0
    prime_flag[1] = 0
    i = 2
    while i * i <= n:
        if prime_flag[i]:
            for j in range(2 * i, n + 1, i):
                prime_flag[j] = 0
        i += 1
    return [i for i in range(n + 1) if prime_flag[i]]

N=int(input())
n=int(N**(1/3))+1
li=enum_primes(n)

ans=0
for i in range(len(li)):
    p=li[i]
    ok=i
    ng=len(li)-1
    while ng-ok>1:
        j=(ok+ng)//2
        q=li[j]
        if  p*q**3<=N:
            ok=j
        else:
            ng=j
    if ok>i:
        ans+=ok-i

print(ans)

--- Correct Code ---
def enum_primes(n):
    prime_flag = [1] * (n + 1)
    prime_flag[0] = 0
    prime_flag[1] = 0
    i = 2
    while i * i <= n:
        if prime_flag[i]:
            for j in range(2 * i, n + 1, i):
                prime_flag[j] = 0
        i += 1
    return [i for i in range(n + 1) if prime_flag[i]]

N=int(input())
n=int(N**(1/3))+1
li=enum_primes(n)

ans=0
for i in range(len(li)):
    p=li[i]
    ok=i
    ng=len(li)
    while ng-ok>1:
        j=(ok+ng)//2
        q=li[j]
        if  p*q**3<=N:
            ok=j
        else:
            ng=j
    if ok>i:
        ans+=ok-i

print(ans)


### Example 2
--- Buggy Code ---
n = int(input())
prl = [0] *(10**6)
def pr_jg(p):
    pr = int(p ** (1/2)) + 1
    m = 2
    while m <= pr:
        if p % m == 0:
            return(False)
        m += 1
    return True

k = int((n//2) ** (1/3))
prl[0] = 2
cur = 1
for i in range(3,k+1):
    if pr_jg(i):
        prl[cur] = i
        cur += 1
maxv = cur-1
ans = 0
for i in range(cur):
    for j in range(maxv,i,-1):
        if prl[i] * (prl[j]**3) <= n:
            maxv = j
            ans += j - i
            break
 
print(ans)

--- Correct Code ---
n = int(input())
prl = [0] *(10**6)
def pr_jg(p):
    pr = int(p ** (1/2)) + 1
    m = 2
    while m <= pr:
        if p % m == 0:
            return(False)
        m += 1
    return True

k = int((n//2) ** (1/3))
prl[0] = 2
cur = 1
for i in range(3,k+2):
    if pr_jg(i):
        prl[cur] = i
        cur += 1
maxv = cur-1
ans = 0
for i in range(cur):
    for j in range(maxv,i,-1):
        if prl[i] * (prl[j]**3) <= n:
            maxv = j
            ans += j - i
            break
 
print(ans)


### Example 3
--- Buggy Code ---
############################################################################################
import bisect,collections,copy,heapq,itertools,math,string,sys,queue,time,random
from decimal import Decimal
def I(): return input()
def IS(): return input().split()
def II(): return int(input())
def IIS(): return list(map(int,input().split()))
def LIIS(): return list(map(int,input().split()))

def make_divisors(n):
    lower_divisors , upper_divisors = [], []
    i = 1
    while i*i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n//i)
        i += 1
    return lower_divisors + upper_divisors[::-1]

import math

def prime_numbers(n):
    prime = [True for i in range(n+1)]
    prime[0] = False
    prime[1] = False

    sqrt_n = math.ceil(math.sqrt(n))
    for i in range(2, sqrt_n):
        if prime[i]:
            for j in range(2*i, n+1, i):
                prime[j] = False
    numbers=[]
    for i in range(2,n+1):
        if prime[i]:
            numbers.append(i)

    return numbers

def factorization(n):
    arr = []
    temp = n
    for i in range(2, int(-(-n**0.5//1))+1):
        if temp%i==0:
            cnt=0
            while temp%i==0:
                cnt+=1
                temp //= i
            arr.append([i, cnt])
 
    if temp!=1:
        arr.append([temp, 1])
 
    if arr==[]:
        arr.append([n, 1])
 
    return arr
 
INF=10**18
MOD=998244353
MOD2=10**9+7
#sys.setrecursionlimit(500005)
def bit_count(x):
    return bin(x).count("1")
def yesno(f):
    if f:print("Yes")
    else:print("No")
####################################################
n,m=IIS()
li=[-1]*(m+1)
idx=1
st=set()
for i in range(n):
    a,b=IIS()
    li[a]=b
    st.add(b)
    idx=max(idx,a)
cnt=[]
cnt.append((m-idx+1,m))
for i in range(1,m):
    if i in st:break
    idx=max(idx,li[i])
    idx=max(i+1,idx)
    cnt.append((m-idx+1,m-i))
ans=[0]*(m+1)
for i,j in cnt:
    ans[j]+=1
    ans[j-i]-=1
cnt=0
for i in range(1,m+1)[::-1]:
    cnt+=ans[i]
    ans[i]=cnt
print(*ans[1:])




--- Correct Code ---
############################################################################################
import bisect,collections,copy,heapq,itertools,math,string,sys,queue,time,random
from decimal import Decimal
def I(): return input()
def IS(): return input().split()
def II(): return int(input())
def IIS(): return list(map(int,input().split()))
def LIIS(): return list(map(int,input().split()))

def make_divisors(n):
    lower_divisors , upper_divisors = [], []
    i = 1
    while i*i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n//i)
        i += 1
    return lower_divisors + upper_divisors[::-1]

import math

def prime_numbers(n):
    prime = [True for i in range(n+1)]
    prime[0] = False
    prime[1] = False

    sqrt_n = math.ceil(math.sqrt(n))
    for i in range(2, sqrt_n):
        if prime[i]:
            for j in range(2*i, n+1, i):
                prime[j] = False
    numbers=[]
    for i in range(2,n+1):
        if prime[i]:
            numbers.append(i)

    return numbers

def factorization(n):
    arr = []
    temp = n
    for i in range(2, int(-(-n**0.5//1))+1):
        if temp%i==0:
            cnt=0
            while temp%i==0:
                cnt+=1
                temp //= i
            arr.append([i, cnt])
 
    if temp!=1:
        arr.append([temp, 1])
 
    if arr==[]:
        arr.append([n, 1])
 
    return arr
 
INF=10**18
MOD=998244353
MOD2=10**9+7
#sys.setrecursionlimit(500005)
def bit_count(x):
    return bin(x).count("1")
def yesno(f):
    if f:print("Yes")
    else:print("No")
####################################################
n,m=IIS()
li=[-1]*(m+1)
idx=1
st=set()
for i in range(n):
    a,b=IIS()
    li[a]=max(li[a],b)
    st.add(b)
    idx=max(idx,a)
cnt=[]
cnt.append((m-idx+1,m))
for i in range(1,m):
    if i in st:break
    idx=max(idx,li[i])
    idx=max(i+1,idx)
    cnt.append((m-idx+1,m-i))
ans=[0]*(m+1)
for i,j in cnt:
    ans[j]+=1
    ans[j-i]-=1
cnt=0
for i in range(1,m+1)[::-1]:
    cnt+=ans[i]
    ans[i]=cnt
print(*ans[1:])


Your task:
1) Identify the single incorrect line in the buggy program.
2) Assume EXACTLY ONE line is wrong.
3) Provide the corrected version of the ENTIRE program, changing only that single line.
4) Do not restructure or rewrite unrelated code.
5) Respond ONLY in JSON format:

{
  "explanation": "Explain the bug and how you fixed it.",
  "fixed_code": "The FULL program with only that ONE line corrected."
}