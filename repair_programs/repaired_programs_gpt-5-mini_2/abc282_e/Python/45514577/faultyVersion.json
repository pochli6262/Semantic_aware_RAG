{
  "explanation": "The code was building a spanning tree but sorted edges in ascending order (edges.sort()), which picks the minimum edges first (minimum spanning tree). The intended behavior is to pick the largest-weight edges (maximum spanning tree), so the edges must be sorted in descending order. I fixed the single line by using edges.sort(reverse=True) so Kruskal's loop selects largest edges first.",
  "fixed_code": "from atcoder.dsu import DSU\nfrom heapq import heappop, heappush\nfrom collections import deque\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\nG = [[0] * N for _ in range(N)]\nfor i in range(N):\n    for j in range(i+1, N):\n        G[i][j] = (pow(A[i], A[j], M) + pow(A[j], A[i], M)) % M\n        G[j][i] = G[i][j]\n\nedges = []\nfor i in range(N):\n    for j in range(i+1, N):\n        edges.append(((pow(A[i], A[j], M) + pow(A[j], A[i], M)) % M, i, j))\nedges.sort(reverse=True)\n\nans = 0\nuf = DSU(N)\nfor p, i, j in edges:\n    if uf.same(i, j): continue\n    ans += p\n    uf.merge(i, j)\nprint(ans)"
}