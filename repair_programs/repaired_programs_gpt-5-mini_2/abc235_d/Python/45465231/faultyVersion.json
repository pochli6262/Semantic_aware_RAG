{
  "explanation": "The check for a previously seen state used di[x] != 0 to detect whether x had been visited. But di is a defaultdict(int), so unseen keys return 0; that makes the initial state (or any state recorded with cost 0) indistinguishable from unseen, allowing revisits and incorrect behavior. I fixed the condition to test membership explicitly (x in di) so we only treat x as visited if it was actually recorded in the dictionary.",
  "fixed_code": "import sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import gcd,log,sqrt\nfrom atcoder.modint import ModContext, Modint\n\nModContext(1).context.append(998244353)\nsys.setrecursionlimit(1000000)\n\ninput = lambda :sys.stdin.readline().rstrip()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\na, N = mi()\nans = 1 << 60\ndi = defaultdict(int)\ndef change(x, cnt):\n    # print(x, cnt)\n    if x in di and di[x] <= cnt:\n        return\n    di[x] = cnt\n    global ans\n    if x == 1:\n        ans = min(ans, cnt)\n        return\n    if x % a == 0:\n        change(x // a, cnt + 1)\n    d = sum(c.isdigit() for c in str(x))\n    if d == 1:\n        return\n    nx = (x % (10 ** (d - 1))) * 10 + x // (10 ** (d-1))\n    change(nx, cnt + 1)\n    return\nchange(N, 0)\nif ans == 1 << 60:\n    print(-1)\nelse:\n    print(ans)\n"
}