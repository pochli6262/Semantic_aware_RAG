{
  "explanation": "The line S = input()[:-1] incorrectly removes the last character of the input string (not just the trailing newline). input() already returns the line without the newline, so slicing off the final character drops a valid character from S. I fixed it by using S = input().strip(), which removes only leading/trailing whitespace/newline and preserves the actual characters of the input string.",
  "fixed_code": "import sys\nimport math\nfrom collections import deque\nsys.setrecursionlimit(10**6) #pythonの無限再起を防ぐための上限変更\ninput = sys.stdin.readline\n\n# 303 D\nX, Y , Z = map(int, input().split())\nS = input().strip()\n\nINF = 10000000000\nSlen = len(S)\nres = [[INF]*2 for i in range(Slen+1)]\nres[0][0] = 0\nfor i in range(Slen):\n    if S[i] == 'a':\n        if res[i][0] != INF:\n            res[i+1][0] = min(res[i+1][0], res[i][0] + X)\n            res[i+1][1] = min(res[i+1][1], res[i][0] + Z + Y)\n\n        if res[i][1] != INF:\n            res[i+1][0] = min(res[i+1][0], res[i][1] + Z + X)\n            res[i+1][1] = min(res[i+1][1], res[i][1] + Y)\n\n    elif S[i] == 'A':\n        if res[i][0] != INF:\n            res[i+1][1] = min(res[i+1][1], res[i][0] + Z + X)\n            res[i+1][0] = min(res[i+1][0], res[i][0] + Y)\n\n        if res[i][1] != INF:\n            res[i+1][1] = min(res[i+1][1], res[i][1] + X)\n            res[i+1][0] = min(res[i+1][0], res[i][1] + Z + Y)\n\nprint(min(res[Slen][0], res[Slen][1]))"
}