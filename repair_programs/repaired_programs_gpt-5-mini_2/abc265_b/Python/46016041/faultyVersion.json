{
  "explanation": "The code used `if nowP in S:` to decide when to take a boost, then popped exactly one item from queB. That fails when there are multiple boosts at the same checkpoint (or when we must ensure the deque's front actually corresponds to the current position). I replaced that single-line condition with a loop that checks the front of queB matches nowP and keeps popping/adding while it does: `while queB and queB[0][0] == nowP:`. This ensures all boosts at the current position are applied and that we only pop matching entries.",
  "fixed_code": "N, M, T = map(int, input().split())\nA = list(map(int, input().split()))\nB = []\nfor i in range(M):\n    B.append(tuple(map(int, input().split())))\n\nfrom collections import deque\nqueA = deque(A)\nB.sort(key=lambda x: x[0])\nqueB = deque(B)\n\nans = \"Yes\"\nnowT = T\nnowP = 1\nS = set([row[0] for row in B])\n# print(S)\nfor i in range(N-1):\n    # print(nowT)\n    p = queA.popleft()\n    while queB and queB[0][0] == nowP:\n        # print(\"inS\")\n        pt = queB.popleft()\n        nowT += pt[1]\n\n    if nowT >= p:\n        nowT -= p\n        nowP += 1\n    else:\n        ans = \"No\"\n        break\n\nprint(ans)"
}