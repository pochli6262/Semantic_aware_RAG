{
  "explanation": "The predicate in cal() was using the wrong comparison: it accumulated amounts for items with day >= x, which is the reverse of the usual prefix-sum check. Changing the comparison to <= makes cal(x) compute the total amount up to day x (days <= x). This fixes the logical error that caused the binary search to operate on the wrong predicate direction.",
  "fixed_code": "# python3 answer.py < input.txt\n# =list(map(int, input().split()))\n#=int(input())\n#import collections\n#import itertools\n#import numpy\n#from collections import deque\n#import heapq\n#inf=10**100\n#isok=True\n#import numpy as np\n#np.set_printoptions(suppress=True)\n#k=int(input())\n\n#n=int(input())\n#lis=[]\nn,k=list(map(int, input().split()))\n\n\ndef cal(x,li):\n    res=0\n    for i in range(n):\n        if li[i][0]<=x:\n            res+=li[i][1]\n    #print(res>k)\n    return res>k\n\nmaxday=0\nlis=[]\nfor i in range(n):\n    a,b=list(map(int, input().split()))\n    maxday=max(maxday,a)\n    lis.append([a,b])\n\nl=-1\nr=maxday\n\nwhile abs(r-l)>1:\n    mid=(l+r)//2\n    #print(l,r,mid)\n    if cal(mid,lis):#飲む量が多いか\n        l=mid\n    else:\n        r=mid\n\nif r<=0:\n    print(1)\nelse:\n    print(r)\n"
}