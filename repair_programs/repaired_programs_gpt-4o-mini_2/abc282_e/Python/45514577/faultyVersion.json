{
  "explanation": "The bug was in the way the edges were being generated. The line where edges are appended to the 'edges' list was duplicated with the same calculation as the previous one. This created an unnecessary computation. Therefore, I simplified the edge generation to use the previously computed value from the adjacency matrix instead of recalculating it. Specifically, I replaced the duplicate calculation with the reference to 'G[i][j]'.",
  "fixed_code": "from atcoder.dsu import DSU\nfrom heapq import heappop, heappush\nfrom collections import deque\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\nG = [[0] * N for _ in range(N)]\nfor i in range(N):\n    for j in range(i+1, N):\n        G[i][j] = (pow(A[i], A[j], M) + pow(A[j], A[i], M)) % M\n        G[j][i] = G[i][j]\n\nedges = []\nfor i in range(N):\n    for j in range(i+1, N):\n        edges.append((G[i][j], i, j))\nedges.sort()\n\nans = 0\nuf = DSU(N)\nfor p, i, j in edges:\n    if uf.same(i, j): continue\n    ans += p\n    uf.merge(i, j)\nprint(ans)"
}