{
  "explanation": "The bug is in the calculation of dp[i+1][j+1]. The original code accesses Y[j+1], but this is incorrect because the indices of Y are 0-based while the outer loop iterates over j, which is also 0-based. Therefore, Y[j+1] should actually be Y[j], as we're trying to access the score for the 'j-th' item. I changed Y[j+1] to Y[j] in that line.",
  "fixed_code": "import sys\nimport re\nfrom math import ceil, floor, sqrt, pi, factorial, gcd\nfrom copy import deepcopy\nfrom collections import Counter, deque, defaultdict\nfrom heapq import heapify, heappop, heappush\nfrom itertools import accumulate, product, combinations, combinations_with_replacement, permutations\nfrom bisect import bisect, bisect_left, bisect_right\nfrom functools import reduce\nfrom decimal import Decimal, getcontext\n\ndef input(): return sys.stdin.readline().strip()\ndef i_input(): return int(input())\ndef i_map(): return map(int, input().split())\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input() for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\ndef lcm(a, b): return a * b // gcd(a, b)\ndef rotate90(S): return list(zip(*S[::-1]))\ndef rotate180(S): return list(zip(*list(zip(*S[::-1]))[::-1]))\ndef rotate270(S): return list(zip(*S))[::-1]\n\n\nsys.setrecursionlimit(10 ** 6)\nINF = float('inf')\nMOD = 10 ** 9 + 7\nDIRECTION = [\n    (1, 0),\n    (1, 1),\n    (0, 1),\n    (-1, 1),\n    (-1, 0),\n    (-1, -1),\n    (0, -1),\n    (1, -1),\n]\n\ndef main():\n    N, M = i_map()\n    X = i_list()\n    CY = i_row_list(M)\n\n    Y = [0 for _ in range(N+1)]\n    for c, y in CY:\n        Y[c] = y\n    # print(Y)\n\n    dp = [[-MOD for _ in range(N+1)] for _ in range(N+1)]\n\n    dp[0][0] = 0\n\n    for i in range(N):\n        for j in range(N):\n            # 0のとき\n            dp[i+1][0] = max(dp[i][j], dp[i+1][0])\n\n            # 1のとき\n            dp[i+1][j+1] = max(dp[i][j] + X[i] + Y[j], dp[i+1][j+1])\n\n    # for d in dp:\n    #     print(d)\n\n    print(max(dp[-1]))\n\n\nif __name__ == '__main__':\n    main()"
}