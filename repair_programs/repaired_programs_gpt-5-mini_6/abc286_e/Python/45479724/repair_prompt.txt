You are a Python expert.

A user gives you the following Python program which is buggy.

## Problem Description (from dataset)
Score : 500 points

### Problem Statement

There are N cities. There are also one-way direct flights that connect different cities.  
The availability of direct flights is represented by N strings S\_1,S\_2,\ldots,S\_N of length N each.
If the j-th character of S\_i is `Y`, there is a direct flight from city i to city j;
if it is `N`, there is not.  
Each city sells a souvenir; city i sells a souvenir of value A\_i.

Consider the following problem:

> Takahashi is currently at city S and wants to get to city T (that is different from city S) using some direct flights.  
> Every time he visits a city (including S and T), he buys a souvenir there.  
> If there are multiple routes from city S to city T, Takahashi decides the route as follows:
>
> * He tries to minimize the number of direct flights in the route from city S to city T.
> * Then he tries to maximize the total value of the souvenirs he buys.
>
> Determine if he can travel from city S to city T using the direct flights.
> If he can, find the "number of direct flights" and "total value of souvenirs" in the route that satisfies the conditions above.

You are given Q pairs (U\_i,V\_i) of distinct cities.  
For each 1\leq i\leq Q, print the answer to the problem above when S=U\_i and T=V\_i.

### Constraints

* 2 \leq N \leq 300
* 1\leq A\_i\leq 10^9
* S\_i is a string of length N consisting of `Y` and `N`.
* The i-th character of S\_i is `N`.
* 1\leq Q\leq N(N-1)
* 1\leq U\_i,V\_i\leq N
* U\_i\neq V\_i
* If i \neq j, then (U\_i,V\_i)\neq (U\_j,V\_J).
* N,A\_i,Q,U\_i, and V\_i are all integers.

---

### Input

The input is given from Standard Input in the following format:

```
N
A_1 A_2 \ldots A_N
S_1
S_2
\vdots
S_N
Q
U_1 V_1
U_2 V_2
\vdots
U_Q V_Q
```

### Output

Print Q lines.  
The i-th (1\leq i\leq Q) line should contain
`Impossible` if he cannot travel from city U\_i to city V\_i;
if he can, the line should contain "the number of direct flights" and "the total value of souvenirs" in the route chosen as described above, in this order, separated by a space.

---

### Sample Input 1

```
5
30 50 70 20 60
NYYNN
NNYNN
NNNYY
YNNNN
YNNNN
3
1 3
3 1
4 5
```

### Sample Output 1

```
1 100
2 160
3 180
```

For (S,T)=(U\_1,V\_1)=(1,3), there is a direct flight from city 1 to city 3,
so the minimum possible number of direct flights is 1, which is achieved when he uses that direct flight.
In this case, the total value of the souvenirs is A\_1+A\_3=30+70=100.

For (S,T)=(U\_2,V\_2)=(3,1), the minimum possible number of direct flights is 2.
The following two routes achieve the minimum: cities 3\to 4\to 1, and cities 3\to 5\to 1.
Since the total value of souvenirs in the two routes are 70+20+30=120 and 70+60+30=160, respectively,
so he chooses the latter route, and the total value of the souvenirs is 160.

For (S,T)=(U\_3,V\_3)=(4,5), the number of direct flights is minimum when he travels cities 4\to 1\to 3\to 5, where the total value of the souvenirs is 20+30+70+60=180.

---

### Sample Input 2

```
2
100 100
NN
NN
1
1 2
```

### Sample Output 2

```
Impossible
```

There may be no direct flight at all.

## Your Analysis (1-sentence bug summary)
The tie-breaker uses min(...) for equal-length routes, so the code picks the smaller souvenir total instead of maximizing the total (it should use max).

## Buggy Program
n=int(input())
a=list(map(int,input().split()))
s=[list(map(str,input())) for i in range(n)]
q=int(input())
ans=[[[10**9,10**20] for i in range(n)] for i in range(n)]
for i in range(n):
  ans[i][i]=[0,a[i]]
for i in range(n):
  for j in range(n):
    if s[i][j]=="Y":
      ans[i][j]=[1,a[i]+a[j]]
for k in range(n):
  for i in range(n):
    for j in range(n):
      if ans[i][j][0]>ans[i][k][0]+ans[k][j][0]:
        ans[i][j]=[ans[i][k][0]+ans[k][j][0],ans[i][k][1]+ans[k][j][1]-a[k]]
      elif ans[i][j][0]==ans[i][k][0]+ans[k][j][0]:
        ans[i][j][1]=min(ans[i][k][1]+ans[k][j][1]-a[k],ans[i][j][1])
for i in range(q):
  c,b=map(int,input().split())
  c-=1;b-=1
  if ans[c][b][1]==10**20:
    print("Impossible")
  else:
    print(*ans[c][b])

## Related Known Fixes (retrieved diffs)
### Diff 1
--- 
+++ 
@@ -29,7 +29,7 @@
         if k[i]<b[i]:
             return False
     return True
-for i in range(am):
+for i in range(am+1):
     while check():
         t+=1
         if t==bm:

### Diff 2
--- 
+++ 
@@ -18,7 +18,7 @@
 for i in range(k1+1):
     if dp[-1][i]>k2 or dp[-1][i]==10**5:
         continue
-    ans=i*c1+dp[-1][i]*c2
+    ans=min(ans,i*c1+dp[-1][i]*c2)
 if ans==10**30:
     print(-1)
 else:

### Diff 3
--- 
+++ 
@@ -11,7 +11,7 @@
     d.append(a-b)
     s-=b
 
-if s<=0:
+if s<0:
   print("No")
   exit()
 

### Diff 4
--- 
+++ 
@@ -34,7 +34,7 @@
         bool=True
         if ans[i][k][0]>v+j:
           ans[i][k]=[v+j,q]
-          if ans[i][0][0]<ans[i][1][0]:
+          if ans[i][0][0]>ans[i][1][0]:
             ans[i][0],ans[i][1]=ans[i][1],ans[i][0]
           heapq.heappush(hq,(v+j,i,q))
     if bool:

### Diff 5
--- 
+++ 
@@ -1,3 +1,4 @@
+
 from collections import deque
 n = int(input())
 a = [list(map(int,input().split())) for i in range(n)]
@@ -34,7 +35,7 @@
                         b.append(j)
                         break
 
-                if len(d) == 0 and n-1-i <j:
+                if n-1-i < j:
                     ans = -1
 
             else:
@@ -66,3 +67,4 @@
 
 else:
     print(ans)
+

Your task:
1) Identify the single incorrect line according to the problem summary and the retrieved diffs.
2) Assume EXACTLY ONE line is wrong.
3) Provide the corrected version of the ENTIRE program, changing only that single line â€” all other lines must remain identical.
4) Do not restructure or rewrite unrelated code.
5) Respond ONLY in JSON format:

{
  "explanation": "Explain what was wrong in that single line and how you fixed it (mention which diff patterns inspired the fix if applicable).",
  "fixed_code": "The FULL program with only that ONE line corrected."
}