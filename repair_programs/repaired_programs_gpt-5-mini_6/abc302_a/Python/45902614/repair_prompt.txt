You are a Python expert.

A user gives you the following Python program which is buggy.

## Problem Description (from dataset)
Score : 100 points

### Problem Statement

There is an enemy with stamina A. Every time you attack the enemy, its stamina reduces by B.

At least how many times do you need to attack the enemy to make its stamina 0 or less?

### Constraints

* 1 \le A,B \le 10^{18}
* A and B are integers.

---

### Input

The input is given from Standard Input in the following format:

```
A B
```

### Output

Print the answer.

---

### Sample Input 1

```
7 3
```

### Sample Output 1

```
3
```

Attacking three times make the enemy's stamina -2.

Attacking only twice makes the stamina 1, so you need to attack it three times.

---

### Sample Input 2

```
123456789123456789 987654321
```

### Sample Output 2

```
124999999
```

---

### Sample Input 3

```
999999999999999998 2
```

### Sample Output 3

```
499999999999999999
```

## Your Analysis (1-sentence bug summary)
The program performs float division and unconditionally adds 1, causing an off-by-one when x is divisible by y (and risking floating-point precision errors for very large integers).

## Buggy Program
x, y = map(int, input().split())
print(int(x/y)+1)

## Related Known Fixes (retrieved diffs)
### Diff 1
--- 
+++ 
@@ -1,8 +1,9 @@
 n, a, b = map(int, input().split())
 if a <= b:
-    print(n)
+    print(max(n - a + 1, 0))
 else:
     if n < a:
         print(0)
     else:
         print((n // a - 1) * b + min(b - 1, n % a) + 1)
+

### Diff 2
--- 
+++ 
@@ -1,2 +1,2 @@
 x,y,z = map(int, input().split())
-print(-1 if x == y == 0 and z == 1 or x == z == 0 and y == 1 or y == z == 0 and x == 1 else max(x, y, z))
+print(-1 if x > y + z or y > x + z or z > x + y else max(x, y, z))

### Diff 3
--- 
+++ 
@@ -1,7 +1,7 @@
 A,B = map(int,input().split())
 if A + B == 3:
   print("3")
-elif A + B == 4:
+elif A + B == 4 and A != B:
   print("2")
 elif A + B == 5:
   print("1")

### Diff 4
--- 
+++ 
@@ -19,7 +19,7 @@
     C = C - 1
   while(X[i] >= 5 and B > 0):
     X[i] = X[i] - 5
-    B =  - 1
+    B = B - 1
   while(X[i] >= 1 and A > 0):
     X[i] = X[i] - 1
     A = A - 1

### Diff 5
--- 
+++ 
@@ -2,7 +2,7 @@
 ab = [list(map(int, input().split())) for _ in range(n)]
 t = 0
 c = 0
-mn = 10 ** 18
+mn = 10 ** 19
 for i in range(n):
     if c >= x:
         break

Your task:
1) Identify the single incorrect line according to the problem summary and the retrieved diffs.
2) Assume EXACTLY ONE line is wrong.
3) Provide the corrected version of the ENTIRE program, changing only that single line â€” all other lines must remain identical.
4) Do not restructure or rewrite unrelated code.
5) Respond ONLY in JSON format:

{
  "explanation": "Explain what was wrong in that single line and how you fixed it (mention which diff patterns inspired the fix if applicable).",
  "fixed_code": "The FULL program with only that ONE line corrected."
}