You are a Python expert.

A user gives you the following Python program which is buggy.

## Problem Description (from dataset)
Score : 500 points

### Problem Statement

Given is an undirected graph with N+1 vertices.  
The vertices are called Vertex 0, Vertex 1, \ldots, Vertex N.

For each i=1,2,\ldots,N, the graph has an undirected edge with a weight of A\_i connecting Vertex 0 and Vertex i.

Additionally, for each i=1,2,\ldots,N, the graph has an undirected edge with a weight of B\_i connecting Vertex i and Vertex i+1. (Here, Vertex N+1 stands for Vertex 1.)

The graph has no edge other than these 2N edges above.

Let us delete some of the edges from this graph so that the graph will be bipartite.  
What is the minimum total weight of the edges that have to be deleted?

### Constraints

* 3 \leq N \leq 2 \times 10^5
* 1 \leq A\_i \leq 10^9
* 1 \leq B\_i \leq 10^9
* All values in input are integers.

---

### Input

Input is given from Standard Input in the following format:

```
N
A_1 A_2 \dots A_N
B_1 B_2 \dots B_N
```

### Output

Print the answer.

---

### Sample Input 1

```
5
31 4 159 2 65
5 5 5 5 10
```

### Sample Output 1

```
16
```

![](https://img.atcoder.jp/ghi/ded08d4aa13d31bea28b91afe246c790.png)  
Deleting the edge connecting Vertices 0,2 (weight: 4), the edge connecting Vertices 0,4 (weight: 2), and the edge connecting Vertices 1,5 (weight: 10) makes the graph bipartite.

---

### Sample Input 2

```
4
100 100 100 1000000000
1 2 3 4
```

### Sample Output 2

```
10
```

## Your Analysis (1-sentence bug summary)
The DP transition for dp[i+1][1][0] wrongly adds B[i-1] in both branches, erroneously charging the B-edge deletion cost even when the previous vertex has the opposite color so that edge need not be removed.

## Buggy Program
N = int(input())
A = list(map(int, input().split()))
B = list(map(int, input().split()))
INF = 10**18
# dp[i][j][k]: 頂点i番目まで見たときに、i番目が色j(0or1)で、頂点1が色k(0or1)の時の総和の最小値
# 頂点0 は色0 で固定する
dp = [[[INF] * 2 for _ in range(2)] for _ in range(N + 1)]
dp[0][0][0] = 0
dp[0][0][1] = 0
for i in range(N):
    if i == 0:
        # 頂点1が0と同じ色の場合、辺を消す
        dp[i+1][0][0] = A[0]
        dp[i+1][1][1] = 0
        continue

    dp[i+1][0][0] = min(dp[i][0][0] + A[i] + B[i-1], dp[i][1][0] + A[i])
    dp[i+1][0][1] = min(dp[i][0][1] + A[i] + B[i-1], dp[i][1][1] + A[i])
    dp[i+1][1][0] = min(dp[i][0][0] + B[i-1], dp[i][1][0] + B[i-1])
    dp[i+1][1][1] = min(dp[i][0][1], dp[i][1][1] + B[i-1])

# N における辺A は調査済み
ans = dp[N][0][0] + B[-1]
ans = min(ans, dp[N][0][1])
ans = min(ans, dp[N][1][0])
ans = min(ans, dp[N][1][1] + B[-1])
print(ans)

## Related Known Fixes (retrieved diffs)
### Diff 1
--- 
+++ 
@@ -28,7 +28,7 @@
     for u in range(n):
         if s & (1 << u) == 0:
             continue
-        for v, w in graph[u]:
+        for v in range(n):
             dp[s | (1 << v)][v] = min(dp[s | (1 << v)][v], dp[s][u] + d[u][v])
 
 ans = INF

### Diff 2
--- 
+++ 
@@ -54,7 +54,7 @@
                         new_mins[m + 1] = A[i + 1] - b
             mins = new_mins
 
-        answer = dp[N - 1][mod]
+        answer = min(dp[N - 1][mod], dp[N - 1][mod - 1])
         print(answer)
 
 

### Diff 3
--- 
+++ 
@@ -1,7 +1,7 @@
 N,M = map(int,input().split())
 A = list(map(int,input().split()))
 
-dp = [[0]*N for i in range(M)]
+dp = [[-(10**18)]*N for i in range(M)]
 dp[0][0]=A[0]
 for i in range(1,N):
     dp[0][i]=max(A[i],dp[0][i-1])

### Diff 4
--- 
+++ 
@@ -9,6 +9,7 @@
 for j in range(N):
   for i in range(N):
     for k in range(N):
+      if D[i][j]==INF or D[j][k]==INF:continue
       D[i][k]=min(D[i][k],D[i][j]+D[j][k])
 #dp[bit][i]:bitを訪問済、最後がiの最短距離
 dp=[[INF for _ in range(N)] for _ in range(1<<N)]
@@ -20,6 +21,7 @@
       continue
     nbit=bit|(1<<j)
     for i in range(N):
+      if dp[bit][i]==INF or D[i][j]==INF:continue
       dp[nbit][j]=min(dp[nbit][j],dp[bit][i]+D[i][j])
 
 ans=min(dp[-1])

### Diff 5
--- 
+++ 
@@ -18,7 +18,7 @@
 for i in range(k1+1):
     if dp[-1][i]>k2 or dp[-1][i]==10**5:
         continue
-    ans=i*c1+dp[-1][i]*c2
+    ans=min(ans,i*c1+dp[-1][i]*c2)
 if ans==10**30:
     print(-1)
 else:

Your task:
1) Identify the single incorrect line according to the problem summary and the retrieved diffs.
2) Assume EXACTLY ONE line is wrong.
3) Provide the corrected version of the ENTIRE program, changing only that single line — all other lines must remain identical.
4) Do not restructure or rewrite unrelated code.
5) Respond ONLY in JSON format:

{
  "explanation": "Explain what was wrong in that single line and how you fixed it (mention which diff patterns inspired the fix if applicable).",
  "fixed_code": "The FULL program with only that ONE line corrected."
}