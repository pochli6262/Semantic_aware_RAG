You are a Python expert.

A user gives you the following Python program which is buggy.

## Problem Description (from dataset)
Score : 400 points

### Problem Statement

Takahashi is playing with toy trains, connecting and disconnecting them.  
There are N toy train cars, with car numbers: Car 1, Car 2, \ldots, Car N.  
Initially, all cars are separated.

You will be given Q queries. Process them in the order they are given.
There are three kinds of queries, as follows.

* `1 x y`: Connect the front of Car y to the rear of Car x.  
  It is guaranteed that:

  + x \neq y
  + just before this query, no train is connected to the rear of Car x;
  + just before this query, no train is connected to the front of Car y;
  + just before this query, Car x and Car y belong to different connected components.
* `2 x y`: Disconnect the front of Car y from the rear of Car x.  
  It is guaranteed that:

  + x \neq y;
  + just before this query, the front of Car y is directly connected to the rear of Car x.
* `3 x`: Print the car numbers of the cars belonging to the connected component containing Car x, **from front to back**.

### Constraints

* 2 \leq N \leq 10^5
* 1 \leq Q \leq 10^5
* 1 \leq x \leq N
* 1 \leq y \leq N
* All values in input are integers.
* All queries satisfy the conditions in the Problem Statement.
* The queries of the format `3 x` ask to print at most 10^6 car numbers in total.

---

### Input

Input is given from Standard Input in the following format:

```
N Q
\mathrm{query}_1
\mathrm{query}_2
\vdots
\mathrm{query}_Q
```

The i-th query \mathrm{query}\_i begins with an integer c\_i (1, 2, or 3) representing the kind of the query, followed by x and y if c\_i = 1 or 2, and followed by x if c\_i = 3.

In short, each query is in one of the following three formats:

```
1 x y
```

```
2 x y
```

```
3 x
```

### Output

If a query with c\_i = 3 asks to print the values j\_1, j\_2, \ldots, j\_M, output the following line:

```
M j_1 j_2 \ldots j_M
```

Your output should consist of q lines, where q is the number of queries with c\_i = 3.  
The k-th line (1 \leq k \leq q) should contain the response to the k-th such query.

---

### Sample Input 1

```
7 14
1 6 3
1 4 1
1 5 2
1 2 7
1 3 5
3 2
3 4
3 6
2 3 5
2 4 1
1 1 5
3 2
3 4
3 6
```

### Sample Output 1

```
5 6 3 5 2 7
2 4 1
5 6 3 5 2 7
4 1 5 2 7
1 4
2 6 3
```

The figure below shows the cars when the first 5 queries are processed.  
For example, Car 2 belongs to the same connected component as Cars 3, 5, 6, 7, which is different from the connected component containing Cars 1, 4.

![](https://img.atcoder.jp/ghi/dbfd2666776e351752bba67e9b65fafa.png)

The figure below shows the cars when the first 11 queries are processed.

![](https://img.atcoder.jp/ghi/dad814ca77ec58f31cb88c62b9825bef.png)

## Your Analysis (1-sentence bug summary)
The code collects front-side node indices in zero-based form without adding 1 (while it adds +1 for back-side nodes), so printed car numbers on the front are off by one.

## Buggy Program
N,Q=map(int,input().split())
connects=[[-1,-1] for _ in range(N)]

for _ in range(Q):
    query=list(map(int,input().split()))
    t=query[0]
    x=query[1]-1
    if t==1:
        y=query[2]-1
        connects[x][1]=y
        connects[y][0]=x
    elif t==2:
        y=query[2]-1
        connects[x][1]=-1
        connects[y][0]=-1
    else:
        front=[]
        back=[]
        now=x
        while connects[now][0]!=-1:
            now=connects[now][0]
            front.append(now)
        now=x
        while connects[now][1]!=-1:
            now=connects[now][1]
            back.append(now+1)
        answer=front[::-1]+[x+1]+back
        print(len(answer),*answer)

## Related Known Fixes (retrieved diffs)
### Diff 1
--- 
+++ 
@@ -1,5 +1,5 @@
 n,M=map(int,input().split())
-q=[[0]*(n+1) for i in range(n+1)]
+q=[[0]*(n+1) for i in range(n+2)]
 q[0][0]=1
 q[1][0]=-1
 for i in range(n+1):

### Diff 2
--- 
+++ 
@@ -26,7 +26,7 @@
           break
       ans.append((r,0))
     for q in Q:
-      while ans[-1][0] > q and n < K:
+      while ans[-1][0] > q and not(n == K and ans[-1][1] == 1):
         r,cc = ans.pop()
         n += cc
       ans.append((q,1))

### Diff 3
--- 
+++ 
@@ -47,7 +47,7 @@
     u, v = map(int,input().split())
     u -= 1
     v -= 1
-    if K[u] == K[v]:
+    if K[u] == K[v] and K[u] != -1:
         print("Yes")
     else:
         print("No")

### Diff 4
--- 
+++ 
@@ -13,7 +13,7 @@
 for i in range(Q):
     query = [*map(int, input().split())]
     if query[0] == 2:
-        if len(dic[1]) == 0:
+        if len(dic[query[1]]) == 0:
             ans -= 1
         for j in dic[query[1]]:
             dic[j].remove(query[1])

### Diff 5
--- 
+++ 
@@ -10,6 +10,7 @@
     pair=(u-1,v-1)
     if pair in pairs:
         continue
+    pairs.add(pair)
     graph[u-1].append(v-1)
     reversed_graph[v-1].add(u-1)
     if v-1 in que:
@@ -24,6 +25,7 @@
     now=heapq.heappop(que)
     answers.append(now+1)
     for to in graph[now]:
+        reversed_graph[to].remove(now)
         if len(reversed_graph[to])==0:
             heapq.heappush(que,to)
     

Your task:
1) Identify the single incorrect line according to the problem summary and the retrieved diffs.
2) Assume EXACTLY ONE line is wrong.
3) Provide the corrected version of the ENTIRE program, changing only that single line â€” all other lines must remain identical.
4) Do not restructure or rewrite unrelated code.
5) Respond ONLY in JSON format:

{
  "explanation": "Explain what was wrong in that single line and how you fixed it (mention which diff patterns inspired the fix if applicable).",
  "fixed_code": "The FULL program with only that ONE line corrected."
}