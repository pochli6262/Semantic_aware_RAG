{
  "explanation": "The code used defaultdict(int) so di[x] defaults to 0. The original check \"if di[x] != 0 and di[x] <= cnt:\" incorrectly treats nodes with stored distance 0 (or unvisited nodes) the same, breaking the pruning logic. I changed the condition to test membership explicitly: \"if x in di and di[x] <= cnt:\" so we only compare cnt when a previous value was actually stored for x. This fixes the visited/pruning bug without changing other logic.",
  "fixed_code": "import sys,random,bisect\nfrom collections import deque,defaultdict\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations\nfrom math import gcd,log,sqrt\nfrom atcoder.modint import ModContext, Modint\n\nModContext(1).context.append(998244353)\nsys.setrecursionlimit(1000000)\n\ninput = lambda :sys.stdin.readline().rstrip()\nmi = lambda :map(int,input().split())\nli = lambda :list(mi())\n\na, N = mi()\nans = 1 << 60\ndi = defaultdict(int)\ndef change(x, cnt):\n    # print(x, cnt)\n    if x in di and di[x] <= cnt:\n        return\n    di[x] = cnt\n    global ans\n    if x == 1:\n        ans = min(ans, cnt)\n        return\n    if x % a == 0:\n        change(x // a, cnt + 1)\n    d = sum(c.isdigit() for c in str(x))\n    if d == 1:\n        return\n    nx = (x % (10 ** (d - 1))) * 10 + x // (10 ** (d-1))\n    change(nx, cnt + 1)\n    return\nchange(N, 0)\nif ans == 1 << 60:\n    print(-1)\nelse:\n    print(ans)"
}