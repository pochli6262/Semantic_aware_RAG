You are a Python expert.

A user gives you the following Python program which is buggy.

## Problem Description (from dataset)
Score : 400 points

### Problem Statement

We have a positive integer a. Additionally, there is a blackboard with a number written in base 10.  
Let x be the number on the blackboard. Takahashi can do the operations below to change this number.

* Erase x and write x multiplied by a, in base 10.
* See x as a string and move the rightmost digit to the beginning.  
  This operation can only be done when x \geq 10 and x is not divisible by 10.

For example, when a = 2, x = 123, Takahashi can do one of the following.

* Erase x and write x \times a = 123 \times 2 = 246.
* See x as a string and move the rightmost digit `3` of `123` to the beginning, changing the number from 123 to 312.

The number on the blackboard is initially 1. What is the minimum number of operations needed to change the number on the blackboard to N? If there is no way to change the number to N, print -1.

### Constraints

* 2 \leq a \lt 10^6
* 2 \leq N \lt 10^6
* All values in input are integers.

---

### Input

Input is given from Standard Input in the following format:

```
a N
```

### Output

Print the answer.

---

### Sample Input 1

```
3 72
```

### Sample Output 1

```
4
```

We can change the number on the blackboard from 1 to 72 in four operations, as follows.

* Do the operation of the first type: 1 \to 3.
* Do the operation of the first type: 3 \to 9.
* Do the operation of the first type: 9 \to 27.
* Do the operation of the second type: 27 \to 72.

It is impossible to reach 72 in three or fewer operations, so the answer is 4.

---

### Sample Input 2

```
2 5
```

### Sample Output 2

```
-1
```

It is impossible to change the number on the blackboard to 5.

---

### Sample Input 3

```
2 611
```

### Sample Output 3

```
12
```

There is a way to change the number on the blackboard to 611 in 12 operations: 1 \to 2 \to 4 \to 8 \to 16 \to 32 \to 64 \to 46 \to 92 \to 29 \to 58 \to 116 \to 611, which is the minimum possible.

---

### Sample Input 4

```
2 767090
```

### Sample Output 4

```
111
```

## Your Analysis (1-sentence bug summary)
The code applies the rotation transition unconditionally in the reverse BFS without enforcing the forward-rotation constraints (e.g., that the predecessor has at least two digits and its last digit is nonzero), so it considers invalid predecessors.

## Buggy Program
from queue import Queue
a,N=map(int,input().split())
def rot(N):
    M=str(N)
    return int(M[1:]+M[0])
d=[10**3]*10**len(str(N))
d[N]=0
q=Queue()
q.put(N)
while not q.empty():
    M=q.get()
    if M==1:
        break
    if M%a==0 and d[M//a]>d[M]+1:
        d[M//a]=d[M]+1
        q.put(M//a)
    if d[rot(M)]>d[M]+1:
        d[rot(M)]=d[M]+1
        q.put(rot(M))
print(d[1] if d[1]!=10**3 else -1)

## Related Known Fixes (retrieved diffs)
### Diff 1
--- 
+++ 
@@ -4,7 +4,7 @@
 for i in range(1,19):
   if i==1:
     if N<9:
-      print(N)
+      print(N*(N+1)//2)
       exit()
     ans += (9*10)//2
   else:
@@ -19,5 +19,3 @@
       ans += (a%mod)*((a+1)%mod)//2
       ans %= mod
 print(ans)
-  
-  

### Diff 2
--- 
+++ 
@@ -3,7 +3,7 @@
 
 for i in map(int, input().split()):
     ans[i-1] = 0
-for i in range(N-2, 0, -1):
+for i in range(N-1, 0, -1):
     ans[i-1] = min(ans[i-1], ans[i]+1)
 
 print('\n'.join(map(str, ans)))

### Diff 3
--- 
+++ 
@@ -1,7 +1,7 @@
 N = int(input())
 
 D=[]
-for i in range(1,9):
+for i in range(1,10):
   if N % i ==0:
     D.append(i)
 

### Diff 4
--- 
+++ 
@@ -1,12 +1,13 @@
 N, M = map(int, input().split())
- 
+
 P = 1
 ans = 0
- 
+
 for y in range(2, N + 1):
   P = P * (N + 1 - y) % M
   f = P * pow(N, N - y, M)
- 
+
   ans += f * (y - 1) * y // 2
   ans %= M
-  print(ans * N % M)
+
+print(ans * N % M)

### Diff 5
--- 
+++ 
@@ -1,6 +1,6 @@
 N = int(input())
 least_number = 0
-for number in range(1000000):
+for number in range(10000000):
     if number**3 <= N:
         for_number = str(number**3)
         rev_number = str(number**3)[::-1]

Your task:
1) Identify the single incorrect line according to the problem summary and the retrieved diffs.
2) Assume EXACTLY ONE line is wrong.
3) Provide the corrected version of the ENTIRE program, changing only that single line â€” all other lines must remain identical.
4) Do not restructure or rewrite unrelated code.
5) Respond ONLY in JSON format:

{
  "explanation": "Explain what was wrong in that single line and how you fixed it (mention which diff patterns inspired the fix if applicable).",
  "fixed_code": "The FULL program with only that ONE line corrected."
}