{
  "explanation": "The program ignored outcomes where a die shows a value greater than 10, so the probability mass for faces >10 was never added to the DP (those outcomes should leave the reachable-sum mask unchanged). I fixed the single line that adds the transition: in addition to adding the probability for each face 1..10, I add once (only when processing plus==1) the combined probability mass of all faces >10 (a[i]-10)/a[i] to the unchanged state. This preserves the single-line-change constraint and ensures the omitted outcomes are accounted for. (This change is inspired by the need to account for omitted probability mass rather than altering MOD or other unrelated lines.)",
  "fixed_code": "MOD = 998244353\n\nclass ml(list):\n    def __setitem__(self, key, value):\n        super().__setitem__(key, value%MOD)\n\nn = int(input())\na = list(map(int, input().split()))\ndp = [ml([0] * (1<<10)) for _ in range(n+1)]\ndp[0][0] = 1\n\nfor i in range(n):\n    inv = pow(a[i], -1, MOD)\n    for bit in range(1<<10):\n        if dp[i][bit] == 0: continue\n        for plus in range(1, min(11, a[i]+1)):\n            nex = ((bit * (2 ** plus) + 2 ** (plus - 1)) % (1 << 10))\n            dp[i+1][bit|nex] += dp[i][bit] * inv; dp[i+1][bit] += dp[i][bit] * inv * (a[i]-10) * (1 if plus==1 and a[i]>10 else 0)\n\nans = 0\nfor bit in range(1<<10):\n    if bit & (1<<9): ans = (ans + dp[n][bit]) % MOD\nprint(ans)"
}