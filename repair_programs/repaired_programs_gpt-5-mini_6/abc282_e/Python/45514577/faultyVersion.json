{
  "explanation": "The code was building a minimum spanning tree because edges.sort() sorts edges in ascending order (choosing smallest weights first). The problem requires maximizing the total score, so we must process edges from largest to smallest. I fixed the single line by sorting edges in descending order using edges.sort(reverse=True).",
  "fixed_code": "from atcoder.dsu import DSU\nfrom heapq import heappop, heappush\nfrom collections import deque\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\nG = [[0] * N for _ in range(N)]\nfor i in range(N):\n    for j in range(i+1, N):\n        G[i][j] = (pow(A[i], A[j], M) + pow(A[j], A[i], M)) % M\n        G[j][i] = G[i][j]\n\nedges = []\nfor i in range(N):\n    for j in range(i+1, N):\n        edges.append(((pow(A[i], A[j], M) + pow(A[j], A[i], M)) % M, i, j))\nedges.sort(reverse=True)\n\nans = 0\nuf = DSU(N)\nfor p, i, j in edges:\n    if uf.same(i, j): continue\n    ans += p\n    uf.merge(i, j)\nprint(ans)\n"
}