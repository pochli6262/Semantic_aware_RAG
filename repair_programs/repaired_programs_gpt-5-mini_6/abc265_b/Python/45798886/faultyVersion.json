{
  "explanation": "The program treated t == 0 as a valid remaining time after a move (it used `if t >= 0:`), but the problem states a move that makes the time limit 0 or less is not allowed. I changed the condition to require t > 0 after subtracting the move cost. This is a one-line comparator fix (inspired by the bug summary pointing out the >= vs > logic).",
  "fixed_code": "import sys\nsys.setrecursionlimit(10 ** 5 + 10000)\n# sys.setrecursionlimit(10**6)\ninput = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\ndef II(): return int(input())\ndef MI(): return map(int, input().split())\ndef MI1(): return map(int1, input().split())\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LIS(): return list(map(int, SI()))\ndef LA(f): return list(map(f, input().split()))\ndef LLI(H): return [LI() for _ in range(H)]     # H:列数\ndef SI(): return input().strip('\\n')\n### 数字文字交じりクエリを文字列のリストにする '1 19 G' -> ['1', '19', 'G']\n# input()を含まず、受け取ったLLSのクエリの文字列に対し実行する\n# l = ''.join(Strings).split(' ')\ndef MS(): return input().split()\ndef LS(): return list(input().strip('\\n'))\ndef LLS(H): return [LS() for _ in range(H)]\n# 迷路の前後左右\n#for y, x in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\ndef gen_matrix(h, w, init): return [[init] * w for _ in range(h)]\nINF = float('inf')\n# from bisect import bisect_left, bisect_right\n# from heapq import heapify, heappop, heappush\nimport decimal\nfrom decimal import Decimal\nimport math\nfrom math import ceil, floor, log2, log, sqrt, gcd\ndef lcm(x, y): return (x * y) // gcd(x, y)\n# At = list(zip(*A)) 転置行列\nfrom itertools import combinations as comb, combinations_with_replacement as comb_w, product, permutations, accumulate\nfrom collections import deque, defaultdict\nfrom pprint import pprint\n# import numpy as np    # cumsum\nfrom functools import reduce, lru_cache     # decorator: 関数をメモ化再起してくれる. max_size=128\nimport operator\nfrom copy import deepcopy\nMOD = 10**9+7\nMOD2 = 998244353\ndef y(): print('Yes'); exit()\ndef n(): print('No'); exit()\nfrom bisect import bisect_left, bisect_right, insort\nfrom typing import Generic, Iterable, Iterator, TypeVar, Union, List\nT = TypeVar('T')\n \n# 累積和 ans=list(itertools.accumulate(L))\n# 順列 ans=list(itertools.permutation(L))\n# 直積 ans=list(itertools.product(L,M))\n# 重複なし組み合わせ ans=list(itertools.combinations(L,2))\n# 重複あり組み合わせ ans=list(itertools.combinations_with_replacement(L,2))\n# nCr ans=math.comb(n,r)\n\ndef solve():\n    ans = INF\n\n    n,m,t = MI()\n    A = LI()\n    L = LLI(m)\n\n    d = defaultdict(int)\n    for x, y in L:\n        d[x] = y\n\n    for i, a in enumerate(A):\n        room = i+1          # 1-index\n        if d[room]:\n            t += d[room]\n        t -= a\n        if t > 0:\n            continue\n        else:\n            print(\"No\")\n            exit()\n    \n    print(\"Yes\")\n\n\n\nif __name__ == '__main__':\n    solve()\n"
}