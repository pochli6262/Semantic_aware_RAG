{
  "explanation": "The loop 'for i in range(1,4):' skipped the 0-degree orientation of A (no rotation). That caused valid matches where A already fits inside B to be missed. I changed the loop to 'for i in range(4):' so it checks all four rotations (0, 90, 180, 270 degrees).",
  "fixed_code": "# B\n\nn = int(input())\na = []\nfor _ in range(n):\n    cur_a = list(map(int, input().split()))\n    a.append(cur_a)\nb = []\nfor _ in range(n):\n    cur_b = list(map(int, input().split()))\n    b.append(cur_b)\n\n'''\nn = 3\na = [[0, 1, 1], [1, 0, 0], [0, 1, 0]]\nb = [[1, 1, 0], [0, 0, 1], [1, 1, 1]]\n'''\n'''\nn = 5\na = [[0, 0, 1, 1, 0], [1, 0, 0, 1, 0], [0, 0, 1, 0, 1], [0, 1, 0, 1, 0], [0, 1, 0, 0, 1]]\nb = [[1, 1, 0, 0, 1], [0, 1, 1, 1, 0], [0, 0, 1, 1, 1], [1, 0, 1, 0, 1], [1, 1, 0, 1, 0]]\n'''\n#print(a)\n#print(b)\nimport numpy as np\nfor i in range(4):\n    #print(\"=====================\")\n    #print(i)\n    a90 = np.rot90(a, k = -i)\n    #print(a90)\n    ans = True\n    for j in range(n):\n        for k in range(n):\n            #ans = True\n            #print(\"-----------------\")\n            #print(\"j, k\", j, k)\n            #print(\"a90:::::::::\", a90[j][k])\n            if a90[j][k] == 1:\n                #print(\"b[j][j]:::::\", b[j][k])\n                if b[j][k] != 1:\n                    ans = False\n                    #print(\"NG::::::::::::::::::::::\")\n    if ans:\n        break   \nif ans:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n"
}