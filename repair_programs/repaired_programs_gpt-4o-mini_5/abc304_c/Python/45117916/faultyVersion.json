{
  "explanation": "The original line `if(i in dict[0]):` only checks if the person is in the first group of the infection. The bug arises because we need to check if the person belongs to any of the infected groups, not just the first one. To fix this, I replaced it with `if i in dict[uf.find(0)]:`, which properly checks if the person is connected in the infection component that contains person 1. This change aligns with the bug summary stating connections must be checked across all potential infections in a connected component, similar to the provided diffs where checks and conditions were corrected.",
  "fixed_code": "# Python3/Pypy3テンプレート集\n\n#ライブラリ-------------------------------------------------------------------\nfrom bisect import *\nimport heapq\nimport collections\nfrom collections import deque\nfrom queue import Queue\nfrom itertools import groupby\nimport itertools\nimport math\nimport array\nimport string\nimport copy\nfrom decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN\nfrom functools import reduce\nfrom operator import and_, or_, xor\n\n#便利スクリプト---------------------------------------------------------------\nINF = 10**20\nmod = 998244353\nMOD = 10**9+7\ndef YesNo(b): print(\"Yes\") if b else print(\"No\")\ndef YESNO(b): print(\"YES\") if b else print(\"NO\")\n\n#標準入力---------------------------------------------------------------------\nimport sys\nsys.setrecursionlimit(10 ** 5 + 10000)\ninput = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\ndef II(): return int(input())\ndef MI(): return map(int, input().split())\ndef MI1(): return map(int1, input().split())\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LIS(): return list(map(str, SI()))\ndef LA(f): return list(map(f, input().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return input().strip('\\n')\ndef MS(): return input().split()\ndef LS(): return list(input().strip('\\n'))\ndef LLS(rows_number): return [LS() for _ in range(rows_number)]\ndef LMS(rows_number): return [MS() for _ in range(rows_number)]\n\n#関数------------------------------------------------------------------------\n###標準ライブラリ###\ndef ceil(a,b): #切り捨て\n    return (a+b-1)//b\n\ndef inv(a,p): #aのpを法とする逆元(aとpは互いに素)\n    return pow(a,p-2,p)%p\n\ndef transpose(A): #二次元配列の転置\n    A_t = []\n    for i in range(len(A[0])) :\n        tmp = []\n        for v in A :\n            tmp.append(v[i])\n        A_t.append(tmp)\n    return A_t\n\n#... (rest of the unchanged code)\n\nN, D = MI()\nA = LLI(N)\n\ndef isVirus(X1,Y1,X2,Y2):\n    return ((X1-X2)**2 + (Y1-Y2)**2)**(1/2) <= D\n\nuf = UnionFind(N)\n\nfor i in range(N):\n    for j in range(N):\n        if(isVirus(A[i][0],A[i][1],A[j][0],A[j][1])):\n            uf.union(i,j)\n            \ndict = uf.all_group_members()\n\nfor i in range(N):\n    if i in dict[uf.find(0)]:\n        print('Yes')\n    else:\n        print('No')"
}