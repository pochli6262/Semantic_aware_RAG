You are a Python expert.

A user gives you the following Python program which is buggy.

## Problem Description (from dataset)
Score : 500 points

### Problem Statement

You have an integer 1 and a die that shows integers between 1 and 6 (inclusive) with equal probability.  
You repeat the following operation while your integer is strictly less than N:

* Cast a die. If it shows x, multiply your integer by x.

Find the probability, modulo 998244353, that your integer ends up being N.

 How to find a probability modulo 998244353? 
We can prove that the sought probability is always rational.
Additionally, under the constraints of this problem, when that value is represented as \frac{P}{Q} with two coprime integers P and Q, we can prove that there is a unique integer R such that R \times Q \equiv P\pmod{998244353} and 0 \leq R \lt 998244353. Find this R.

### Constraints

* 2 \leq N \leq 10^{18}
* N is an integer.

---

### Input

The input is given from Standard Input in the following format:

```
N
```

### Output

Print the probability, modulo 998244353, that your integer ends up being N.

---

### Sample Input 1

```
6
```

### Sample Output 1

```
239578645
```

One of the possible procedures is as follows.

* Initially, your integer is 1.
* You cast a die, and it shows 2. Your integer becomes 1 \times 2 = 2.
* You cast a die, and it shows 4. Your integer becomes 2 \times 4 = 8.
* Now your integer is not less than 6, so you terminate the procedure.

Your integer ends up being 8, which is not equal to N = 6.

The probability that your integer ends up being 6 is \frac{7}{25}. Since 239578645 \times 25 \equiv 7 \pmod{998244353}, print 239578645.

---

### Sample Input 2

```
7
```

### Sample Output 2

```
0
```

No matter what the die shows, your integer never ends up being 7.

---

### Sample Input 3

```
300
```

### Sample Output 3

```
183676961
```

---

### Sample Input 4

```
979552051200000000
```

### Sample Output 4

```
812376310
```

## Your Analysis (1-sentence bug summary)
The program likely has a bug in handling the updates to the `dp` array, as it does not ensure the values are taken modulo `BIGPRIME`, which could lead to incorrect results when updating the probabilities.

## Buggy Program
def ezpow(a, b):
    c = 1
    for i in range(b):
        c = c * a
    return c

class PowMod:
    def __init__(self, A, m=998244353):
        self.memory = {}
        self.A = A
        self.m = m
    def pow(self, b):
        if (b == 0):
            return 1
        if (b == 1):
            return self.A
        if (b in self.memory):
            return self.memory[b]
        m = self.m
        bdiv2 = b//2
        lf = self.pow(bdiv2)
        rg = self.pow(b-bdiv2)
        self.memory[b] = ((lf % m) * (rg % m)) % m
        return ((lf % m) * (rg % m)) % m


def reciprocalMod(a, p=998244353):
    # a**(p-2)を返す。a と p は互いに素であるのが普通。そうでないと答えが出ない可能性が大きい。
    powMod = PowMod(a, p)
    return powMod.pow(p-2)

N = int(input())

# N を 2, 3, 5で割って割り切れなければ当然確率は0。
# まず素因数を求める。
curN = N
factors = {2: 0, 3: 0, 5: 0}
while (True):
    if (curN == 1):
        break
    divided = False
    for p in [2, 3, 5]:
        if (curN % p == 0):
            curN /= p
            factors[p] += 1
            divided = True
            break
    if (not divided):
        print(0)
        exit()
        


#X,Y,Zは2,3,5の指数。
# スタート地点は1(x,y,z=0,0,0)。
# そこから1/5の確率で、x+=1, y+=1, x+=2, z+=1, x,y+=1 と遷移する。
# x,y,zどれか1つでもオーバーしていたらそれ以降の確率は0なので計算しなくてよい。

# 小さい順から取り出して調べていけば、正常に値を計算できる。
# /5は、 5の 逆数をmod BIGPRIMEで掛けるという動作で正しく計算できる（ABC297-Eより)
# x2の場合: dp[x+1][y][z] = dp[x][y][z] / 5 = dp[x][y][z] * mod.reciprocalMod(5) if x+1 <= X else 0
# 結局、データ量は (X-1)(Y-1)(Z-1)個使い、N <= 10^18なので Xは10^6レベル、よってXの数は20くらい。最大は20^3となるので8000くらい。
# DPの数的にメモリ・計算量ともに制約を満たす。
# 求めるのは、dp[X][Y][Z]
# 入れる順番は、予めXYZで3重ループしてlistを作っておく。

X = factors[2]
Y = factors[3]
Z = factors[5]


BIGPRIME = 998244353
recip5 = reciprocalMod(5, BIGPRIME)
order = [] # 0 ～ XYZまでを小さい順で並べる。すると後から前の値を更新ということが起こらない。
for x in range(X+1):
    for y in range(Y+1):
        for z in range(Z+1):
            order.append((ezpow(2, x) * ezpow(3, y) * ezpow(5, z), x, y, z))
order.sort()            

dp = [[[0 for _ in range(Z+1)] for _ in range(Y+1)] for _ in range(X+1)]
dp[0][0][0] = 1

#print(factors)
#print(order)

for num, x, y, z in order:
    if (x + 1 <= X): # 2
        dp[x+1][y][z] += (dp[x][y][z] * recip5) % BIGPRIME
        if (x + 2 <= X): # 4
            dp[x+2][y][z] += (dp[x][y][z] * recip5) % BIGPRIME
        if (x + 1 <= X and y + 1 <= Y): # 6
            dp[x+1][y+1][z] += (dp[x][y][z] * recip5) % BIGPRIME
    if (y + 1 <= Y): # 3
        dp[x][y+1][z] += (dp[x][y][z] * recip5) % BIGPRIME
    if (z + 1 <= Z): # 5
        dp[x][y][z+1] += (dp[x][y][z] * recip5) % BIGPRIME

print(dp[X][Y][Z] % BIGPRIME)

## Related Known Fixes (retrieved diffs)
### Diff 1
--- 
+++ 
@@ -77,7 +77,9 @@
     v_s = mod_time(v_f, fraci[i])
 
     ans[0] += (mod_time(v_f, Prob[i][0]) + mod_time(v_s, Prob[i][1])) % BigPrime
+    ans[0] %= BigPrime
     ans[1] += (mod_time(v_s, Prob[i][0]) + mod_time(v_f, Prob[i][1])) % BigPrime
+    ans[1] %= BigPrime
 
 print(*ans)
 

### Diff 2
--- 
+++ 
@@ -71,7 +71,7 @@
     # g1 = pow(g, MOD - 2, MOD)
     lcm = ((A1 * A2) // g) % MOD
     # lcm1 = pow(lcm, MOD - 2, MOD)
-    print(A1, A2, lcm, N // lcm)
+    # print(A1, A2, lcm, N // lcm)
     return N // lcm
 
 

### Diff 3
--- 
+++ 
@@ -54,6 +54,6 @@
         # Z個の零要素中N-K+1-C個以上をi以上に置換える
         for m in range(N-K+1-C, Z+1):
 #            print(f'i={i}, comb({Z},{m})*pow({M-i+1},{m})*pow({M},{Z-m})')
-            NC = (NC + comb(Z,m)*pow(M-i+1,m,MOD)*pow(M,Z-m,MOD)) % MOD
+            NC = (NC + comb(Z,m)*pow(M-i+1,m,MOD)*pow(i-1,Z-m,MOD)) % MOD
 
 print((NC*NAI)%MOD)

### Diff 4
--- 
+++ 
@@ -42,7 +42,7 @@
     # 置けるマス、置ける数は合計 L 個
     for j in range(n+1)[::-1]:
         for k in range(j,n+1)[::-1]:
-            if dp[j][k] == 0: break
+            if dp[j][k] == 0: continue
             # i 個を l セット置く
             r = finv[i]
             for l in range(1,n+1):

### Diff 5
--- 
+++ 
@@ -20,7 +20,7 @@
         r = max(r, pos[a] + 1)
 
 dp = [[0] * (m + 2) for _ in range(m + 1)]
-dp[0][-1] = 1
+dp[0][m] = 1
 for a in range(n - 1, min_aaa, -1):
     ndp1 = [[0] * (m + 2) for _ in range(m + 1)]  # l が増える方向の累積和
     ndp2 = [[0] * (m + 2) for _ in range(m + 1)]  # r が減る方向の累積和

Your task:
1) Identify the single incorrect line according to the problem summary and the retrieved diffs.
2) Assume EXACTLY ONE line is wrong.
3) Provide the corrected version of the ENTIRE program, changing only that single line — all other lines must remain identical.
4) Do not restructure or rewrite unrelated code.
5) Respond ONLY in JSON format:

{
  "explanation": "Explain what was wrong in that single line and how you fixed it (mention which diff patterns inspired the fix if applicable).",
  "fixed_code": "The FULL program with only that ONE line corrected."
}