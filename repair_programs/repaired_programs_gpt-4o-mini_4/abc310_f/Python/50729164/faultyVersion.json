{
  "explanation": "The issue was with the line using 'inv = pow(a[i], -1, MOD)', which incorrectly calculates the modular inverse for accumulating probabilities. The modular inverse should not be used for this purpose in the accumulation, hence it should be removed to prevent incorrect results. This aligns with the logic from related fixes that emphasized modifying the way probabilities are added, which can be seen in the context of keeping counts rather than calculating inverses.",
  "fixed_code": "MOD = 998244353\n\nclass ml(list):\n    def __setitem__(self, key, value):\n        super().__setitem__(key, value%MOD)\n\nn = int(input())\na = list(map(int, input().split()))\ndp = [ml([0] * (1<<10)) for _ in range(n+1)]\ndp[0][0] = 1\n\nfor i in range(n):\n    # inv = pow(a[i], -1, MOD)  # THIS LINE IS REMOVED\n    for bit in range(1<<10):\n        if dp[i][bit] == 0: continue\n        for plus in range(1, min(11, a[i]+1)):\n            nex = ((bit * (2 ** plus) + 2 ** (plus - 1)) % (1 << 10))\n            dp[i+1][bit|nex] += dp[i][bit]  # Update this line to avoid using inv\n\nans = 0\nfor bit in range(1<<10):\n    if bit & (1<<9): ans = (ans + dp[n][bit]) % MOD\nprint(ans)"
}