You are a Python expert.

A user gives you the following Python program which is buggy.

## Problem Description (from dataset)
Score : 100 points

### Problem Statement

Given eight integers S\_1,S\_2,\dots, and S\_8,
print `Yes` if they satisfy all of the following three conditions, and `No` otherwise.

* The sequence (S\_1,S\_2,\dots,S\_8) is monotonically non-decreasing. In other words, S\_1 \leq S\_2 \leq \dots \leq S\_8.
* S\_1,S\_2,\dots, and S\_8 are all between 100 and 675, inclusive.
* S\_1,S\_2,\dots, and S\_8 are all multiples of 25.

### Constraints

* 0\leq S\_i \leq 1000
* All input values are integers.

---

### Input

The input is given from Standard Input in the following format:

```
S_1 S_2 \dots S_8
```

### Output

Print the answer.

---

### Sample Input 1

```
125 175 250 300 400 525 600 650
```

### Sample Output 1

```
Yes
```

They satisfy all of the three conditions.

---

### Sample Input 2

```
100 250 300 400 325 575 625 675
```

### Sample Output 2

```
No
```

They violate the first condition because S\_4 > S\_5.

---

### Sample Input 3

```
0 23 24 145 301 413 631 632
```

### Sample Output 3

```
No
```

They violate the second and third conditions.

## Your Analysis (1-sentence bug summary)
The likely bug is that the second loop incorrectly uses the variable `i` instead of `j`, causing it to always reference the last element of the list when checking for the range and divisibility conditions.

## Buggy Program
S = list(map(int,input().split()))
ans = "Yes"
for i in range(len(S)-1):
  if not(S[i] <= S[i+1]):
    ans = "No"
for j in range(len(S)):
  if not(S[i] % 25 == 0 and 100 <= S[i] <= 675):
    ans = "No"
print(ans)

## Related Known Fixes (retrieved diffs)
### Diff 1
--- 
+++ 
@@ -1,7 +1,7 @@
 S = input()
 ans = True
 for i in range(1, 17, 2):
-  if S[i-1]!='0':
+  if S[i]!='0':
     ans = False
 
 if ans:

### Diff 2
--- 
+++ 
@@ -1,6 +1,6 @@
 s = input()
 ans = "Yes"
-for i in range(3,16):
+for i in range(16):
     if i %2 == 1 and s[i] != "0":
         ans = "No"
         break

### Diff 3
--- 
+++ 
@@ -3,10 +3,9 @@
 
 for s in S:
   num[S.count(s)] += 1
-  
 for n in num:
-  if n % 2 != 0:
+  if  2 * num.index(n) != n:
     print('No')
     exit()
-    
+
 print('Yes')

### Diff 4
--- 
+++ 
@@ -1,7 +1,7 @@
 S = input().strip()
 
 for i in range(1, 9):
-  if S[2 * i - 1] != 0:
+  if S[2 * i - 1] != "0":
     print("No")
     exit()
 print("Yes")

### Diff 5
--- 
+++ 
@@ -1,5 +1,5 @@
 S = input()
-if int(S[3:]) == 316 or int(S[3:]) > 349:
+if int(S[3:]) == 316 or int(S[3:]) > 349 or int(S[3:]) == 0:
     print("No")
 else:
     print("Yes")

Your task:
1) Identify the single incorrect line according to the problem summary and the retrieved diffs.
2) Assume EXACTLY ONE line is wrong.
3) Provide the corrected version of the ENTIRE program, changing only that single line â€” all other lines must remain identical.
4) Do not restructure or rewrite unrelated code.
5) Respond ONLY in JSON format:

{
  "explanation": "Explain what was wrong in that single line and how you fixed it (mention which diff patterns inspired the fix if applicable).",
  "fixed_code": "The FULL program with only that ONE line corrected."
}