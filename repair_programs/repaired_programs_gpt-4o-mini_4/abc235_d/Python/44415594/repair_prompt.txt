You are a Python expert.

A user gives you the following Python program which is buggy.

## Problem Description (from dataset)
Score : 400 points

### Problem Statement

We have a positive integer a. Additionally, there is a blackboard with a number written in base 10.  
Let x be the number on the blackboard. Takahashi can do the operations below to change this number.

* Erase x and write x multiplied by a, in base 10.
* See x as a string and move the rightmost digit to the beginning.  
  This operation can only be done when x \geq 10 and x is not divisible by 10.

For example, when a = 2, x = 123, Takahashi can do one of the following.

* Erase x and write x \times a = 123 \times 2 = 246.
* See x as a string and move the rightmost digit `3` of `123` to the beginning, changing the number from 123 to 312.

The number on the blackboard is initially 1. What is the minimum number of operations needed to change the number on the blackboard to N? If there is no way to change the number to N, print -1.

### Constraints

* 2 \leq a \lt 10^6
* 2 \leq N \lt 10^6
* All values in input are integers.

---

### Input

Input is given from Standard Input in the following format:

```
a N
```

### Output

Print the answer.

---

### Sample Input 1

```
3 72
```

### Sample Output 1

```
4
```

We can change the number on the blackboard from 1 to 72 in four operations, as follows.

* Do the operation of the first type: 1 \to 3.
* Do the operation of the first type: 3 \to 9.
* Do the operation of the first type: 9 \to 27.
* Do the operation of the second type: 27 \to 72.

It is impossible to reach 72 in three or fewer operations, so the answer is 4.

---

### Sample Input 2

```
2 5
```

### Sample Output 2

```
-1
```

It is impossible to change the number on the blackboard to 5.

---

### Sample Input 3

```
2 611
```

### Sample Output 3

```
12
```

There is a way to change the number on the blackboard to 611 in 12 operations: 1 \to 2 \to 4 \to 8 \to 16 \to 32 \to 64 \to 46 \to 92 \to 29 \to 58 \to 116 \to 611, which is the minimum possible.

---

### Sample Input 4

```
2 767090
```

### Sample Output 4

```
111
```

## Your Analysis (1-sentence bug summary)
The program likely fails to correctly track the minimum operations needed due to improper handling of the bounds for `numSet`, which could lead to out-of-bounds errors or incorrect state updates during the search.

## Buggy Program
from sys import stdin, setrecursionlimit
a, n = list(map(int, input().split()))

setrecursionlimit(10 ** 9)
numSet = [10**5] * (10 ** 7)
ans = 10 ** 10

def numSrch(c, moves):
    global numSet
    # print(c, numSet[c], moves)
    if c == 1:
        global ans
        ans = min(ans, moves)
        return
    elif numSet[c] > moves:
        # print(c)
        numSet[c] = moves

        if c % a == 0:
            c1 = int(c//a)
            if numSet[c1] > moves+1:
                numSrch(c1, moves+1)
        if c > 11:
            c2 = str(c)
            c2 = "".join([c2[1:], c2[0]])
            # print(c, c2)
            c2 = int(c2)
            if numSet[c2] > moves+1:
                numSrch(c2, moves+1)

numSrch(n, 0)
if ans == 10 ** 10:
    ans = -1
print(ans)


## Related Known Fixes (retrieved diffs)
### Diff 1
--- 
+++ 
@@ -26,7 +26,7 @@
 ans = 0
 
 # for all possible squared numbers, check if it is possible to create by rearraning S
-for i in range(1, math.ceil(math.sqrt(10**N))):
+for i in range(math.ceil(math.sqrt(10**N))):
     squared = i * i
     count_squared = [0] * 10
 

### Diff 2
--- 
+++ 
@@ -6,7 +6,7 @@
 # n = int(input())
 n,q = map(int, input().split())
 if q==2:
-    print(int(math.log(n,2)))
+    print(int(math.log(n,2))+1)
     exit()
 P = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
 r = 0

### Diff 3
--- 
+++ 
@@ -37,7 +37,7 @@
         if now >= Ns:
             v += Ns
             now -= Ns
-    v += now + 1
+    v += now
     return v <= N * Ns
 
         

### Diff 4
--- 
+++ 
@@ -2,7 +2,7 @@
 s = [int(x) for x in input()]
 s.sort()
 ans = 0
-for x in range(1, 10**7):
+for x in range(10**7):
     t = [int(c) for c in str(x * x)]
     if len(t) > n:
         break

### Diff 5
--- 
+++ 
@@ -45,6 +45,8 @@
                 ans.append(str(9-i))
         else:
             continue
+        if len(ans) == digits:
+            break
 
     return ''.join(ans)
 

Your task:
1) Identify the single incorrect line according to the problem summary and the retrieved diffs.
2) Assume EXACTLY ONE line is wrong.
3) Provide the corrected version of the ENTIRE program, changing only that single line â€” all other lines must remain identical.
4) Do not restructure or rewrite unrelated code.
5) Respond ONLY in JSON format:

{
  "explanation": "Explain what was wrong in that single line and how you fixed it (mention which diff patterns inspired the fix if applicable).",
  "fixed_code": "The FULL program with only that ONE line corrected."
}