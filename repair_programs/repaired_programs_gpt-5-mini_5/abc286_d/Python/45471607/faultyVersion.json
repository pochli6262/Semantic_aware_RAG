{
  "explanation": "The bug was in the inner DP update: the code used an assignment dp[i+1][j] = dp[i][j] or dp[i][j - k * a[i]] which overwrote dp[i+1][j] on each k iteration, possibly discarding a True set by an earlier k. I changed the line to OR with the existing dp[i+1][j] so earlier True values are preserved: dp[i+1][j] = dp[i+1][j] or dp[i][j - k * a[i]]. This follows the same idea as other fixes that preserve previous state when updating (e.g. using max/OR to accumulate instead of replacing).",
  "fixed_code": "import sys\nimport math\nfrom collections import defaultdict\nfrom collections import Counter\nfrom functools import lru_cache\n\n\nsys.setrecursionlimit(10 ** 8)\nMOD1 = 10**9 + 7\n\n\ndef main():\n    n, x = map(int, sys.stdin.readline().split())\n    a, b = [], []\n    for _ in range(n):\n        ai, bi = map(int, sys.stdin.readline().split())\n        a.append(ai)\n        b.append(bi)\n\n    # @lru_cache(maxsize=None)\n    # def rec(index, s):\n    #     if s == x:\n    #         return True\n    #\n    #     if index == n:\n    #         return False\n    #\n    #     for i in range(b[index] + 1):\n    #         if rec(index + 1, s + i * a[index]):\n    #             return True\n    #     return False\n    #\n    # if rec(0, 0):\n    #     print(\"Yes\")\n    # else:\n    #     print(\"No\")\n    dp = [[False for _ in range(x + 1)] for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(n):\n        for j in range(x + 1):\n            for k in range(b[i] + 1):\n                if j >= k * a[i]:\n                    dp[i + 1][j] = dp[i + 1][j] or dp[i][j - k * a[i]]\n    if dp[n][x]:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\nif __name__ == '__main__':\n    main()\n"
}