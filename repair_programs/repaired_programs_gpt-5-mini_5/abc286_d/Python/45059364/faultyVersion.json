{
  "explanation": "The DP was being updated in increasing order of n (for n in range(X+1)), which allows newly set DP values from the current coin type to be reused later in the same coin loop and thus treats the coin as effectively unbounded. The standard fix for bounded knapsack with in-place DP is to iterate n in descending order so that DP[n - c*a] refers to states before using the current coin type. I fixed the single line by changing the loop to iterate from X down to 0.",
  "fixed_code": "N,X=map(int,input().split())\n  \nDP=[0]*(X+1) #DP[n]=現在n円払えるか\nDP[0]=1\nfor i in range(N):\n  a,b=map(int,input().split())\n  for n in range(X, -1, -1):\n    for c in range(1,b+1):\n      if 0<=n-c*a and DP[n-c*a]:\n        DP[n]=1\nprint(\"Yes\" if DP[X] else \"No\")"
}