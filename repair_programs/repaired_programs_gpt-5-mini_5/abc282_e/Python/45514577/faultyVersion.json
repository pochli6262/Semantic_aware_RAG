{
  "explanation": "The algorithm was building a maximum spanning tree (to maximize total score) but the edges were sorted in ascending order (edges.sort()), which produces a minimum spanning tree. I fixed the single line to sort edges in descending order using edges.sort(reverse=True) so Kruskal's loop picks largest-weight edges first. This change directly addresses the bug described (choosing edges in descending order).",
  "fixed_code": "from atcoder.dsu import DSU\nfrom heapq import heappop, heappush\nfrom collections import deque\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\nG = [[0] * N for _ in range(N)]\nfor i in range(N):\n    for j in range(i+1, N):\n        G[i][j] = (pow(A[i], A[j], M) + pow(A[j], A[i], M)) % M\n        G[j][i] = G[i][j]\n\nedges = []\nfor i in range(N):\n    for j in range(i+1, N):\n        edges.append(((pow(A[i], A[j], M) + pow(A[j], A[i], M)) % M, i, j))\nedges.sort(reverse=True)\n\nans = 0\nuf = DSU(N)\nfor p, i, j in edges:\n    if uf.same(i, j): continue\n    ans += p\n    uf.merge(i, j)\nprint(ans)\n"
}