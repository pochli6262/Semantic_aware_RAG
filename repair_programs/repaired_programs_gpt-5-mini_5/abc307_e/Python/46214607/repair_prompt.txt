You are a Python expert.

A user gives you the following Python program which is buggy.

## Problem Description (from dataset)
Score : 475 points

### Problem Statement

There are N people numbered from 1 to N standing in a circle. Person 1 is to the right of person 2, person 2 is to the right of person 3, ..., and person N is to the right of person 1.

We will give each of the N people an integer between 0 and M-1, inclusive.  
Among the M^N ways to distribute integers, find the number, modulo 998244353, of such ways that no two adjacent people have the same integer.

### Constraints

* 2 \leq N,M \leq 10^6
* N and M are integers.

---

### Input

The input is given from Standard Input in the following format:

```
N M
```

### Output

Print the answer.

---

### Sample Input 1

```
3 3
```

### Sample Output 1

```
6
```

There are six desired ways, where the integers given to persons 1,2,3 are (0,1,2),(0,2,1),(1,0,2),(1,2,0),(2,0,1),(2,1,0).

---

### Sample Input 2

```
4 2
```

### Sample Output 2

```
2
```

There are two desired ways, where the integers given to persons 1,2,3,4 are (0,1,0,1),(1,0,1,0).

---

### Sample Input 3

```
987654 456789
```

### Sample Output 3

```
778634319
```

Be sure to find the number modulo 998244353.

## Your Analysis (1-sentence bug summary)
The code mixes a modular pow with a non-modular term and never reduces the final sum modulo 998244353, so it can produce incorrect or negative outputs.

## Buggy Program
N,M=map(int,input().split())
mod=998244353

answer=(-1)**(N%2)*(M-1)+pow(M-1,N,mod)
print(answer)

## Related Known Fixes (retrieved diffs)
### Diff 1
--- 
+++ 
@@ -1,2 +1,2 @@
 N,M,P=map(int,input().split())
-print((N-M)//P+1 if N>M else 0)
+print((N-M)//P+1 if N>=M else 0)

### Diff 2
--- 
+++ 
@@ -17,6 +17,8 @@
     if N < M:
         return pow(2, N, 10)
     if N == M:
+        if N == 1:
+            return 0
         return 1
     # N > M
     return calc(M-(-N%M), M, 0)

### Diff 3
--- 
+++ 
@@ -5,7 +5,7 @@
 table = [2,4,8,6]
 def solve(N, M, K):
     if M-K == 1:
-        return 0 if N >= K-1 else pow(2, N, 10)
+        return 0 if N >= K else table[(N+3)%4]	# 多分ここがafter_contestに引っかかってる
     if N >= M:
 		# N<MになるまでNからM-Kを引く操作を高速に行う。
 		# NからN-Mより大きいM-Kの倍数で引く

### Diff 4
--- 
+++ 
@@ -1,7 +1,7 @@
 P,B,N,M = map(int,input().split())
 LR = [tuple(map(int,input().split())) for _ in range(M)]
 
-if P >= N:
+if P >= N+1:
     exit(print('Yes'))
 
 INF = 10**18

### Diff 5
--- 
+++ 
@@ -30,4 +30,4 @@
         ndp[i|j] += dp[j]*(p2[cnt[i]]-1)
         ndp[i|j] %= mod
     dp = ndp
-print(dp[(1<<K)-1])
+print(dp[(1<<K)-1]) if M>1 else print((dp[(1<<K)-1]-1)%mod)

Your task:
1) Identify the single incorrect line according to the problem summary and the retrieved diffs.
2) Assume EXACTLY ONE line is wrong.
3) Provide the corrected version of the ENTIRE program, changing only that single line — all other lines must remain identical.
4) Do not restructure or rewrite unrelated code.
5) Respond ONLY in JSON format:

{
  "explanation": "Explain what was wrong in that single line and how you fixed it (mention which diff patterns inspired the fix if applicable).",
  "fixed_code": "The FULL program with only that ONE line corrected."
}