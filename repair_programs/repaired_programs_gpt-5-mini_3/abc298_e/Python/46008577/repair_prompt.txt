You are a Python repair assistant.

A user gives you the following buggy program.

## Buggy Program
N,A,B,P,Q=map(int,input().split())
mod=998244353

def sugoroku(X,start):
    dp=[[0 for _ in range(N+1)] for _ in range(N+1)]
    dp[0][start]=1
    for i in range(N):
        for j in range(N+1):
            for k in range(1,X+1):
                    denominator=pow(X,-1,mod)
                    if j+k>=N:
                        dp[i+1][N]+=dp[i][j]*denominator%mod
                    else:
                        dp[i+1][j+k]+=dp[i][j]*denominator%mod
    return dp

T_dp=sugoroku(P,A)
A_dp=sugoroku(Q,B)

answer=0
for i in range(N):
    answer+=(1-A_dp[i][-1])*T_dp[i+1][-1]
    answer%=mod

print(answer%mod)

## Related Example Fixes (retrieved from similar problems)
These examples are only references. 
They must NOT be copied directly, but can inspire how similar bugs were fixed.

### Example 1
--- Buggy Code ---
Q=int(input())
for _ in range(Q):
  P,A,B,S,G=map(int,input().split())
  mod=P
  if S==G:
    print(0)
    continue
  if A==0:
    if B==P:
      print(1)
      continue
    else:
      print(-1)
      continue
  def g(x):
    ans=1
    w=x
    n=mod-2
    while n>0:
      if n&1:
        ans*=w
        ans%=mod
      w**=2
      w%=mod
      n//=2
    return ans
  if A==1:
    if B==0:
      print(-1)
      continue
    ans=(G-S)*g(B)
    ans%=mod
    print(ans)
    continue
  c=B*g(A-1)
  c%=mod
  if ((S+c)%mod)==0:
    print(-1)
    continue
  ans=(G+c)*g(S+c)
  ans%=mod
  T={}
  d=1
  from math import sqrt
  k=int(sqrt(mod))
  for i in range(k):
    if not d in T:
      T[d]=i
    d*=A
    d%=mod
  result=10**20
  for y in range(k+2):
    e=ans*pow(A,-k*y,mod)
    e%=mod
    if e in T:
      pos=T[e]
      result=y*k+pos
      break
  if result<10**20:
    print(result)
  else:
    print(-1)

--- Correct Code ---
Q=int(input())
for _ in range(Q):
  P,A,B,S,G=map(int,input().split())
  mod=P
  if S==G:
    print(0)
    continue
  if A==0:
    if B==G:
      print(1)
      continue
    else:
      print(-1)
      continue
  def g(x):
    ans=1
    w=x
    n=mod-2
    while n>0:
      if n&1:
        ans*=w
        ans%=mod
      w**=2
      w%=mod
      n//=2
    return ans
  if A==1:
    if B==0:
      print(-1)
      continue
    ans=(G-S)*g(B)
    ans%=mod
    print(ans)
    continue
  c=B*g(A-1)
  c%=mod
  if ((S+c)%mod)==0:
    print(-1)
    continue
  ans=(G+c)*g(S+c)
  ans%=mod
  T={}
  d=1
  from math import sqrt
  k=int(sqrt(mod))
  for i in range(k):
    if not d in T:
      T[d]=i
    d*=A
    d%=mod
  result=10**20
  for y in range(k+2):
    e=ans*pow(A,-k*y,mod)
    e%=mod
    if e in T:
      pos=T[e]
      result=y*k+pos
      break
  if result<10**20:
    print(result)
  else:
    print(-1)


### Example 2
--- Buggy Code ---
n,k = map(int,input().split())
p = list(map(int,input().split()))
q = list(map(int,input().split()))
mod = 998244353

a = [0]*(n)
for i in range(n):
  a[p[i]-1] = q[i]-1


dp = [[0]*(n+1) for i in range(k+1)] 
dp[0][n] = 1
for i in range(n):
  ai = a[i]
  new = [[0]*(n+1) for i in range(k+1)] 
  for j in range(k+1):
    for mini in range(1, n+1):
      if mini >= ai and j >= 1:
        new[j][mini] += dp[j-1][mini]
      if mini >= ai:
        new[j][ai] += dp[j][mini]
      else:
        new[j][mini] += dp[j][mini]
      new[j][mini] %= mod
      new[j][ai] %= mod
  dp = new

print(sum(dp[-1])%mod)




--- Correct Code ---
n,k = map(int,input().split())
p = list(map(int,input().split()))
q = list(map(int,input().split()))
mod = 998244353

a = [0]*(n)
for i in range(n):
  a[p[i]-1] = q[i]-1


dp = [[0]*(n+1) for i in range(k+1)] 
dp[0][n] = 1
for i in range(n):
  ai = a[i]
  new = [[0]*(n+1) for i in range(k+1)] 
  for j in range(k+1):
    for mini in range(n+1):
      if mini >= ai and j >= 1:
        new[j][mini] += dp[j-1][mini]
      if mini >= ai:
        new[j][ai] += dp[j][mini]
      else:
        new[j][mini] += dp[j][mini]
      new[j][mini] %= mod
      new[j][ai] %= mod
  dp = new

print(sum(dp[-1])%mod)


### Example 3
--- Buggy Code ---
N,K=map(int,input().split())
A=[int(x) for x in input().split()]
mod=998244353
A.sort()
d=1
from collections import Counter
C=Counter(A)
for c in C:
  for i in range(C[c]):
    d*=i+1
    d%=mod
    
dp=[1,0]
t=0
j=N-1
for i in range(N):
  while j>=i:
    if A[j]+A[i]>=K:
      t+=1
    else:
      break
    j-=1 
  if i==j:
    break    
  dp2=[0,0]
  dp2[0]=dp[0]*t*(t-1)%mod
  dp2[1]=(dp[0]*t*2 +dp[1]*(t*(t-1)+t*2)) %mod
  dp=dp2.copy()

  t-=1
  
ans1=dp[0]
for i in range(t+1):
  ans1*=i+1
  ans1%=mod
ans2=dp[1]
for i in range(t+1):
  ans2*=i+1
  ans2%=mod  
ans=ans1+ans2  
ans*=pow(d,mod-2,mod)
print(ans%mod)
         
  


--- Correct Code ---
N,K=map(int,input().split())
A=[int(x) for x in input().split()]
mod=998244353
A.sort()
d=1
from collections import Counter
C=Counter(A)
for c in C:
  for i in range(C[c]):
    d*=i+1
    d%=mod
    
dp=[1,0]
t=0
j=N-1
for i in range(N):
  while j>i:
    if A[j]+A[i]>=K:
      t+=1
    else:
      break
    j-=1 
  if i==j:
    break    
  dp2=[0,0]
  dp2[0]=dp[0]*t*(t-1)%mod
  dp2[1]=(dp[0]*t*2 +dp[1]*(t*(t-1)+t*2)) %mod
  dp=dp2.copy()
  t-=1
  
ans1=dp[0]
for i in range(t+1):
  ans1*=i+1
  ans1%=mod
ans2=dp[1]
for i in range(t+1):
  ans2*=i+1
  ans2%=mod  
ans=ans1+ans2  
ans*=pow(d,mod-2,mod)
print(ans%mod)


Your task:
1) Identify the single incorrect line in the buggy program.
2) Assume EXACTLY ONE line is wrong.
3) Provide the corrected version of the ENTIRE program, changing only that single line.
4) Do not restructure or rewrite unrelated code.
5) Respond ONLY in JSON format:

{
  "explanation": "Explain the bug and how you fixed it.",
  "fixed_code": "The FULL program with only that ONE line corrected."
}