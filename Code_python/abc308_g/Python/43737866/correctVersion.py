# InlineImporter
import os as _os
import sys as _sys
from functools import lru_cache as _lru_cache
from importlib.abc import ExecutionLoader, MetaPathFinder
from importlib.machinery import ModuleSpec


class InlineImporter(ExecutionLoader, MetaPathFinder):

    version = None
    inlined_modules = {}
    namespace_packages = False

    @classmethod
    def find_spec(cls, fullname, path=None, target=None):
        """Find a spec for a given module.
        
        Because we only deal with our inlined module, we don't have to care about path or target.
        The import machinery also takes care of fully resolving all names, so we just have to deal with the fullnames.
        """
        if fullname in cls.inlined_modules:
            # We have inlined this module, so return the spec
            ms = ModuleSpec(fullname, cls, origin=cls.get_filename(fullname), is_package=cls.is_package(fullname))
            ms.has_location = True
            if cls.namespace_packages and ms.submodule_search_locations is not None:
                for p in _sys.path:
                    ms.submodule_search_locations.append(_os.path.join(p, _os.path.dirname(ms.origin)))
            return ms

        return None

    @staticmethod
    def _call_with_frames_removed(f, *args, **kwds):
        """remove_importlib_frames in import.c will always remove sequences
        of importlib frames that end with a call to this function

        Use it instead of a normal call in places where including the importlib
        frames introduces unwanted noise into the traceback (e.g. when executing
        module code)
        """
        return f(*args, **kwds)

    @classmethod
    def create_module(cls, spec):
        """Create a module using the default machinery."""
        return None

    @classmethod
    def exec_module(cls, module):
        """Execute the module."""
        code = cls.get_code(module.__name__)
        if code is None:
            raise ImportError("cannot load module {!r} when get_code() returns None".format(module.__name__))
        cls._call_with_frames_removed(exec, code, module.__dict__)

    @classmethod
    @_lru_cache(maxsize=None)
    def get_filename(cls, fullname):
        """Returns the 

        Raises ImportError if the module cannot be found.
        """
        if fullname not in cls.inlined_modules:
            raise ImportError

        mod = cls.inlined_modules[fullname]
        origin = fullname
        if mod[0]:
            origin = ".".join([origin, "__init__"])
        origin = ".".join([origin.replace(".", "/"), "py"])

        return origin

    @classmethod
    @_lru_cache(maxsize=None)
    def is_package(cls, fullname):
        if fullname not in cls.inlined_modules:
            raise ImportError

        return cls.inlined_modules[fullname][0]

    @classmethod
    def get_source(cls, fullname):
        if fullname not in cls.inlined_modules:
            raise ImportError

        return cls.inlined_modules[fullname][1]

    @classmethod
    def get_code(cls, fullname):
        """Method to return the code object for fullname.

        Should return None if not applicable (e.g. built-in module).
        Raise ImportError if the module cannot be found.
        """
        source = cls.get_source(fullname)
        if source is None:
            return None
        try:
            path = cls.get_filename(fullname)
        except ImportError:
            return cls.source_to_code(source)
        else:
            return cls.source_to_code(source, path)


InlineImporter.version = '0.0.4'
InlineImporter.inlined_modules = {
    'lib.array2d': (False, "class Array2dView:\n    def __init__(self, arr, i_indices, j_indices):\n        self.arr = arr\n        self.i_indices = i_indices\n        self.j_indices = j_indices\n        self.n = len(i_indices)\n        self.m = len(j_indices)\n    \n    def _get_view(self, i, j):\n        i = self.i_indices[i]\n        j = self.j_indices[j]\n        return Array2dView(self.arr, i, j)\n\n    def get_ind(self, i, j):\n        return self.i_indices[i]+self.j_indices[j]\n    \n    def __getitem__(self, index):\n        i, j = index\n        try:\n            return self.arr[self.get_ind(i,j)]\n        except TypeError:\n            return self._get_view(i, j)\n    \n    def __setitem__(self, index, value):\n        i, j = index\n        try:\n            self.arr[self.get_ind(i,j)] = value\n        except TypeError:\n            x = self._get_view(i, j)\n            for i in x.i_indices:\n                for j in x.j_indices:\n                    self.arr[i+j] = value\n    \n    def __iter__(self):\n        for i in self.i_indices:\n            for j in self.j_indices:\n                yield self.arr[i+j]\n    \n    def __reversed__(self):\n        for i in reversed(self.i_indices):\n            for j in reversed(self.j_indices):\n                yield self.arr[i+j]\n    \n    def __str__(self):\n        m = max(len(str(v)) for v in self)\n        res = ['']*len(self.i_indices)\n        row = ['']*(len(self.j_indices)+2)\n        for ri,i in enumerate(self.i_indices):\n            if ri == 0:\n                row[0] = '['\n            else:\n                row[0] = ' '\n            if ri == len(self.i_indices)-1:\n                row[-1] = ']\\n'\n            for rj,j in enumerate(self.j_indices):\n                row[rj+1] = f'{str(self.arr[i+j]):>{m+1}}'\n            res[ri] = ''.join(row)\n        return '\\n'.join(res)\n    \n    def copy(self):\n        return Array2d(len(self.i_indices), len(self.j_indices), list(self))\n\n\nclass Array2d:\n    def __init__(self, n, m, arr):\n        self.n = n\n        self.m = m\n        self.arr = arr\n    \n    @classmethod\n    def full(cls, n, m, fill_value):\n        return cls(n, m, [fill_value]*(n*m))\n    \n    @classmethod\n    def from_list(cls, lst):\n        n,m = len(lst), len(lst[0])\n        arr = [lst[0]]*(n*m)\n        k = 0\n        for row in lst:\n            for v in row:\n                arr[k] = v\n                k += 1\n        return cls(n, m, arr)\n    \n    def _get_view(self, i, j):\n        i = tuple(range(0, self.n*self.m, self.m))[i]\n        j = tuple(range(self.m))[j]\n        return Array2dView(self.arr, i, j)\n\n    def get_ind(self, i, j):\n        return i*self.m+j\n\n    def __getitem__(self, index):\n        try:\n            return self.arr[self.get_ind(*index)]\n        except TypeError:\n            return self._get_view(*index)\n    \n    def __setitem__(self, index, value):\n        try:\n            self.arr[self.get_ind(*index)] = value\n        except TypeError:\n            x = self._get_view(*index)\n            for i in x.i_indices:\n                for j in x.j_indices:\n                    self.arr[i+j] = value\n    \n    def __iter__(self):\n        return iter(self.arr)\n    \n    def __reversed__(self):\n        return reversed(self.arr)\n    \n    def __str__(self):\n        m = max(len(str(v)) for v in self)\n        res = ['']*self.n\n        row = ['']*(self.m+2)\n        for i in range(self.n):\n            if i == 0:\n                row[0] = '['\n            else:\n                row[0] = ' '\n            if i == self.n-1:\n                row[-1] = ']\\n'\n            for j in range(self.m):\n                row[j+1] = f'{str(self.arr[i*self.m+j]):>{m+1}}'\n            res[i] = ''.join(row)\n        return '\\n'.join(res)\n\n    __repr__ = __str__\n\n    def __eq__(self, other):\n        return self.arr == other.arr\n\n    def copy(self):\n        return self.__class__(self.n, self.m, self.arr[:])\n\n    @property\n    def t(self):\n        arr = [self.arr[0]]*(len(self.arr))\n        x = 0\n        for i in range(self.n):\n            for j in range(self.m):\n                arr[j*self.n + i] = self.arr[x]\n                x += 1\n        return self.__class__(self.m, self.n, arr)\n"),
    'lib.array3d': (False, 'class Array3d(list):\n    def __init__(self, n, m, p, arr):\n        list.__init__(self, arr)\n        self.n = n\n        self.m = m\n        self.p = p\n        self.mp = m*p\n\n    @classmethod\n    def full(cls, n, m, p, fill_value):\n        return cls(n, m, p, [fill_value] * (n * m * p))\n\n    def get_ind(self, i, j, k):\n        return i * self.mp + j * self.p + k\n\n    def __getitem__(self, index):\n        return list.__getitem__(self, self.get_ind(*index))\n\n    def __setitem__(self, index, value):\n        list.__setitem__(self, self.get_ind(*index), value)\n'),
    'lib.benchmark': (False, '\nfrom time import perf_counter as timer\ndef simple_timeit(func, repeat=1000, warmup=100):\n    for i in range(warmup):\n        func(i)\n    start = timer()\n    for i in range(repeat):\n        func(i)\n    stop = timer()\n    return stop-start\n'),
    'lib.data_structure': (False, 'from typing import List, Any, TypeVar, Iterator\nfrom collections.abc import MutableSet\n\nclass DisjointSet:\n    def __init__(self, parent):\n        self.parent = parent\n\n    @classmethod\n    def empty(cls, size):\n        return cls([-1]*size)\n\n    def find(self, x):\n        stack = []\n        while self.parent[x] >= 0:\n            stack.append(x)\n            x = self.parent[x]\n        for y in stack:\n            self.parent[y] = x\n        return x\n\n    def union_reps(self, xr, yr):\n        if xr == yr:\n            return xr\n        if self.parent[xr] > self.parent[yr]:\n            xr, yr = yr, xr\n        self.parent[xr] += self.parent[yr]\n        self.parent[yr] = xr\n        return xr\n\n    def union(self, x, y):\n        return self.union_reps(self.find(x), self.find(y))\n\n    def group_size(self, x):\n        return -self.parent[self.find(x)]\n\n    def is_rep(self, x):\n        return self.parent[x] < 0\n\n    def copy(self):\n        return DisjointSet(self.parent)\n\n\nclass SegmentTree:\n    """\n    ???????????????????????????????????\n    ???????????????????????????(???????????)\n    """\n\n    @classmethod\n    def all_identity(cls, operator, identity, size):\n        return cls(operator, identity, [identity] * (2 << (size - 1).bit_length()))\n\n    @classmethod\n    def from_initial_data(cls, operator, identity, data):\n        size = 1 << (len(data) - 1).bit_length()\n        temp = [identity] * (2 * size)\n        temp[size:size + len(data)] = data\n        data = temp\n\n        for i in reversed(range(size)):\n            data[i] = operator(data[2 * i], data[2 * i + 1])\n        return cls(operator, identity, data)\n\n    # ??????????????????????\n    def __init__(self, operator, identity, data):\n        self.op = operator\n        self.id = identity\n        self.data = data\n        self.size = len(data) // 2\n\n    def reduce(self, l, r):\n        l += self.size\n        r += self.size\n        vl = self.id\n        vr = self.id\n\n        while l < r:\n            if l & 1:\n                vl = self.op(vl, self.data[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                vr = self.op(self.data[r], vr)\n            l >>= 1\n            r >>= 1\n        return self.op(vl, vr)\n\n    def elements(self, l, r):\n        l += self.size\n        r += self.size\n\n        lefts = []\n        rights = []\n\n        while l < r:\n            if l & 1:\n                lefts.append(self.data[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                rights.append(self.data[r])\n            l >>= 1\n            r >>= 1\n        return lefts, rights\n\n    def __getitem__(self, i):\n        if isinstance(i, slice):\n            return self.reduce(\n                0 if i.start is None else i.start,\n                self.size if i.stop is None else i.stop)\n        elif isinstance(i, int):\n            return self.data[i + self.size]\n\n    def __setitem__(self, i, v):\n        i += self.size\n        while i:\n            self.data[i] = v\n            v = self.op(self.data[i ^ 1], v) if i & 1 else self.op(v, self.data[i ^ 1])\n            i >>= 1\n\n    def __iter__(self):\n        return iter(self.data[self.size:])\n\n\nclass LazySegmentTree:\n    """\n    op: ????????reduce?????????\n    apply: ??????\n    comp: ??????\n    \n    range_query: reduce(op, (apply(x,m) for x,m in zip(X,M)))\n    \n    ???????:\n    \n    ??X (??)\n    op[+]: X,X -> X\n    (X, op)?????\n    \n    ??M (???)\n    comp[*]: M,M -> M\n    (M, compose)?????\n    \n    apply[f(x,m,n)]: X,M,Z+ -> X\n    (Z+????)\n    \n    f(x,e_M,n) = x\n    f(x,m*n,p) = f(f(x,m,p),n,p)\n    f(x,m,p)+f(y,m,q) = f(x+y,m,p+q)\n    \n    ??: https://algo-logic.info/segment-tree/#toc_id_3\n    """\n\n    @classmethod\n    def all_identity(cls, op, op_e, comp, comp_e, apply, size):\n        size = 1 << (size - 1).bit_length()\n        return cls(\n            op,\n            op_e,\n            comp,\n            comp_e,\n            apply,\n            [op_e] * (2 * size),\n            [comp_e] * size\n        )\n\n    @classmethod\n    def from_initial_data(cls, op, op_e, comp, comp_e, apply, data):\n        size = 1 << (len(data) - 1).bit_length()\n        temp = [op_e] * (2 * size)\n        temp[size:size + len(data)] = data\n\n        for i in reversed(range(size)):\n            temp[i] = op(temp[2 * i], temp[2 * i + 1])\n        return cls(\n            op,\n            op_e,\n            comp,\n            comp_e,\n            apply,\n            temp,\n            [comp_e] * size\n        )\n\n    # ??????????????????????\n    def __init__(self, op, op_e, comp, comp_e, apply, data, lazy):\n        self.op = op\n        self.op_e = op_e\n        self.comp = comp\n        self.comp_e = comp_e\n        self.apply = apply\n        self.data = data\n        self.lazy = lazy\n        self.size = len(self.data) // 2\n        self.depth = self.size.bit_length() - 1\n        self._l_indices = [0] * self.depth\n        self._r_indices = [0] * self.depth\n\n    def _update_indices(self, i, l):\n        m = i // (i & -i)\n        i >>= 1\n        for k in range(self.depth):\n            l[k] = i if i < m else 0\n            i >>= 1\n\n    def _propagate_top_down(self):\n        data = self.data\n        lazy = self.lazy\n        apply = self.apply\n        comp = self.comp\n        comp_e = self.comp_e\n        k = self.size >> 1\n\n        for i, j in zip(reversed(self._l_indices), reversed(self._r_indices)):\n            if i > 0:\n                temp = lazy[i]\n                if temp != comp_e:\n                    lazy[i] = comp_e\n                    a = i << 1\n                    b = a | 1\n                    data[a] = apply(data[a], temp, k)\n                    data[b] = apply(data[b], temp, k)\n                    if k > 1:\n                        lazy[a] = comp(lazy[a], temp)\n                        lazy[b] = comp(lazy[b], temp)\n            if i < j:\n                temp = lazy[j]\n                if temp != comp_e:\n                    lazy[j] = comp_e\n                    a = j << 1\n                    b = a | 1\n                    data[a] = apply(data[a], temp, k)\n                    data[b] = apply(data[b], temp, k)\n                    if k > 1:\n                        lazy[a] = comp(lazy[a], temp)\n                        lazy[b] = comp(lazy[b], temp)\n            k >>= 1\n\n    def _propagate_bottom_up(self):\n        data = self.data\n        op = self.op\n        for i, j in zip(self._l_indices, self._r_indices):\n            if i < j:\n                data[j] = op(data[j << 1], data[j << 1 | 1])\n            if i > 0:\n                data[i] = op(data[i << 1], data[i << 1 | 1])\n\n    def update_interval(self, l, r, m):\n        lazy = self.lazy\n        data = self.data\n        comp = self.comp\n        apply = self.apply\n\n        l += self.size\n        r += self.size\n        self._update_indices(l, self._l_indices)\n        self._update_indices(r, self._r_indices)\n        self._propagate_top_down()\n        k = 1\n        while l < r:\n            if l & 1:\n                data[l] = apply(data[l], m, k)\n                if k > 1:\n                    lazy[l] = comp(lazy[l], m)\n                l += 1\n            if r & 1:\n                r -= 1\n                data[r] = apply(data[r], m, k)\n                if k > 1:\n                    lazy[r] = comp(lazy[r], m)\n            l >>= 1\n            r >>= 1\n            k <<= 1\n        self._propagate_bottom_up()\n\n    def get_interval(self, l, r):\n        data = self.data\n        op = self.op\n\n        l += self.size\n        r += self.size\n        self._update_indices(l, self._l_indices)\n        self._update_indices(r, self._r_indices)\n        self._propagate_top_down()\n\n        lx = self.op_e\n        rx = self.op_e\n        while l < r:\n            if l & 1:\n                lx = op(lx, data[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                rx = op(data[r], rx)\n            l >>= 1\n            r >>= 1\n        return op(lx, rx)\n\n\nfrom operator import add, sub\n\n\nclass BinaryIndexedTree:\n    def __init__(self, size, zero=0, operator=add, inv_operator=sub):\n        self.zero = zero\n        self.op = operator\n        self.inv = inv_operator\n        self.data = [zero] * (size + 1)\n        self.msb = 1 << (size.bit_length() - 1)\n\n    def _add(self, i, w):\n        i += 1\n        while i < len(self.data):\n            self.data[i] = self.op(self.data[i], w)\n            i += i & -i\n\n    def _get_sum(self, i):\n        res = self.zero\n        while i > 0:\n            res = self.op(res, self.data[i])\n            i -= i & -i\n        return res\n\n    def __getitem__(self, i):\n        """\n        [0,i)\n        """\n        if isinstance(i, slice):\n            a = self._get_sum(len(self.data) - 1 if i.stop is None else i.stop)\n            b = self._get_sum(0 if i.start is None else i.start)\n            return self.inv(a, b)\n        else:\n            return self.zero  # fake value\n\n    __setitem__ = _add\n\n    def bisect_left(self, v):\n        """\n        return smallest i s.t v <= sum[:i+1]\n        """\n        i = 0\n        k = self.msb\n        l = len(self.data)\n        while k > 0:\n            i += k\n            if i < l and self.data[i] < v:\n                v -= self.data[i]\n            else:\n                i -= k\n            k >>= 1\n        return i\n\n    def bisect_right(self, v):\n        """\n        return smallest i s.t v < sum[:i+1]\n        """\n        i = 0\n        k = self.msb\n        l = len(self.data)\n        while k > 0:\n            i += k\n            if i < l and self.data[i] <= v:\n                v -= self.data[i]\n            else:\n                i -= k\n            k >>= 1\n        return i\n\n    bisect = bisect_right\n\n\nimport bisect\nT = TypeVar(\'T\')\n\n\nclass SortedList(MutableSet):\n\n    def __init__(self, sorted_values: List[T]):\n        self.i2v = sorted_values\n        self.v2i = {v:i for i,v in enumerate(self.i2v)}\n        self.fen = BinaryIndexedTree(len(self.i2v))\n        self.n = 0\n\n    def rank(self, x:T) -> int:\n        \'\'\'\n        x???????????\n\n        :param x: ??????\n        :return: x????????\n        \'\'\'\n        return self.fen[:bisect.bisect_left(self.i2v, x)]\n\n    def get(self, rank: int) -> T:\n        return self.i2v[self.fen.bisect_left(rank)]\n\n    def lower_bound(self, x: T, k: int = 1) -> T:\n        \'\'\'\n        x???k????????????O(log N)\n\n        :param x: ??????\n        :param k: ?????????????????1?\n        :return: x???k????????\n        \'\'\'\n        t = self.fen[:bisect.bisect(self.i2v, x)]-k\n        if t < 0 or t >= self.n:\n            raise IndexError\n        return self.fen.bisect_left(t)\n\n    def upper_bound(self, x: T, k: int = 1) -> T:\n        \'\'\'\n        x???k????????????O(log N)\n\n        :param x: ??????\n        :param k: ?????????????????1?\n        :return: x???k????????\n        \'\'\'\n        t = self.fen[:bisect(self.i2v, x)-1]+k\n        if t < 0 or t >= self.n:\n            raise IndexError\n        return self.fen.bisect_left(t)\n\n    def add(self, value: T) -> None:\n        pass\n\n    def discard(self, value: T) -> None:\n        pass\n\n    def __contains__(self, x: Any) -> bool:\n        pass\n\n    def __len__(self) -> int:\n        pass\n\n    def __iter__(self) -> Iterator[T]:\n        pass\n\n\n\nclass SlidingWindowAggregator:\n    # ????????\n    def __init__(self, op, identity):\n        self.op = op\n        self.identity = identity\n        self.data = []\n        self.front = [identity]\n        self.back = [identity]\n\n    def __len__(self):\n        return len(self.front) + len(self.back) - 2\n\n    def push(self, x):\n        self.data.append(x)\n        self.back.append(self.op(self.back[-1], x))\n\n    def pop(self):\n        if len(self.front) == 1:\n            self.move()\n        self.front.pop()\n\n    def move(self):\n        self.back = [self.identity]\n        for x in reversed(self.data):\n            self.front.append(self.op(x, self.front[-1]))\n        self.data.clear()\n\n    def get(self):\n        return self.op(self.front[-1], self.back[-1])\n\n# bit = BinaryIndexedTree(4)\n# bit[1] += 1\n# bit[2] += 1\n# for i in range(5):\n#     print(i, bit.bisect_left(i), bit.bisect_right(i))'),
    'lib.graph': (False, 'import itertools\nimport heapq as hq\nfrom lib.misc import min2\nfrom lib.array2d import Array2d\nfrom collections import defaultdict\n\nfrom typing import *\n\nT = TypeVar(\'T\')\n\nINF = 2 ** 62\n\n\nclass BaseWeightedGraph:\n\n    def __init__(self, n_vertices: int):\n        self.n_vertices = n_vertices\n\n    def wadj(self, v: int) -> Iterable[Tuple[int, Any]]:\n        """\n        Return an iterable of vertices adjacent to v and edge weight\n        """\n        raise NotImplementedError\n\n    def adj(self, v: int) -> Iterable[int]:\n        """\n        Return an iterable of vertices adjacent to v\n        """\n        return (u for u, w in self.wadj(v))\n\n    @property\n    def wedges(self) -> Iterable[Tuple[int, int, Any]]:\n        """\n        Return an iterable of weighted edges (vertex_1, vertex_2, weight)\n        """\n        return ((v, u, w) for v in range(self.n_vertices) for u, w in self.wadj(v))\n\n    @property\n    def edges(self):\n        return ((v, u) for v in range(self.n_vertices) for u in self.adj(v))\n\n    def dist(self, s: int, t: int, inf=INF):\n        return dijkstra(self, s, t, inf)[t]\n\n    def warshall_floyd(self, inf=INF):\n        dist = Array2d.full(self.n_vertices, self.n_vertices, inf)\n        for u, v, w in self.wedges:\n            dist[u, v] = w\n        for i in range(self.n_vertices):\n            dist[i, i] = 0\n        for k in range(self.n_vertices):\n            for i in range(self.n_vertices):\n                for j in range(self.n_vertices):\n                    dist[i, j] = min2(dist[i, j], dist[i, k] + dist[k, j])\n        return dist\n\n    def to_wgraph(self) -> \'WeightedGraph\':\n        return WeightedGraph.from_directed_edges(self.n_vertices, self.wedges)\n\n    def to_reverse_wgraph(self) -> \'WeightedGraph\':\n        return WeightedGraph.from_directed_edges(self.n_vertices, ((u, v, w) for v, u, w in self.wedges))\n\n    def to_graph(self) -> \'Graph\':\n        l = [[] for _ in range(self.n_vertices)]\n        for u, v in self.edges:\n            l[u].append(v)\n        return Graph.from_lil_adj(self.n_vertices, l)\n\n    def to_reverse_graph(self) -> \'Graph\':\n        l = [[] for _ in range(self.n_vertices)]\n        for u, v in self.edges:\n            l[v].append(u)\n        return Graph.from_lil_adj(self.n_vertices, l)\n\n\nclass WeightedGraph(BaseWeightedGraph):\n\n    def __init__(self, n_vertices: int, adj: List[int], weight: List[Any], ind: List[int]):\n        super().__init__(n_vertices)\n        self._adj = adj\n        self._weight = weight\n        self._ind = ind\n\n    @classmethod\n    def from_lil_adj(cls, n_vertices: int, adj_list: Iterable[Sequence[Tuple[int, Any]]],\n                     n_edges: int) -> \'WeightedGraph\':\n        adj = [0] * n_edges\n        weight = [0] * n_edges\n        ind = [0] * (n_vertices + 1)\n        i = 0\n        for u, l in enumerate(adj_list):\n            ind[u] = i\n            for v, w in l:\n                adj[i] = v\n                weight[i] = w\n                i += 1\n        ind[n_vertices] = i\n        return cls(n_vertices, adj, weight, ind)\n\n    @classmethod\n    def from_directed_edges(cls, n_vertices: int, edges: Iterable[Tuple[int, int, int]]) -> \'WeightedGraph\':\n        temp = [[] for _ in range(n_vertices)]\n        n_edges = 0\n        for u, v, w in edges:\n            temp[u].append((v, w))\n            n_edges += 1\n        return cls.from_lil_adj(n_vertices, temp, n_edges)\n\n    @classmethod\n    def from_undirected_edges(cls, n_vertices: int, edges: Iterable[Tuple[int, int, int]]) -> \'WeightedGraph\':\n        return cls.from_directed_edges(n_vertices, itertools.chain(edges, ((u, v, w) for v, u, w in edges)))\n\n    def wadj(self, v: int) -> Iterable[Tuple[int, Any]]:\n        i, j = self._ind[v], self._ind[v + 1]\n        return ((self._adj[k], self._weight[k]) for k in range(i, j))\n\n\nclass ModifiableWeightedGraph(BaseWeightedGraph):\n\n    def __init__(self, n_vertices: int, edges: MutableMapping[Tuple[int, int], Any]):\n        super().__init__(n_vertices)\n        self._edges = edges\n        temp = [set() for _ in range(n_vertices)]\n        for u, v, w in edges:\n            temp[u].add((v, w))\n        self._adj = temp\n\n    @classmethod\n    def from_directed_edges(cls, n_vertices: int, edges: Iterable[Tuple[int, int, Any]]) -> \'ModifiableWeightedGraph\':\n        return cls(n_vertices, edges)\n\n    @classmethod\n    def from_undirected_edges(cls, n_vertices: int, edges: Iterable[Tuple[int, int, Any]]) -> \'ModifiableWeightedGraph\':\n        return cls.from_directed_edges(n_vertices, itertools.chain(edges, ((u, v, w) for v, u, w in edges)))\n\n    def wadj(self, v: int) -> Iterable[Tuple[int, Any]]:\n        return self._adj[v]\n\n    def update_edge(self, v: int, u: int, w: Any) -> None:\n        try:\n            w_old = self._edges[v, u]\n            self._edges[v, u] = w\n            self._adj[v].discard((u, w_old))\n            self._adj[v].add((u, w))\n        except KeyError:\n            self._edges[v, u] = w\n            self._adj[v].add((u, w))\n\n    def delete_edge(self, v: int, u: int) -> None:\n        try:\n            w = self._edges[v, u]\n            del self._edges[v, u]\n            self._adj[v].discard((u, w))\n        except KeyError:\n            pass\n\n\nclass BaseGraph(BaseWeightedGraph):\n\n    def adj(self, v):\n        raise NotImplementedError\n\n    def wadj(self, v):\n        return ((u, 1) for u in self.adj(v))\n\n    def dist(self, s: int, t: int, inf: Any = INF):\n        d = self.bfs(s, t)[t]\n        return inf if d == -1 else d\n\n    def furthest_vertex(self, v0):\n        """\n        Returns a vertex that is furthest away from v0, and its distance from v0\n        """\n        q = [v0]\n        visited = [0] * self.n_vertices\n        visited[v0] = 1\n        x = -1\n        rd = 0\n        for d in itertools.count():\n            if not q:\n                rd = d\n                break\n            x = q[0]\n            nq = []\n            for v in q:\n                for u in self.adj(v):\n                    if not visited[u]:\n                        visited[u] = 1\n                        nq.append(u)\n            q = nq\n        return x, rd\n\n\nclass Graph(BaseGraph):\n\n    def __init__(self, n_vertices: int, adj: List[int], ind: List[int]):\n        super().__init__(n_vertices)\n        self._adj = adj\n        self._ind = ind\n\n    @classmethod\n    def from_lil_adj(cls, n_vertices: int, adj_list: Iterable[Sequence[int]]) -> \'Graph\':\n        n_edges = sum(len(l) for l in adj_list)\n        adj = [0] * n_edges\n        ind = [0] * (n_vertices + 1)\n        i = 0\n        for u, l in enumerate(adj_list):\n            ind[u] = i\n            for v in l:\n                adj[i] = v\n                i += 1\n        ind[n_vertices] = i\n        return cls(n_vertices, adj, ind)\n\n    @classmethod\n    def from_directed_edges(cls, n_vertices: int, edges: Iterable[Tuple[int, int]]) -> \'Graph\':\n        temp = [[] for _ in range(n_vertices)]\n        for u, v in edges:\n            temp[u].append(v)\n        return cls.from_lil_adj(n_vertices, temp)\n\n    @classmethod\n    def from_undirected_edges(cls, n_vertices: int, edges: Iterable[Tuple[int, int]]) -> \'Graph\':\n        temp = [[] for _ in range(n_vertices)]\n        for u, v in edges:\n            temp[u].append(v)\n            temp[v].append(u)\n        return cls.from_lil_adj(n_vertices, temp)\n\n    def adj(self, v):\n        return self._adj[self._ind[v]: self._ind[v + 1]]\n\n\nclass ModifiableGraph(BaseGraph):\n\n    def __init__(self, n_vertices: int, adj: List[MutableSet[int]]):\n        super().__init__(n_vertices)\n        self._adj = adj\n\n    @classmethod\n    def from_directed_edges(cls, n_vertices: int, edges: Iterable[Tuple[int, int]]) -> \'ModifiableGraph\':\n        temp = [set() for _ in range(n_vertices)]\n        for u, v in edges:\n            temp[u].add(v)\n        return cls(n_vertices, temp)\n\n    @classmethod\n    def from_undirected_edges(cls, n_vertices: int, edges: Iterable[Tuple[int, int]]) -> \'ModifiableGraph\':\n        return cls.from_directed_edges(n_vertices, itertools.chain(edges, ((u, v) for v, u in edges)))\n\n    def adj(self, v: int) -> Iterable[int]:\n        return self._adj[v]\n\n    def add_edge(self, v: int, u: int) -> None:\n        self._adj[v].add(u)\n\n    def delete_edge(self, v: int, u: int) -> None:\n        self._adj[v].discard(u)\n\n\nclass FunctionalGraph(BaseGraph):\n    def __init__(self, n_vertices: int, func: List[int]):\n        super().__init__(n_vertices)\n        self.func = func\n\n    def adj(self, v: int) -> Iterable[int]:\n        yield self.func[v]\n\n    def get_doubling(self, max_length: int) -> Array2d:\n        k = max_length.bit_length()\n        dbl = Array2d.full(k, self.n_vertices, 0)\n        for v in range(self.n_vertices):\n            dbl[0, v] = self.func[v]\n        for t in range(1, k):\n            for v in range(self.n_vertices):\n                dbl[t, v] = dbl[t-1, dbl[t-1, v]]\n        return dbl\n\n    @staticmethod\n    def apply_func(v: int, k: int, dbl: Array2d) -> int:\n        assert k.bit_length() <= dbl.n\n\n        for t in range(dbl.n):\n            if k&1:\n                v = dbl[t, v]\n            k >>= 1\n        return v\n\n\nclass Grid(BaseGraph):\n    def __init__(self, grid):\n        super().__init__(grid.n * grid.m)\n        self.grid = grid\n\n    def adj(self, v):\n        if not self.grid.arr[v]:\n            return\n        i, j = divmod(v, self.grid.m)\n        if i + 1 < self.grid.n and self.grid[i + 1, j]:\n            yield v + self.grid.m\n        if 0 <= i - 1 and self.grid[i - 1, j]:\n            yield v - self.grid.m\n        if j + 1 < self.grid.m and self.grid[i, j + 1]:\n            yield v + 1\n        if 0 <= j - 1 and self.grid[i, j - 1]:\n            yield v - 1\n\n\ndef strongly_connected_components(graph: BaseWeightedGraph, rgraph: BaseWeightedGraph = None):\n    if rgraph is None:\n        rgraph = graph.to_reverse_graph()\n    n = graph.n_vertices\n    order = []\n    color = [0] * n\n    for v0 in range(n):\n        if color[v0]:\n            continue\n        color[v0] = -1\n        stack = [iter(graph.adj(v0))]\n        path = [v0]\n        while path:\n            for u in stack[-1]:\n                if color[u] == 0:\n                    color[u] = -1\n                    path.append(u)\n                    stack.append(iter(graph.adj(u)))\n                    break\n            else:\n                v = path.pop()\n                order.append(v)\n                stack.pop()\n\n    label = 0\n    for v0 in reversed(order):\n        if color[v0] >= 0:\n            continue\n        color[v0] = label\n        stack = [v0]\n        while stack:\n            v = stack.pop()\n            for u in rgraph.adj(v):\n                if color[u] < 0:\n                    color[u] = label\n                    stack.append(u)\n        label += 1\n    return label, color\n\n\ndef bfs(graph: BaseWeightedGraph, s: Union[int, Iterable[int]], t: Union[int, Iterable[int]] = -1) -> List[int]:\n    """\n    ?????????????????\n\n    :param graph: ???\n    :param s: ????\n    :param t: ????\n    :return: ?????(s??????????-1)\n    """\n    dist = [-1] * graph.n_vertices\n\n    if isinstance(s, int):\n        q = [s]\n        dist[s] = 0\n    else:\n        q = list(s)\n        for v in q:\n            dist[v] = 0\n\n    if isinstance(t, int):\n        t = [t]\n    else:\n        t = list(t)\n        if len(t) > 8:\n            t = set(t)\n\n    for d in range(1, graph.n_vertices):\n        nq = []\n        for v in q:\n            for u in graph.adj(v):\n                if dist[u] < 0:\n                    dist[u] = d\n                    nq.append(u)\n                if u in t:\n                    return dist\n        q = nq\n    return dist\n\n\ndef dijkstra(graph: BaseWeightedGraph, s: Union[int, Iterable[int]], t: Union[int, Iterable[int]] = -1,\n             inf: int = INF) -> List[int]:\n    """\n    Returns a list of distance. If starts contains more than one vertex, returns the shortest distance from any of them.\n    """\n    K = graph.n_vertices.bit_length()\n    MASK = (1 << K) - 1\n    dist = [inf] * graph.n_vertices\n\n    if isinstance(s, int):\n        q = [s]\n        dist[s] = 0\n    else:\n        q = list(s)\n        for v in q:\n            dist[v] = 0\n    if isinstance(t, int):\n        if t < 0:\n            t = []\n        else:\n            t = [t]\n    else:\n        t = set(t)\n\n    while q:\n        x = hq.heappop(q)\n        d, v = x >> K, x & MASK\n        if v in t:\n            return dist\n        if d > dist[v]:\n            continue\n        for u, w in graph.wadj(v):\n            if dist[u] > d + w:\n                dist[u] = d + w\n                hq.heappush(q, ((d + w) << K) | u)\n    return dist\n\n\ndef dijkstra_general(graph: BaseWeightedGraph, inf: T, zero: T, s: Union[int, Iterable[int]],\n                     t: Union[int, Iterable[int]] = -1) -> List[Any]:\n    """\n    Returns a list of distance. If starts contains more than one vertex, returns the shortest distance from any of them.\n    """\n    dist = [inf] * graph.n_vertices\n\n    if isinstance(s, int):\n        q = [(zero, s)]\n        dist[s] = zero\n    else:\n        q = [(zero, v) for v in s]\n        for d, v in q:\n            dist[v] = zero\n    if isinstance(t, int):\n        if t < 0:\n            t = []\n        else:\n            t = [t]\n    else:\n        t = set(t)\n\n    while q:\n        d, v = hq.heappop(q)\n        if v in t:\n            return dist\n        if d > dist[v]:\n            continue\n        for u, w in graph.wadj(v):\n            nw = d + w\n            if dist[u] > nw:\n                dist[u] = nw\n                hq.heappush(q, (nw, u))\n    return dist\n\n\ndef get_dual_graph(n_vertices: int, wedges: Iterable[Tuple[int, int, int]]) -> Tuple[\n    List[int], List[int], List[int], List[int]]:\n    """\n    ?????????????????\n\n    (u, v, cap) in E ??????????? (u, v, cap) ? (v, u, 0) ?????????????????????????\n\n    :param n_vertices: ???\n    :param wedges: ?????\n    :return: (???????, ???index?????)\n    """\n\n    cap = defaultdict(int)\n    for u, v, c in wedges:\n        cap[(u, v)] += c\n        cap[(v, u)] += 0\n    temp: List[List[Tuple[int, int]]] = [[] for _ in range(n_vertices)]\n    for (u, v), w in cap.items():\n        temp[u].append((v, w))\n\n    adj = [0] * len(cap)\n    weight = [0] * len(cap)\n    rev = [0] * len(cap)\n    ind = [0] * (n_vertices + 1)\n\n    i = 0\n    for u, l in enumerate(temp):\n        ind[u] = i\n        for v, w in l:\n            adj[i] = v\n            weight[i] = w\n            if u < v:\n                cap[(v, u)] = i\n            else:\n                j = cap[(u, v)]\n                rev[i] = j\n                rev[j] = i\n            i += 1\n    ind[n_vertices] = i\n\n    return adj, weight, ind, rev\n\n\ndef edmonds_karp(n_vertices: int, edges: Iterable[Tuple[int, int, int]], s: int, t: int):\n    """\n    ????????\n\n    ???: ``O(VE^2)``\n\n    :param n_vertices: ???\n    :param edges: (??1, ??2, ??)?Iterable\n    :param s: ??\n    :param t: ??\n    :return: (????, ?????, ?????)\n    """\n\n    adj, caps, ind, rev = get_dual_graph(n_vertices, edges)\n\n    m0 = max(caps)\n    bfs_memo = [0] * n_vertices\n    pv = [-1] * n_vertices\n    pe = [-1] * n_vertices\n    bfs_memo[s] = n_vertices + 1\n    offset = 0\n\n    def find_path():\n        nonlocal offset\n        offset += 1\n        q = [s]\n        while q:\n            nq = []\n            for v in q:\n                if v == t:\n                    return True\n                for i in range(ind[v], ind[v + 1]):\n                    if caps[i] == 0:\n                        continue\n                    u = adj[i]\n                    if bfs_memo[u] < offset:\n                        bfs_memo[u] = offset\n                        pv[u] = v\n                        pe[u] = i\n                        nq.append(u)\n            q = nq\n        return False\n\n    res = 0\n    flag = find_path()\n    while flag:\n        v = t\n        m = m0\n        while pv[v] >= 0:\n            e = pe[v]\n            m = min2(m, caps[e])\n            v = pv[v]\n        v = t\n        while pv[v] >= 0:\n            e = pe[v]\n            caps[e] -= m\n            caps[rev[e]] += m\n            v = pv[v]\n        res += m\n        flag = find_path()\n    return res, WeightedGraph(n_vertices, adj, caps, ind), rev\n\n\ndef min_st_cut(n_vertices: int, edges: Iterable[Tuple[int, int, int]], s: int, t: int):\n    """\n    ?? ``st`` ?????????\n\n    :param n_vertices: ???\n    :param edges: ?\n    :param s: ??\n    :param t: ??\n    :return: (?????, ???????(0-1??????), ?????, ?????)\n    """\n    flow, g, rev = edmonds_karp(n_vertices, edges, s, t)\n    stack = [s]\n    visited = [0] * n_vertices\n    visited[s] = 1\n    while stack:\n        v = stack.pop()\n        for u, w in g.wadj(v):\n            if w > 0 and not visited[u]:\n                stack.append(u)\n                visited[u] = 1\n    return flow, visited, g, rev\n\n\nclass MaxFlowGraph:\n    class Edge(NamedTuple):\n        src: int\n        dst: int\n        cap: int\n        flow: int\n\n    class _Edge:\n        def __init__(self, dst: int, cap: int) -> None:\n            self.dst = dst\n            self.cap = cap\n            self.rev: Optional[MaxFlowGraph._Edge] = None\n\n    def __init__(self, n: int) -> None:\n        self._n = n\n        self._g: List[List[MaxFlowGraph._Edge]] = [[] for _ in range(n)]\n        self._edges: List[MaxFlowGraph._Edge] = []\n\n    def add_edge(self, src: int, dst: int, cap: int) -> int:\n        assert 0 <= src < self._n\n        assert 0 <= dst < self._n\n        assert 0 <= cap\n        m = len(self._edges)\n        e = MaxFlowGraph._Edge(dst, cap)\n        re = MaxFlowGraph._Edge(src, 0)\n        e.rev = re\n        re.rev = e\n        self._g[src].append(e)\n        self._g[dst].append(re)\n        self._edges.append(e)\n        return m\n\n    def get_edge(self, i: int) -> Edge:\n        assert 0 <= i < len(self._edges)\n        e = self._edges[i]\n        re = cast(MaxFlowGraph._Edge, e.rev)\n        return MaxFlowGraph.Edge(\n            re.dst,\n            e.dst,\n            e.cap + re.cap,\n            re.cap\n        )\n\n    def edges(self) -> List[Edge]:\n        return [self.get_edge(i) for i in range(len(self._edges))]\n\n    def change_edge(self, i: int, new_cap: int, new_flow: int) -> None:\n        assert 0 <= i < len(self._edges)\n        assert 0 <= new_flow <= new_cap\n        e = self._edges[i]\n        e.cap = new_cap - new_flow\n        assert e.rev is not None\n        e.rev.cap = new_flow\n\n    def flow(self, s: int, t: int, flow_limit: Optional[int] = None) -> int:\n        assert 0 <= s < self._n\n        assert 0 <= t < self._n\n        assert s != t\n        if flow_limit is None:\n            flow_limit = cast(int, sum(e.cap for e in self._g[s]))\n\n        current_edge = [0] * self._n\n        level = [0] * self._n\n\n        def fill(arr: List[int], value: int) -> None:\n            for i in range(len(arr)):\n                arr[i] = value\n\n        def bfs() -> bool:\n            fill(level, self._n)\n            queue = []\n            q_front = 0\n            queue.append(s)\n            level[s] = 0\n            while q_front < len(queue):\n                v = queue[q_front]\n                q_front += 1\n                next_level = level[v] + 1\n                for e in self._g[v]:\n                    if e.cap == 0 or level[e.dst] <= next_level:\n                        continue\n                    level[e.dst] = next_level\n                    if e.dst == t:\n                        return True\n                    queue.append(e.dst)\n            return False\n\n        def dfs(lim: int) -> int:\n            stack = []\n            edge_stack: List[MaxFlowGraph._Edge] = []\n            stack.append(t)\n            while stack:\n                v = stack[-1]\n                if v == s:\n                    flow = min(lim, min(e.cap for e in edge_stack))\n                    for e in edge_stack:\n                        e.cap -= flow\n                        assert e.rev is not None\n                        e.rev.cap += flow\n                    return flow\n                next_level = level[v] - 1\n                while current_edge[v] < len(self._g[v]):\n                    e = self._g[v][current_edge[v]]\n                    re = cast(MaxFlowGraph._Edge, e.rev)\n                    if level[e.dst] != next_level or re.cap == 0:\n                        current_edge[v] += 1\n                        continue\n                    stack.append(e.dst)\n                    edge_stack.append(re)\n                    break\n                else:\n                    stack.pop()\n                    if edge_stack:\n                        edge_stack.pop()\n                    level[v] = self._n\n            return 0\n\n        flow = 0\n        while flow < flow_limit:\n            if not bfs():\n                break\n            fill(current_edge, 0)\n            while flow < flow_limit:\n                f = dfs(flow_limit - flow)\n                flow += f\n                if f == 0:\n                    break\n        return flow\n\n    def min_cut(self, s: int) -> List[bool]:\n        visited = [False] * self._n\n        stack = [s]\n        visited[s] = True\n        while stack:\n            v = stack.pop()\n            for e in self._g[v]:\n                if e.cap > 0 and not visited[e.dst]:\n                    visited[e.dst] = True\n                    stack.append(e.dst)\n        return visited\n\n\nclass MinCostFlowGraph:\n    class Edge(NamedTuple):\n        src: int\n        dst: int\n        cap: int\n        flow: int\n        cost: int\n\n    class _Edge:\n        def __init__(self, dst: int, cap: int, cost: int) -> None:\n            self.dst = dst\n            self.cap = cap\n            self.cost = cost\n            self.rev: Optional[MinCostFlowGraph._Edge] = None\n\n    def __init__(self, n: int) -> None:\n        self._n = n\n        self._g: List[List[MinCostFlowGraph._Edge]] = [[] for _ in range(n)]\n        self._edges: List[MinCostFlowGraph._Edge] = []\n\n    def add_edge(self, src: int, dst: int, cap: int, cost: int) -> int:\n        assert 0 <= src < self._n\n        assert 0 <= dst < self._n\n        assert 0 <= cap\n        m = len(self._edges)\n        e = MinCostFlowGraph._Edge(dst, cap, cost)\n        re = MinCostFlowGraph._Edge(src, 0, -cost)\n        e.rev = re\n        re.rev = e\n        self._g[src].append(e)\n        self._g[dst].append(re)\n        self._edges.append(e)\n        return m\n\n    def get_edge(self, i: int) -> Edge:\n        assert 0 <= i < len(self._edges)\n        e = self._edges[i]\n        re = cast(MinCostFlowGraph._Edge, e.rev)\n        return MinCostFlowGraph.Edge(\n            re.dst,\n            e.dst,\n            e.cap + re.cap,\n            re.cap,\n            e.cost\n        )\n\n    def edges(self) -> List[Edge]:\n        return [self.get_edge(i) for i in range(len(self._edges))]\n\n    def flow(self, s: int, t: int,\n             flow_limit: Optional[int] = None) -> Tuple[int, int]:\n        return self.slope(s, t, flow_limit)[-1]\n\n    def slope(self, s: int, t: int,\n              flow_limit: Optional[int] = None) -> List[Tuple[int, int]]:\n        assert 0 <= s < self._n\n        assert 0 <= t < self._n\n        assert s != t\n        if flow_limit is None:\n            flow_limit = cast(int, sum(e.cap for e in self._g[s]))\n\n        dual = [0] * self._n\n        prev: List[Optional[Tuple[int, MinCostFlowGraph._Edge]]] = [None] * self._n\n\n        def refine_dual() -> bool:\n            pq = [(0, s)]\n            visited = [False] * self._n\n            dist: List[Optional[int]] = [None] * self._n\n            dist[s] = 0\n            while pq:\n                dist_v, v = hq.heappop(pq)\n                if visited[v]:\n                    continue\n                visited[v] = True\n                if v == t:\n                    break\n                dual_v = dual[v]\n                for e in self._g[v]:\n                    w = e.dst\n                    if visited[w] or e.cap == 0:\n                        continue\n                    reduced_cost = e.cost - dual[w] + dual_v\n                    new_dist = dist_v + reduced_cost\n                    dist_w = dist[w]\n                    if dist_w is None or new_dist < dist_w:\n                        dist[w] = new_dist\n                        prev[w] = v, e\n                        hq.heappush(pq, (new_dist, w))\n            else:\n                return False\n            dist_t = dist[t]\n            for v in range(self._n):\n                if visited[v]:\n                    dual[v] -= cast(int, dist_t) - cast(int, dist[v])\n            return True\n\n        flow = 0\n        cost = 0\n        prev_cost_per_flow: Optional[int] = None\n        result = [(flow, cost)]\n        while flow < flow_limit:\n            if not refine_dual():\n                break\n            f = flow_limit - flow\n            v = t\n            while prev[v] is not None:\n                u, e = cast(Tuple[int, MinCostFlowGraph._Edge], prev[v])\n                f = min(f, e.cap)\n                v = u\n            v = t\n            while prev[v] is not None:\n                u, e = cast(Tuple[int, MinCostFlowGraph._Edge], prev[v])\n                e.cap -= f\n                assert e.rev is not None\n                e.rev.cap += f\n                v = u\n            c = -dual[s]\n            flow += f\n            cost += f * c\n            if c == prev_cost_per_flow:\n                result.pop()\n            result.append((flow, cost))\n            prev_cost_per_flow = c\n        return result'),
    'lib.itertools': (False, "from itertools import chain, repeat, count, islice\nfrom collections import Counter\n\n\ndef repeat_chain(values, counts):\n    return chain.from_iterable(map(repeat, values, counts))\n\n\ndef unique_combinations_from_value_counts(values, counts, r):\n    n = len(counts)\n    indices = list(islice(repeat_chain(count(), counts), r))\n    if len(indices) < r:\n        return\n    while True:\n        yield tuple(values[i] for i in indices)\n        for i, j in zip(reversed(range(r)), repeat_chain(reversed(range(n)), reversed(counts))):\n            if indices[i] != j:\n                break\n        else:\n            return\n        j = indices[i] + 1\n        for i, j in zip(range(i, r), repeat_chain(count(j), counts[j:])):\n            indices[i] = j\n\n\ndef unique_combinations(iterable, r):\n    values, counts = zip(*Counter(iterable).items())\n    return unique_combinations_from_value_counts(values, counts, r)\n\n\nclass UniqueCombinations:\n    def __init__(self, values, counts, r):\n        self.values = values\n        self.counts = counts\n        self.r = r\n\n        # dp[i][k] := # of unique combinations of length k or shorter with elements values[i:]\n        dp = [[1]*(r+1) for c in range(len(counts)+1)]\n        for i in reversed(range(len(counts))):\n            cnt = self.counts[i]\n            for k in range(1, r+1):\n                dp[i][k] = dp[i][k-1] + dp[i+1][k] - (dp[i+1][k-cnt-1] if k >= cnt+1 else 0)\n        self.dp = dp\n\n    def __getitem__(self, ind):\n        res = []\n        for i in range(len(self.counts)):\n            for k in reversed(range(1, min(self.r-len(res), self.counts[i])+1)):\n                t = self.dp[i+1][self.r - len(res) - k]-(self.dp[i+1][self.r - len(res)-k-1] if self.r - len(res) >= k+1 else 0)\n                if ind < t:\n                    res.extend(self.values[i] for _ in range(k))\n                    break\n                else:\n                    ind -= t\n        return tuple(res)\n\n    def __len__(self):\n        return self.dp[0][self.r] - self.dp[0][self.r-1]\n\n\n\nif __name__ == '__main__':\n    uc = UniqueCombinations([1,2,3], [5,3,1], 4)\n    for i in range(len(uc)):\n        print(uc[i])\n    # print(list(unique_combinations([2, 2, 2, 2, 4], 4)))\n    # print(list(unique_combinations_from_value_counts('abc', [1, 2, 3], 3)))\n"),
    'lib.matrix': (False, "from lib.array2d import Array2d\n\n\ndef get_general_matrix(zero, one):\n    class Matrix(Array2d):\n        ZERO = zero\n        ONE = one\n\n        @classmethod\n        def zeros(cls, n, m):\n            return cls.full(n, m, cls.ZERO)\n\n        @classmethod\n        def ones(cls, n, m):\n            return cls.full(n, m, cls.ONE)\n\n        def __add__(self, other):\n            if self.m != other.m or self.n != other.n:\n                raise ValueError(f'Cannot add matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            return Matrix(self.n, self.m, [x + y for x, y in zip(self.arr, other.arr)])\n\n        def __iadd__(self, other):\n            if self.m != other.m or self.n != other.n:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            for i, v in enumerate(other.arr):\n                self.arr[i] += v\n            return self\n\n        def __sub__(self, other):\n            if self.m != other.m or self.n != other.n:\n                raise ValueError(f'Cannot subtract matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            return Matrix(self.n, self.m, [x - y for x, y in zip(self.arr, other.arr)])\n\n        def __isub__(self, other):\n            if self.m != other.m or self.n != other.n:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            for i, v in enumerate(other.arr):\n                self.arr[i] -= v\n            return self\n\n        def __mul__(self, other):\n            if self.m != other.m or self.n != other.n:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            return Matrix(self.n, self.m, [x * y for x, y in zip(self.arr, other.arr)])\n\n        def __imul__(self, other):\n            if self.m != other.m or self.n != other.n:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            for i, v in enumerate(other.arr):\n                self.arr[i] *= v\n            return self\n\n        def __truediv__(self, other):\n            if self.m != other.m or self.n != other.n:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            return Matrix(self.n, self.m, [x / y for x, y in zip(self.arr, other.arr)])\n\n        def __matmul__(self, other):\n            if self.m != other.n:\n                raise ValueError(f'Cannot dot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n\n            res = self.full(self.n, other.m, self.ZERO)\n\n            for i in range(self.n):\n                for j in range(other.m):\n                    c = self.ZERO\n                    for k in range(self.m):\n                        c += self[i, k] * other[k, j]\n                    res[i, j] = c\n            return res\n\n        def __imatmul__(self, other):\n            if self.m != other.n:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            if self is other or self.m != other.m:\n                return self @ other\n\n            row = [self.ZERO] * self.m\n            for i in range(self.n):\n                t = i * self.m\n                for j in range(self.m):\n                    row[j] = self.arr[j + t]\n                for j in range(other.m):\n                    c = self.ZERO\n                    for k in range(self.m):\n                        c += row[k] * other[k, j]\n                    self[i, j] = c\n            return self\n\n        def __pow__(self, power, modulo=None):\n            if self.n != self.m:\n                raise ValueError('pow is supported only for square matrix')\n            k = self.n\n            res = Matrix.full(k, k, self.ZERO)\n            for i in range(k):\n                res[i, i] = self.ONE\n\n            m = self\n            while power > 0:\n                if power & 1:\n                    res @= m\n                m @= m\n                power >>= 1\n            return res\n\n    return Matrix\n\n\nIMatrix = get_general_matrix(0, 1)\nFMatrix = get_general_matrix(0.0, 1.0)\n\n\ndef accumulate(mat):\n    res = mat.zeros(mat.n + 1, mat.m + 1)\n    for i in range(mat.n):\n        k = mat.ZERO\n        for j in range(mat.m):\n            k += mat[i, j]\n            res[i + 1, j + 1] = k\n    for j in range(1, mat.m + 1):\n        k = mat.ZERO\n        for i in range(1, mat.n + 1):\n            k += res[i, j]\n            res[i, j] = k\n    return res\n\n\ndef accumulate_prod(mat):\n    res = mat.ones(mat.n + 1, mat.m + 1)\n    for i in range(mat.n):\n        k = mat.ONE\n        for j in range(mat.m):\n            k *= mat[i, j]\n            res[i + 1, j + 1] = k\n    for j in range(1, mat.m + 1):\n        k = mat.ONE\n        for i in range(1, mat.n):\n            k *= res[i, j]\n            res[i, j] = k\n    return res\n"),
    'lib.mincostflow': (False, 'from typing import NamedTuple, Optional, List, Tuple, cast\nfrom heapq import heappush, heappop\n\nclass MFGraph:\n    class Edge(NamedTuple):\n        src: int\n        dst: int\n        cap: int\n        flow: int\n\n    class _Edge:\n        def __init__(self, dst: int, cap: int) -> None:\n            self.dst = dst\n            self.cap = cap\n            self.rev: Optional[MFGraph._Edge] = None\n\n    def __init__(self, n: int) -> None:\n        self._n = n\n        self._g: List[List[MFGraph._Edge]] = [[] for _ in range(n)]\n        self._edges: List[MFGraph._Edge] = []\n\n    def add_edge(self, src: int, dst: int, cap: int) -> int:\n        assert 0 <= src < self._n\n        assert 0 <= dst < self._n\n        assert 0 <= cap\n        m = len(self._edges)\n        e = MFGraph._Edge(dst, cap)\n        re = MFGraph._Edge(src, 0)\n        e.rev = re\n        re.rev = e\n        self._g[src].append(e)\n        self._g[dst].append(re)\n        self._edges.append(e)\n        return m\n\n    def get_edge(self, i: int) -> Edge:\n        assert 0 <= i < len(self._edges)\n        e = self._edges[i]\n        re = cast(MFGraph._Edge, e.rev)\n        return MFGraph.Edge(\n            re.dst,\n            e.dst,\n            e.cap + re.cap,\n            re.cap\n        )\n\n    def edges(self) -> List[Edge]:\n        return [self.get_edge(i) for i in range(len(self._edges))]\n\n    def change_edge(self, i: int, new_cap: int, new_flow: int) -> None:\n        assert 0 <= i < len(self._edges)\n        assert 0 <= new_flow <= new_cap\n        e = self._edges[i]\n        e.cap = new_cap - new_flow\n        assert e.rev is not None\n        e.rev.cap = new_flow\n\n    def flow(self, s: int, t: int, flow_limit: Optional[int] = None) -> int:\n        assert 0 <= s < self._n\n        assert 0 <= t < self._n\n        assert s != t\n        if flow_limit is None:\n            flow_limit = cast(int, sum(e.cap for e in self._g[s]))\n\n        current_edge = [0] * self._n\n        level = [0] * self._n\n\n        def fill(arr: List[int], value: int) -> None:\n            for i in range(len(arr)):\n                arr[i] = value\n\n        def bfs() -> bool:\n            fill(level, self._n)\n            queue = []\n            q_front = 0\n            queue.append(s)\n            level[s] = 0\n            while q_front < len(queue):\n                v = queue[q_front]\n                q_front += 1\n                next_level = level[v] + 1\n                for e in self._g[v]:\n                    if e.cap == 0 or level[e.dst] <= next_level:\n                        continue\n                    level[e.dst] = next_level\n                    if e.dst == t:\n                        return True\n                    queue.append(e.dst)\n            return False\n\n        def dfs(lim: int) -> int:\n            stack = []\n            edge_stack: List[MFGraph._Edge] = []\n            stack.append(t)\n            while stack:\n                v = stack[-1]\n                if v == s:\n                    flow = min(lim, min(e.cap for e in edge_stack))\n                    for e in edge_stack:\n                        e.cap -= flow\n                        assert e.rev is not None\n                        e.rev.cap += flow\n                    return flow\n                next_level = level[v] - 1\n                while current_edge[v] < len(self._g[v]):\n                    e = self._g[v][current_edge[v]]\n                    re = cast(MFGraph._Edge, e.rev)\n                    if level[e.dst] != next_level or re.cap == 0:\n                        current_edge[v] += 1\n                        continue\n                    stack.append(e.dst)\n                    edge_stack.append(re)\n                    break\n                else:\n                    stack.pop()\n                    if edge_stack:\n                        edge_stack.pop()\n                    level[v] = self._n\n            return 0\n\n        flow = 0\n        while flow < flow_limit:\n            if not bfs():\n                break\n            fill(current_edge, 0)\n            while flow < flow_limit:\n                f = dfs(flow_limit - flow)\n                flow += f\n                if f == 0:\n                    break\n        return flow\n\n    def min_cut(self, s: int) -> List[bool]:\n        visited = [False] * self._n\n        stack = [s]\n        visited[s] = True\n        while stack:\n            v = stack.pop()\n            for e in self._g[v]:\n                if e.cap > 0 and not visited[e.dst]:\n                    visited[e.dst] = True\n                    stack.append(e.dst)\n        return visited\n\nclass MCFGraph:\n    class Edge(NamedTuple):\n        src: int\n        dst: int\n        cap: int\n        flow: int\n        cost: int\n\n    class _Edge:\n        def __init__(self, dst: int, cap: int, cost: int) -> None:\n            self.dst = dst\n            self.cap = cap\n            self.cost = cost\n            self.rev: Optional[MCFGraph._Edge] = None\n\n    def __init__(self, n: int) -> None:\n        self._n = n\n        self._g: List[List[MCFGraph._Edge]] = [[] for _ in range(n)]\n        self._edges: List[MCFGraph._Edge] = []\n\n    def add_edge(self, src: int, dst: int, cap: int, cost: int) -> int:\n        assert 0 <= src < self._n\n        assert 0 <= dst < self._n\n        assert 0 <= cap\n        m = len(self._edges)\n        e = MCFGraph._Edge(dst, cap, cost)\n        re = MCFGraph._Edge(src, 0, -cost)\n        e.rev = re\n        re.rev = e\n        self._g[src].append(e)\n        self._g[dst].append(re)\n        self._edges.append(e)\n        return m\n\n    def get_edge(self, i: int) -> Edge:\n        assert 0 <= i < len(self._edges)\n        e = self._edges[i]\n        re = cast(MCFGraph._Edge, e.rev)\n        return MCFGraph.Edge(\n            re.dst,\n            e.dst,\n            e.cap + re.cap,\n            re.cap,\n            e.cost\n        )\n\n    def edges(self) -> List[Edge]:\n        return [self.get_edge(i) for i in range(len(self._edges))]\n\n    def flow(self, s: int, t: int,\n             flow_limit: Optional[int] = None) -> Tuple[int, int]:\n        return self.slope(s, t, flow_limit)[-1]\n\n    def slope(self, s: int, t: int,\n              flow_limit: Optional[int] = None) -> List[Tuple[int, int]]:\n        assert 0 <= s < self._n\n        assert 0 <= t < self._n\n        assert s != t\n        if flow_limit is None:\n            flow_limit = cast(int, sum(e.cap for e in self._g[s]))\n\n        dual = [0] * self._n\n        prev: List[Optional[Tuple[int, MCFGraph._Edge]]] = [None] * self._n\n\n        def refine_dual() -> bool:\n            pq = [(0, s)]\n            visited = [False] * self._n\n            dist: List[Optional[int]] = [None] * self._n\n            dist[s] = 0\n            while pq:\n                dist_v, v = heappop(pq)\n                if visited[v]:\n                    continue\n                visited[v] = True\n                if v == t:\n                    break\n                dual_v = dual[v]\n                for e in self._g[v]:\n                    w = e.dst\n                    if visited[w] or e.cap == 0:\n                        continue\n                    reduced_cost = e.cost - dual[w] + dual_v\n                    new_dist = dist_v + reduced_cost\n                    dist_w = dist[w]\n                    if dist_w is None or new_dist < dist_w:\n                        dist[w] = new_dist\n                        prev[w] = v, e\n                        heappush(pq, (new_dist, w))\n            else:\n                return False\n            dist_t = dist[t]\n            for v in range(self._n):\n                if visited[v]:\n                    dual[v] -= cast(int, dist_t) - cast(int, dist[v])\n            return True\n\n        flow = 0\n        cost = 0\n        prev_cost_per_flow: Optional[int] = None\n        result = [(flow, cost)]\n        while flow < flow_limit:\n            if not refine_dual():\n                break\n            f = flow_limit - flow\n            v = t\n            while prev[v] is not None:\n                u, e = cast(Tuple[int, MCFGraph._Edge], prev[v])\n                f = min(f, e.cap)\n                v = u\n            v = t\n            while prev[v] is not None:\n                u, e = cast(Tuple[int, MCFGraph._Edge], prev[v])\n                e.cap -= f\n                assert e.rev is not None\n                e.rev.cap += f\n                v = u\n            c = -dual[s]\n            flow += f\n            cost += f * c\n            if c == prev_cost_per_flow:\n                result.pop()\n            result.append((flow, cost))\n            prev_cost_per_flow = c\n        return result'),
    'lib.misc': (False, 'from typing import List, Any, Callable, Sequence, Union, Tuple, TypeVar\nfrom numbers import Integral, Real\nimport sys\nfrom functools import reduce\nfrom itertools import accumulate\nfrom lib.data_structure import BinaryIndexedTree, DisjointSet\nimport bisect\nfrom lib.number_theory import modinv\nfrom collections import deque\n\nT = TypeVar(\'T\')\nM = TypeVar(\'M\')\nV = TypeVar(\'V\')\n\n\n\ndef general_bisect(ng: Integral, ok: Integral, judge: Callable[[Integral], bool]) -> Integral:\n    """\n    ???????????????????O(log L)??????\n\n    :param ng: judge(ng)==False????\n    :param ok: judge(ok)==True????\n    :param judge: ??????????\n    :return: judge(x)==True???????????\n    """\n    while abs(ng - ok) > 1:\n        m = (ng + ok) // 2\n        if judge(m):\n            ok = m\n        else:\n            ng = m\n    return ok\n\n\ndef general_bisect_float(ng: Real, ok: Real, judge: Callable[[Real], bool], tol: Real) -> Real:\n    """\n    ???????????????????O(log L)??????\n\n    :param ng: judge(ng)==False????\n    :param ok: judge(ok)==True????\n    :param judge: ??????????\n    :return: judge(x)==True???????????\n    """\n    while abs(ng - ok) > tol:\n        m = (ng + ok) / 2\n        if judge(m):\n            ok = m\n        else:\n            ng = m\n    return ok\n\n\ndef fibonacci_search(left: int, right: int, func: Union[Callable[[int], V], Sequence], inf: V = 2 ** 60) -> Tuple[\n    V, int]:\n    """\n    ??????????????????????????????O(log L)??????\n    ???(left, right)?????????\n\n    :param left: ?????????????\n    :param right: ?????????????\n    :param func: ??????\n    :param inf: func???\n    :return: (func????, ????????func???)\n    """\n    try:\n        func = func.__getitem__\n    except AttributeError:\n        pass\n    f1, f2 = 1, 1\n    while f1 + f2 < right - left:\n        f1, f2 = f1 + f2, f1\n    l = left\n    m1 = func(l + f2)\n    m2 = func(l + f1)\n    while f1 > 2:\n        f1, f2 = f2, f1 - f2\n        if m1 > m2:\n            l += f1\n            m1 = m2\n            m2 = func(l + f1) if l + f1 < right else inf\n        else:\n            m2 = m1\n            m1 = func(l + f2)\n    if m1 < m2:\n        return m1, l + 1\n    else:\n        return m2, l + 2\n\n\ndef max2(x: V, y: V) -> V:\n    return x if x > y else y\n\n\ndef min2(x: V, y: V) -> V:\n    return x if x < y else y\n\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\n\n\ndef rerooting(rooted_tree, merge, identity, finalize):\n    """\n    merge: (T,T) -> T, (T, merge)?????\n    identity: ???\n    finalize: (T, V, V) -> T\n\n    ????????dp?????\n    dp[u,v] = finalize(merge(dp[v,k] for k in adj[v] if k != u), u, v)\n    ???(u,v)?? u->v\n    """\n    N = rooted_tree.n_vertices\n    parent = rooted_tree.parent\n    children = rooted_tree.children\n    order = rooted_tree.dfs_order\n\n    # from leaf to parent\n    dp_down = [None] * N\n    for v in reversed(order):\n        dp_down[v] = finalize(reduce(merge,\n                                     (dp_down[c] for c in children[v]),\n                                     identity), parent[v], v)\n\n    # from parent to leaf\n    dp_up = [None] * N\n    dp_up[0] = identity\n    for v in order:\n        if len(children[v]) == 0:\n            continue\n        temp = (dp_up[v],) + tuple(dp_down[u] for u in children[v]) + (identity,)\n        left = accumulate(temp[:-2], merge)\n        right = tuple(accumulate(reversed(temp[2:]), merge))\n        for u, l, r in zip(children[v], left, reversed(right)):\n            dp_up[u] = finalize(merge(l, r), u, v)\n\n    res = [None] * N\n    for v, l in enumerate(children):\n        res[v] = reduce(merge,\n                        (dp_down[u] for u in children[v]),\n                        identity)\n        res[v] = merge(res[v], dp_up[v])\n    return res, dp_up, dp_down\n\n\ndef rerooting_fast(rooted_tree, merge, identity, finalize):\n    """\n    merge: (T,T) -> T, (T, merge)?????\n    identity: ???\n    finalize: (T, V, V) -> T\n\n    ????????dp?????\n    dp[u,v] = finalize(merge(dp[v,k] for k in adj[v] if k != u), u, v)\n    ???(u,v)??\n    dp[u,v]: v?????u?????????????????\n    """\n    dp1 = [identity] * rooted_tree.n_vertices\n    dp2 = [identity] * rooted_tree.n_vertices\n\n    for v in rooted_tree.post_order:\n        t = identity\n        for u in rooted_tree.children(v):\n            dp2[u] = t\n            t = merge(t, finalize(dp1[u], v, u))\n        t = identity\n        for u in reversed(rooted_tree.children(v)):\n            dp2[u] = merge(t, dp2[u])\n            t = merge(t, finalize(dp1[u], v, u))\n        dp1[v] = t\n    for v in rooted_tree.pre_order:\n        p = rooted_tree.parent(v)\n        if p >= 0:\n            dp2[v] = finalize(merge(dp2[v], dp2[p]), v, p)\n            dp1[v] = merge(dp1[v], dp2[v])\n    return dp1\n\n\ndef longest_increasing_sequence(l, inf, strict=True):\n    if not l:\n        return 0\n    dp = [inf] * len(l)\n    if strict:\n        for i, v in enumerate(l):\n            dp[bisect.bisect_left(dp, v)] = v\n    else:\n        for i, v in enumerate(l):\n            dp[bisect.bisect_right(dp, v)] = v\n\n    m = next(n for n in reversed(range(len(l))) if dp[n] < inf) + 1\n    return m\n\n\n\n\ndef check_bipartiteness(n_vertices, edges):\n    ds = DisjointSet.empty(2 * n_vertices)\n\n    for a, b in edges:\n        ds.union(a, b + n_vertices)\n        ds.union(b, a + n_vertices)\n\n    next_color = 0\n    color = [-1] * (2 * n_vertices)\n    for v in range(n_vertices):\n        ra = ds.find(v)\n        rb = ds.find(v + n_vertices)\n        if ra == rb:\n            return None\n        if color[ra] < 0:\n            color[ra] = next_color\n            color[rb] = next_color + 1\n            next_color += 2\n        color[v] = color[ra]\n        color[v + n_vertices] = color[rb]\n    return color[:n_vertices]\n\n\ndef small_range_duplicate(a: List[int]) -> Tuple[List[int], List[int]]:\n    MASK = (1 << 32) - 1\n    n = len(a)\n    left = [i - 1 for i in range(n + 1)]\n    right = [i + 1 for i in range(n + 1)]\n\n    sorted_ind = sorted((~v << 32) | i for i, v in enumerate(a))\n    t = 0\n    vi = sorted_ind[t]\n    i = vi & MASK\n    v = ~(vi >> 32)\n    while t < n:\n        j = i\n        l = left[i]\n        pi = l\n        pv = v\n        while v == pv and left[i] == pi:\n            pi = i\n            t += 1\n            if t >= n:\n                break\n            vi = sorted_ind[t]\n            i = vi & MASK\n            v = ~(vi >> 32)\n        r = right[pi]\n        right[l] = r\n        while j <= pi:\n            nj = right[j]\n            left[j] = l\n            right[j] = r\n            j = nj\n        left[r] = l\n\n    return left, right\n\n\ndef small_range(a: List[int]) -> Tuple[List[int], List[int]]:\n    N = len(a)\n    MASK = (1 << 32) - 1\n    left = [i - 1 for i in range(N + 1)]\n    right = [i + 1 for i in range(N + 1)]\n    sorted_ind = sorted((~v << 32) | i for i, v in enumerate(a))\n    for v in sorted_ind:\n        i = v & MASK\n        left[right[-i]] = left[-i]\n        right[left[-i]] = right[-i]\n\n    return left, right\n\n\ndef popcnt32(n: int) -> int:\n    n = n - ((n >> 1) & 0x55555555)\n    n = (n & 0x33333333) + ((n >> 2) & 0x33333333)\n    return ((((n + (n >> 4)) & 0x0f0f0f0f) * 0x01010101) >> 24) & 0xff\n\n\ndef popcnt64(n: int) -> int:\n    n = n - ((n >> 1) & 0x5555555555555555)\n    n = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333)\n    n = (n + (n >> 4)) & 0x0f0f0f0f0f0f0f0f\n    return ((((n + (n >> 32)) & 0xffffffff) * 0x01010101) >> 24) & 0xff\n\n\ndef popcnt(n: int) -> int:\n    if n < 1 << 32:\n        return popcnt32(n)\n    elif n < 1 << 64:\n        return popcnt64(n)\n    else:\n        return sum(c == \'1\' for c in bin(n))\n\n\ndef reverse_bits32(x: int):\n    x = ((x & 0x55555555) << 1) | ((x & 0xAAAAAAAA) >> 1)\n    x = ((x & 0x33333333) << 2) | ((x & 0xCCCCCCCC) >> 2)\n    x = ((x & 0x0F0F0F0F) << 4) | ((x & 0xF0F0F0F0) >> 4)\n    x = ((x & 0x00FF00FF) << 8) | ((x & 0xFF00FF00) >> 8)\n    return ((x & 0x0000FFFF) << 16) | ((x & 0xFFFF0000) >> 16)\n\n\ndef count_inversions(l: List[Any]) -> int:\n    """\n    ?????????in-place????????\n\n    :param l: ???\n    :return: ???\n    """\n    bit = BinaryIndexedTree(len(l))\n    res = 0\n    for i, v in enumerate(l):\n        bit[v] += 1\n        res += bit[v + 1:]\n    return res\n\n\ndef construct_xor_basis(iterable):\n    """\n    iterable??xor????????\n\n    :param iterable: ?????????????\n    :return: ?????int????\n    """\n    basis = []\n    for e in iterable:\n        for b in basis:\n            e = min2(e, e ^ b)\n        if e > 0:\n            basis.append(e)\n    return basis\n\n\ndef check_xor_span(basis, x):\n    """\n    x?basis???F2???????????????????\n    basis????????????????????????\n\n    :param basis: ??\n    :param x: ?????\n    :return: 0???????????????????????????????????\n    """\n    for b in basis:\n        x = min2(x, x ^ b)\n    return x\n\n\ndef get_rolling_hash(mods, bases):\n    ib = [modinv(b, m) for b, m in zip(bases, mods)]\n    k = len(mods)\n\n    class RollingHash:\n        """\n        RollingHash object represents a hash of a sequence.\n        O(1) to append/remove element from both front/end.\n\n        """\n        def __init__(self, hash, pb, l):\n            self.hash = hash\n            self.pb = pb\n            self.l = l\n\n        @classmethod\n        def empty(cls):\n            return cls([0]*k, [1]*k, 0)\n\n        def _append_d(self, v):\n            v += 1\n            for i in range(k):\n                self.hash[i] += v * self.pb[i]\n                self.hash[i] %= mods[i]\n                self.pb[i] = (self.pb[i]*bases[i]) % mods[i]\n            self.l += 1\n\n        def _appendleft_d(self, v):\n            v += 1\n            for i in range(k):\n                self.hash[i] *= bases[i]\n                self.hash[i] += v\n                self.hash[i] %= mods[i]\n                self.pb[i] = (self.pb[i]*bases[i]) % mods[i]\n            self.l += 1\n\n        def _pop_d(self, v):\n            v += 1\n            for i in range(k):\n                self.pb[i] = (self.pb[i]*ib[i]) % mods[i]\n                self.hash[i] -= v * self.pb[i]\n                self.hash[i] %= mods[i]\n            self.l -= 1\n\n        def _popleft_d(self, v):\n            v += 1\n            for i in range(k):\n                self.pb[i] = (self.pb[i]*ib[i]) % mods[i]\n                self.hash[i] -= v\n                self.hash[i] *= ib[i]\n                self.hash[i] %= mods[i]\n            self.l -= 1\n\n        def append(self, v):\n            h = self.copy()\n            h._append_d(v)\n            return h\n\n        def appendleft(self, v):\n            h = self.copy()\n            h._appendleft_d(v)\n            return h\n\n        def pop(self, v):\n            h = self.copy()\n            h._pop_d(v)\n            return h\n\n        def popleft(self, v):\n            h = self.copy()\n            h._popleft_d(v)\n            return h\n\n        def __hash__(self):\n            return hash(tuple(self.hash))\n\n        def copy(self):\n            return RollingHash(self.hash[:], self.pb[:], self.l)\n        __copy__ = copy\n\n    return RollingHash\n\n\ndef sliding_max(l, width):\n    res = [0]*(len(l)-width+1)\n    q = deque(maxlen=width+1)\n\n    for i, v in enumerate(l):\n        while q and l[q[0]] <= v:\n            q.popleft()\n        q.appendleft(i)\n        while q[-1]+width <= i:\n            q.pop()\n        res[i-width+1] = l[q[-1]]\n    return res\n\n'),
    'lib.modint': (False, "from importlib.util import find_spec, module_from_spec\n\nmodints = {}\n\n\ndef get_modint(mod):\n    try:\n        return modints[mod]\n    except KeyError:\n        spec = find_spec('lib._modint')\n        module = module_from_spec(spec)\n        module.__dict__['MOD'] = mod\n        spec.loader.exec_module(module)\n        modints[mod] = module.ModInt\n        return modints[mod]"),
    'lib.number_theory': (False, 'from collections import Counter, defaultdict\nfrom math import sqrt, ceil, gcd\nfrom itertools import count\nfrom typing import *\n\n\ndef sign(x):\n    return int(x > 0) - int(x < 0)\n\n\ndef egcd(a: int, b: int) -> Tuple[int, int, int]:\n    """\n    ?????????\n\n    :param a: ??\n    :param b: ??\n    :return: (x, y, gcd(a,b)). x, y?ax+by=gcd(a,b)????\n    """\n    s, ps, r, pr = 0, 1, b, a\n    while r != 0:\n        q = pr // r\n        pr, r = r, pr - q * r\n        ps, s = s, ps - q * s\n    t = (pr - ps * a) // b\n    if pr > 0:\n        return ps, t, pr\n    return -ps, -t, -pr\n\n\ndef modinv(x: int, mod: int) -> int:\n    """\n    Z/(mod Z)???x???\n\n    :param x: ??\n    :param mod: ??\n    :return: x * y % mod = 1????y\n    """\n    s, ps, r, pr = 0, 1, mod, x\n    while r != 0:\n        pr, (q, r) = r, divmod(pr, r)\n        ps, s = s, ps - q * s\n    if pr == 1:\n        return ps if ps >= 0 else ps + mod\n    raise ValueError("base is not invertible for the given modulus")\n\n\ndef modpow(x, k, mod):\n    """\n    Z/(mod Z)???x?k?\n\n    :param x: ??\n    :param k: ??\n    :param mod: ??\n    :return: x ** k % mod\n    """\n    if k < 0:\n        x = modinv(x, mod)\n        k = -k\n    r = 1\n    while k != 0:\n        if k & 1:\n            r = (r * x) % mod\n        x = (x * x) % mod\n        k >>= 1\n    return r\n\n\n# ?????\ndef prime_factors(n):\n    """\n    n??????????\n\n    :param n: ???\n    :return: n????????????????generator\n    """\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            yield i\n    if n > 1:\n        yield n\n\n\ndef int_product(iterable):\n    x = 1\n    for y in iterable:\n        x *= y\n    return x\n\n\n# ?????O(sqrt(n))????\ndef divisors(n):\n    for i in range(1, ceil(sqrt(n)) + 1):\n        j, r = divmod(n, i)\n        if not r:\n            yield i\n            if i != j:\n                yield j\n\n\n# ?????\ndef generate_primes():\n    d = defaultdict(list)\n\n    for q in count(2):\n        if q in d:\n            for p in d[q]:\n                d[p + q].append(p)\n            del d[q]\n        else:\n            yield q\n            d[q * q].append(q)\n\n\ndef totient_factors(n):\n    def it():\n        prev = -1\n        for p in prime_factors(n):\n            if p == prev:\n                yield p\n            else:\n                prev = p\n                for q in prime_factors(p - 1):\n                    yield q\n    return it()\n\n\ndef primitive_root(mod, phi_factors=None):\n    if phi_factors is None:\n        phi_factors = tuple(totient_factors(mod))\n    phi = int_product(phi_factors)\n    primes = set(phi_factors)\n    for i in range(2, mod):\n        for p in primes:\n            if modpow(i, (phi // p), mod) == 1:\n                break\n        else:\n            return i\n    else:\n        raise ValueError(f\'There is no primitive root for modulo {mod}\')\n\n\ndef lcm(nums: Iterable[int]) -> int:\n    m = 1\n    for n in nums:\n        m *= n // gcd(m, n)\n    return m\n\n\ndef chinese_remainder_theorem(reminders: List[int], mods: List[int], mods_lcm: int=-1) -> Tuple[int, int]:\n    """\n    returns x and lcm(reminders) s.t.\n    all(x%m == r for r,m in zip(reminders,mods))\n    """\n    s = 0\n    if mods_lcm < 0:\n        mods_lcm = lcm(mods)\n    for m, r in zip(mods, reminders):\n        p = mods_lcm // m\n        s += r * p * modinv(p, m)\n        s %= mods_lcm\n    return s, mods_lcm\n\n\ndef factorials_with_inv(k, mod):\n    """\n    0! ... k! ?????mod????????\n    """\n    fac = [1] * (k + 1)\n    inv = [1] * (k + 1)\n    t = 1\n    for i in range(1, k + 1):\n        t = (t * i) % mod\n        fac[i] = t\n    t = modinv(t, mod)\n    for i in reversed(range(1, k + 1)):\n        inv[i] = t\n        t = (t * i) % mod\n    return fac, inv\n\n\ndef extended_lucas_theorem(mod):\n    """\n    Returns a function (n,m) -> C(n,m)%mod\n    """\n    factors = tuple((p, q, p ** q) for p, q in Counter(prime_factors(mod)).items())\n    facs = [[0] * k for p, q, k in factors]\n    invs = [[0] * k for p, q, k in factors]\n    for (p, q, k), fac, inv in zip(factors, facs, invs):\n        t = 1\n        for n in range(k):\n            if n % p != 0:\n                t *= n\n                t %= k\n            fac[n] = t\n        t = modinv(t, k)\n        for n in reversed(range(k)):\n            inv[n] = t\n            if n % p != 0:\n                t *= n\n                t %= k\n\n    def helper(n, m):\n        l = n - m\n        if l < 0:\n            return 0\n\n        def reminders():\n            for (p, q, k), fac, inv in zip(factors, facs, invs):\n                a, b, c, e0, eq, i, r = n, m, l, 0, -2, 1, 1\n                while a > 0:\n                    r *= fac[a % k] * inv[b % k] * inv[c % k]\n                    r %= k\n                    a, b, c = a // p, b // p, c // p\n                    if i == q:\n                        eq = e0\n                    e0 += a - b - c\n                    i += 1\n                if eq >= 0:\n                    eq += e0\n                if e0 >= q:\n                    r = 0\n                else:\n                    r *= p ** e0\n                    r %= k\n                    if not (p == 2 and q >= 3) and (eq % 2 == 1):\n                        r = -r\n                yield r\n\n        return chinese_remainder_theorem(reminders(), (m for _, _, m in factors), mod)[0]\n\n    return helper\n\n\ndef lucas_theorem(m, n, mod, comb):\n    cnt = 1\n    while n > 0:\n        m, mr = divmod(m, mod)\n        n, nr = divmod(n, mod)\n        if mr < nr:\n            return 0\n        cnt *= comb(mr, nr)\n        cnt %= mod\n    return cnt\n\n\n# C(n,m) is even iff (~n&m)\n\ndef floor_linear_sum(n, m, a, b):\n    """\n    returns sum((a*i+b)//m for i in range(n))\n    """\n    if b < 0:\n        t = (-b - 1) // m + 1\n        b += m * t\n        res = -t * n\n    else:\n        res = 0\n    while True:\n        if a >= m:\n            res += (n - 1) * n * (a // m) // 2\n            a %= m\n        if b >= m:\n            res += n * (b // m)\n            b %= m\n\n        y_max = (a * n + b) // m\n        if y_max == 0:\n            return res\n        nx_max = b - y_max * m\n        res += (n + nx_max // a) * y_max\n        n, m, a, b = y_max, a, m, nx_max % a\n\ndef get_sieve(n):\n    sieve = [0]*(n+1)\n    for i in range(2, len(sieve)):\n        if sieve[i] > 0:\n            continue\n        sieve[i] = i\n        for j in range(i*2, len(sieve), i):\n            if sieve[j] == 0:\n                sieve[j] = i\n    return sieve\n\n\ndef divisors_from_sieve(n, sieve):\n    res = [1]\n    while n > 1:\n        k = sieve[n]\n        n //= k\n        l = len(res)\n        t = k\n        res.extend(res[i]*t for i in range(l))\n        while n > 1 and sieve[n] == k:\n            t *= k\n            res.extend(res[i]*t for i in range(l))\n            n //= k\n    return res\n\n\ndef factorize_from_sieve(n, sieve):\n    while n > 1:\n        yield sieve[n]\n        n //= sieve[n]\n\n\ndef discrete_log(x: int, y: int, m: int) -> int:\n    """\n    x**k == y mod m ?????????k????\n\n    :param x: ???????\n    :param y: ??????????\n    :param m: mod\n    :return: ?????\n    """\n\n    x = int(x)\n    y = int(y)\n    m = int(m)\n    if y >= m or y < 0:\n        return -1\n    if x == 0:\n        if m == 1:\n            return 0\n        if y == 1:\n            return 0\n        if y == 0:\n            return 1\n        return -1\n    p = 3\n    tmp = x - 1\n    cnt = 0\n    primes = []\n    counts = []\n    ps = 0\n    while tmp & 1:\n        tmp >>= 1\n        cnt += 1\n    if cnt:\n        primes.append(2)\n        counts.append(cnt)\n        ps += 1\n    tmp += 1\n    while tmp != 1:\n        cnt = 0\n        while tmp % p == 0:\n            tmp //= p\n            cnt += 1\n        if cnt:\n            primes.append(p)\n            counts.append(cnt)\n            ps += 1\n        p += 2\n        if tmp != 1 and p * p > x:\n            primes.append(tmp)\n            counts.append(1)\n            ps += 1\n            break\n    tail = 0\n    mp = m\n    for i in range(ps):\n        f = 0\n        while mp % primes[i] == 0:\n            mp //= primes[i]\n            f += 1\n        if tail < (f + counts[i] - 1) // counts[i]:\n            tail = (f + counts[i] - 1) // counts[i]\n    z = 1\n    for i in range(tail):\n        if z == y:\n            return i\n        z = z * x % m\n    if y % gcd(z, m):\n        return -1\n    p = 3\n    u = mp\n    tmp = mp - 1\n    if tmp & 1:\n        u >>= 1\n        while tmp & 1:\n            tmp >>= 1\n    tmp += 1\n    while tmp != 1:\n        if tmp % p == 0:\n            u //= p\n            u *= p - 1\n            while tmp % p == 0:\n                tmp //= p\n        p += 2\n        if tmp != 1 and p * p > mp:\n            u //= tmp\n            u *= tmp - 1\n            break\n    p = 1\n    loop = u\n    while p * p <= u:\n        if u % p == 0:\n            if z * modpow(x, p, m) % m == z:\n                loop = p\n                break\n            ip = u // p\n            if z * modpow(x, ip, m) % m == z:\n                loop = ip\n        p += 1\n    l, r = 0, loop+1\n    sq = (loop+1) >> 1\n    while r - l > 1:\n        if sq * sq <= loop:\n            l = sq\n        else:\n            r = sq\n        sq = (l + r) >> 1\n    if sq * sq < loop:\n        sq += 1\n    b = modpow(modpow(x, loop-1, m), sq, m)\n    d = {}\n    f = z\n    for i in range(sq):\n        d[f] = i\n        f = f * x % m\n    g = y\n    for i in range(sq):\n        if g in d:\n            return i*sq+d[g]+tail\n        g = g * b % m\n    return -1\n\n'),
    'lib.online_sorted_list': (False, 'import sys\nimport traceback\n\nfrom bisect import bisect_left, bisect_right, insort\nfrom itertools import chain, repeat, starmap\nfrom math import log\nfrom operator import add, eq, ne, gt, ge, lt, le, iadd\nfrom textwrap import dedent\n\ntry:\n    from collections.abc import Sequence, MutableSequence\nexcept ImportError:\n    from collections import Sequence, MutableSequence\n\nfrom functools import wraps\nfrom sys import hexversion\n\nif hexversion < 0x03000000:\n    try:\n        from thread import get_ident\n    except ImportError:\n        from dummy_thread import get_ident\nelse:\n    from functools import reduce\n\n    try:\n        from _thread import get_ident\n    except ImportError:\n        from _dummy_thread import get_ident\n\n\ndef recursive_repr(fillvalue=\'...\'):\n    "Decorator to make a repr function return fillvalue for a recursive call."\n\n    # pylint: disable=missing-docstring\n    # Copied from reprlib in Python 3\n    # https://hg.python.org/cpython/file/3.6/Lib/reprlib.py\n\n    def decorating_function(user_function):\n        repr_running = set()\n\n        @wraps(user_function)\n        def wrapper(self):\n            key = id(self), get_ident()\n            if key in repr_running:\n                return fillvalue\n            repr_running.add(key)\n            try:\n                result = user_function(self)\n            finally:\n                repr_running.discard(key)\n            return result\n\n        return wrapper\n\n    return decorating_function\n\n\nclass OnlineSortedList(MutableSequence):\n    """Sorted list is a sorted mutable sequence.\n\n    Sorted list values are maintained in sorted order.\n\n    Sorted list values must be comparable. The total ordering of values must\n    not change while they are stored in the sorted list.\n\n    Methods for adding values:\n\n    * :func:`SortedList.add`\n    * :func:`SortedList.update`\n    * :func:`SortedList.__add__`\n    * :func:`SortedList.__iadd__`\n    * :func:`SortedList.__mul__`\n    * :func:`SortedList.__imul__`\n\n    Methods for removing values:\n\n    * :func:`SortedList.clear`\n    * :func:`SortedList.discard`\n    * :func:`SortedList.remove`\n    * :func:`SortedList.pop`\n    * :func:`SortedList.__delitem__`\n\n    Methods for looking up values:\n\n    * :func:`SortedList.bisect_left`\n    * :func:`SortedList.bisect_right`\n    * :func:`SortedList.count`\n    * :func:`SortedList.index`\n    * :func:`SortedList.__contains__`\n    * :func:`SortedList.__getitem__`\n\n    Methods for iterating values:\n\n    * :func:`SortedList.irange`\n    * :func:`SortedList.islice`\n    * :func:`SortedList.__iter__`\n    * :func:`SortedList.__reversed__`\n\n    Methods for miscellany:\n\n    * :func:`SortedList.copy`\n    * :func:`SortedList.__len__`\n    * :func:`SortedList.__repr__`\n    * :func:`SortedList._check`\n    * :func:`SortedList._reset`\n\n    Sorted lists use lexicographical ordering semantics when compared to other\n    sequences.\n\n    Some methods of mutable sequences are not supported and will raise\n    not-implemented error.\n\n    """\n    DEFAULT_LOAD_FACTOR = 1000\n\n    def __init__(self, iterable=None, key=None):\n        """Initialize sorted list instance.\n\n        Optional `iterable` argument provides an initial iterable of values to\n        initialize the sorted list.\n\n        Runtime complexity: `O(n*log(n))`\n\n        >>> sl = SortedList()\n        >>> sl\n        SortedList([])\n        >>> sl = SortedList([3, 1, 2, 5, 4])\n        >>> sl\n        SortedList([1, 2, 3, 4, 5])\n\n        :param iterable: initial values (optional)\n\n        """\n        assert key is None\n        self._len = 0\n        self._load = self.DEFAULT_LOAD_FACTOR\n        self._lists = []\n        self._maxes = []\n        self._index = []\n        self._offset = 0\n\n        if iterable is not None:\n            self._update(iterable)\n\n    def __new__(cls, iterable=None, key=None):\n        """Create new sorted list or sorted-key list instance.\n\n        Optional `key`-function argument will return an instance of subtype\n        :class:`SortedKeyList`.\n\n        >>> sl = SortedList()\n        >>> isinstance(sl, SortedList)\n        True\n        >>> sl = SortedList(key=lambda x: -x)\n        >>> isinstance(sl, SortedList)\n        True\n        >>> isinstance(sl, SortedKeyList)\n        True\n\n        :param iterable: initial values (optional)\n        :param key: function used to extract comparison key (optional)\n        :return: sorted list or sorted-key list instance\n\n        """\n        # pylint: disable=unused-argument\n        if key is None:\n            return object.__new__(cls)\n        else:\n            if cls is SortedList:\n                return object.__new__(SortedKeyList)\n            else:\n                raise TypeError(\'inherit SortedKeyList for key argument\')\n\n    @property\n    def key(self):  # pylint: disable=useless-return\n        """Function used to extract comparison key from values.\n\n        Sorted list compares values directly so the key function is none.\n\n        """\n        return None\n\n    def _reset(self, load):\n        """Reset sorted list load factor.\n\n        The `load` specifies the load-factor of the list. The default load\n        factor of 1000 works well for lists from tens to tens-of-millions of\n        values. Good practice is to use a value that is the cube root of the\n        list size. With billions of elements, the best load factor depends on\n        your usage. It\'s best to leave the load factor at the default until you\n        start benchmarking.\n\n        See :doc:`implementation` and :doc:`performance-scale` for more\n        information.\n\n        Runtime complexity: `O(n)`\n\n        :param int load: load-factor for sorted list sublists\n\n        """\n        values = reduce(iadd, self._lists, [])\n        self._clear()\n        self._load = load\n        self._update(values)\n\n    def clear(self):\n        """Remove all values from sorted list.\n\n        Runtime complexity: `O(n)`\n\n        """\n        self._len = 0\n        del self._lists[:]\n        del self._maxes[:]\n        del self._index[:]\n        self._offset = 0\n\n    _clear = clear\n\n    def add(self, value):\n        """Add `value` to sorted list.\n\n        Runtime complexity: `O(log(n))` -- approximate.\n\n        >>> sl = SortedList()\n        >>> sl.add(3)\n        >>> sl.add(1)\n        >>> sl.add(2)\n        >>> sl\n        SortedList([1, 2, 3])\n\n        :param value: value to add to sorted list\n\n        """\n        _lists = self._lists\n        _maxes = self._maxes\n\n        if _maxes:\n            pos = bisect_right(_maxes, value)\n\n            if pos == len(_maxes):\n                pos -= 1\n                _lists[pos].append(value)\n                _maxes[pos] = value\n            else:\n                insort(_lists[pos], value)\n\n            self._expand(pos)\n        else:\n            _lists.append([value])\n            _maxes.append(value)\n\n        self._len += 1\n\n    def _expand(self, pos):\n        """Split sublists with length greater than double the load-factor.\n\n        Updates the index when the sublist length is less than double the load\n        level. This requires incrementing the nodes in a traversal from the\n        leaf node to the root. For an example traversal see\n        ``SortedList._loc``.\n\n        """\n        _load = self._load\n        _lists = self._lists\n        _index = self._index\n\n        if len(_lists[pos]) > (_load << 1):\n            _maxes = self._maxes\n\n            _lists_pos = _lists[pos]\n            half = _lists_pos[_load:]\n            del _lists_pos[_load:]\n            _maxes[pos] = _lists_pos[-1]\n\n            _lists.insert(pos + 1, half)\n            _maxes.insert(pos + 1, half[-1])\n\n            del _index[:]\n        else:\n            if _index:\n                child = self._offset + pos\n                while child:\n                    _index[child] += 1\n                    child = (child - 1) >> 1\n                _index[0] += 1\n\n    def update(self, iterable):\n        """Update sorted list by adding all values from `iterable`.\n\n        Runtime complexity: `O(k*log(n))` -- approximate.\n\n        >>> sl = SortedList()\n        >>> sl.update([3, 1, 2])\n        >>> sl\n        SortedList([1, 2, 3])\n\n        :param iterable: iterable of values to add\n\n        """\n        _lists = self._lists\n        _maxes = self._maxes\n        values = sorted(iterable)\n\n        if _maxes:\n            if len(values) * 4 >= self._len:\n                _lists.append(values)\n                values = reduce(iadd, _lists, [])\n                values.sort()\n                self._clear()\n            else:\n                _add = self.add\n                for val in values:\n                    _add(val)\n                return\n\n        _load = self._load\n        _lists.extend(values[pos:(pos + _load)]\n                      for pos in range(0, len(values), _load))\n        _maxes.extend(sublist[-1] for sublist in _lists)\n        self._len = len(values)\n        del self._index[:]\n\n    _update = update\n\n    def __contains__(self, value):\n        """Return true if `value` is an element of the sorted list.\n\n        ``sl.__contains__(value)`` <==> ``value in sl``\n\n        Runtime complexity: `O(log(n))`\n\n        >>> sl = SortedList([1, 2, 3, 4, 5])\n        >>> 3 in sl\n        True\n\n        :param value: search for value in sorted list\n        :return: true if `value` in sorted list\n\n        """\n        _maxes = self._maxes\n\n        if not _maxes:\n            return False\n\n        pos = bisect_left(_maxes, value)\n\n        if pos == len(_maxes):\n            return False\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n\n        return _lists[pos][idx] == value\n\n    def discard(self, value):\n        """Remove `value` from sorted list if it is a member.\n\n        If `value` is not a member, do nothing.\n\n        Runtime complexity: `O(log(n))` -- approximate.\n\n        >>> sl = SortedList([1, 2, 3, 4, 5])\n        >>> sl.discard(5)\n        >>> sl.discard(0)\n        >>> sl == [1, 2, 3, 4]\n        True\n\n        :param value: `value` to discard from sorted list\n\n        """\n        _maxes = self._maxes\n\n        if not _maxes:\n            return\n\n        pos = bisect_left(_maxes, value)\n\n        if pos == len(_maxes):\n            return\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n\n        if _lists[pos][idx] == value:\n            self._delete(pos, idx)\n\n    def remove(self, value):\n        """Remove `value` from sorted list; `value` must be a member.\n\n        If `value` is not a member, raise ValueError.\n\n        Runtime complexity: `O(log(n))` -- approximate.\n\n        >>> sl = SortedList([1, 2, 3, 4, 5])\n        >>> sl.remove(5)\n        >>> sl == [1, 2, 3, 4]\n        True\n        >>> sl.remove(0)\n        Traceback (most recent call last):\n          ...\n        ValueError: 0 not in list\n\n        :param value: `value` to remove from sorted list\n        :raises ValueError: if `value` is not in sorted list\n\n        """\n        _maxes = self._maxes\n\n        if not _maxes:\n            raise ValueError(\'{0!r} not in list\'.format(value))\n\n        pos = bisect_left(_maxes, value)\n\n        if pos == len(_maxes):\n            raise ValueError(\'{0!r} not in list\'.format(value))\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n\n        if _lists[pos][idx] == value:\n            self._delete(pos, idx)\n        else:\n            raise ValueError(\'{0!r} not in list\'.format(value))\n\n    def _delete(self, pos, idx):\n        """Delete value at the given `(pos, idx)`.\n\n        Combines lists that are less than half the load level.\n\n        Updates the index when the sublist length is more than half the load\n        level. This requires decrementing the nodes in a traversal from the\n        leaf node to the root. For an example traversal see\n        ``SortedList._loc``.\n\n        :param int pos: lists index\n        :param int idx: sublist index\n\n        """\n        _lists = self._lists\n        _maxes = self._maxes\n        _index = self._index\n\n        _lists_pos = _lists[pos]\n\n        del _lists_pos[idx]\n        self._len -= 1\n\n        len_lists_pos = len(_lists_pos)\n\n        if len_lists_pos > (self._load >> 1):\n            _maxes[pos] = _lists_pos[-1]\n\n            if _index:\n                child = self._offset + pos\n                while child > 0:\n                    _index[child] -= 1\n                    child = (child - 1) >> 1\n                _index[0] -= 1\n        elif len(_lists) > 1:\n            if not pos:\n                pos += 1\n\n            prev = pos - 1\n            _lists[prev].extend(_lists[pos])\n            _maxes[prev] = _lists[prev][-1]\n\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n\n            self._expand(prev)\n        elif len_lists_pos:\n            _maxes[pos] = _lists_pos[-1]\n        else:\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n\n    def _loc(self, pos, idx):\n        """Convert an index pair (lists index, sublist index) into a single\n        index number that corresponds to the position of the value in the\n        sorted list.\n\n        Many queries require the index be built. Details of the index are\n        described in ``SortedList._build_index``.\n\n        Indexing requires traversing the tree from a leaf node to the root. The\n        parent of each node is easily computable at ``(pos - 1) // 2``.\n\n        Left-child nodes are always at odd indices and right-child nodes are\n        always at even indices.\n\n        When traversing up from a right-child node, increment the total by the\n        left-child node.\n\n        The final index is the sum from traversal and the index in the sublist.\n\n        For example, using the index from ``SortedList._build_index``::\n\n            _index = 14 5 9 3 2 4 5\n            _offset = 3\n\n        Tree::\n\n                 14\n              5      9\n            3   2  4   5\n\n        Converting an index pair (2, 3) into a single index involves iterating\n        like so:\n\n        1. Starting at the leaf node: offset + alpha = 3 + 2 = 5. We identify\n           the node as a left-child node. At such nodes, we simply traverse to\n           the parent.\n\n        2. At node 9, position 2, we recognize the node as a right-child node\n           and accumulate the left-child in our total. Total is now 5 and we\n           traverse to the parent at position 0.\n\n        3. Iteration ends at the root.\n\n        The index is then the sum of the total and sublist index: 5 + 3 = 8.\n\n        :param int pos: lists index\n        :param int idx: sublist index\n        :return: index in sorted list\n\n        """\n        if not pos:\n            return idx\n\n        _index = self._index\n\n        if not _index:\n            self._build_index()\n\n        total = 0\n\n        # Increment pos to point in the index to len(self._lists[pos]).\n\n        pos += self._offset\n\n        # Iterate until reaching the root of the index tree at pos = 0.\n\n        while pos:\n\n            # Right-child nodes are at odd indices. At such indices\n            # account the total below the left child node.\n\n            if not pos & 1:\n                total += _index[pos - 1]\n\n            # Advance pos to the parent node.\n\n            pos = (pos - 1) >> 1\n\n        return total + idx\n\n    def _pos(self, idx):\n        """Convert an index into an index pair (lists index, sublist index)\n        that can be used to access the corresponding lists position.\n\n        Many queries require the index be built. Details of the index are\n        described in ``SortedList._build_index``.\n\n        Indexing requires traversing the tree to a leaf node. Each node has two\n        children which are easily computable. Given an index, pos, the\n        left-child is at ``pos * 2 + 1`` and the right-child is at ``pos * 2 +\n        2``.\n\n        When the index is less than the left-child, traversal moves to the\n        left sub-tree. Otherwise, the index is decremented by the left-child\n        and traversal moves to the right sub-tree.\n\n        At a child node, the indexing pair is computed from the relative\n        position of the child node as compared with the offset and the remaining\n        index.\n\n        For example, using the index from ``SortedList._build_index``::\n\n            _index = 14 5 9 3 2 4 5\n            _offset = 3\n\n        Tree::\n\n                 14\n              5      9\n            3   2  4   5\n\n        Indexing position 8 involves iterating like so:\n\n        1. Starting at the root, position 0, 8 is compared with the left-child\n           node (5) which it is greater than. When greater the index is\n           decremented and the position is updated to the right child node.\n\n        2. At node 9 with index 3, we again compare the index to the left-child\n           node with value 4. Because the index is the less than the left-child\n           node, we simply traverse to the left.\n\n        3. At node 4 with index 3, we recognize that we are at a leaf node and\n           stop iterating.\n\n        4. To compute the sublist index, we subtract the offset from the index\n           of the leaf node: 5 - 3 = 2. To compute the index in the sublist, we\n           simply use the index remaining from iteration. In this case, 3.\n\n        The final index pair from our example is (2, 3) which corresponds to\n        index 8 in the sorted list.\n\n        :param int idx: index in sorted list\n        :return: (lists index, sublist index) pair\n\n        """\n        if idx < 0:\n            last_len = len(self._lists[-1])\n\n            if (-idx) <= last_len:\n                return len(self._lists) - 1, last_len + idx\n\n            idx += self._len\n\n            if idx < 0:\n                raise IndexError(\'list index out of range\')\n        elif idx >= self._len:\n            raise IndexError(\'list index out of range\')\n\n        if idx < len(self._lists[0]):\n            return 0, idx\n\n        _index = self._index\n\n        if not _index:\n            self._build_index()\n\n        pos = 0\n        child = 1\n        len_index = len(_index)\n\n        while child < len_index:\n            index_child = _index[child]\n\n            if idx < index_child:\n                pos = child\n            else:\n                idx -= index_child\n                pos = child + 1\n\n            child = (pos << 1) + 1\n\n        return (pos - self._offset, idx)\n\n    def _build_index(self):\n        """Build a positional index for indexing the sorted list.\n\n        Indexes are represented as binary trees in a dense array notation\n        similar to a binary heap.\n\n        For example, given a lists representation storing integers::\n\n            0: [1, 2, 3]\n            1: [4, 5]\n            2: [6, 7, 8, 9]\n            3: [10, 11, 12, 13, 14]\n\n        The first transformation maps the sub-lists by their length. The\n        first row of the index is the length of the sub-lists::\n\n            0: [3, 2, 4, 5]\n\n        Each row after that is the sum of consecutive pairs of the previous\n        row::\n\n            1: [5, 9]\n            2: [14]\n\n        Finally, the index is built by concatenating these lists together::\n\n            _index = [14, 5, 9, 3, 2, 4, 5]\n\n        An offset storing the start of the first row is also stored::\n\n            _offset = 3\n\n        When built, the index can be used for efficient indexing into the list.\n        See the comment and notes on ``SortedList._pos`` for details.\n\n        """\n        row0 = list(map(len, self._lists))\n\n        if len(row0) == 1:\n            self._index[:] = row0\n            self._offset = 0\n            return\n\n        head = iter(row0)\n        tail = iter(head)\n        row1 = list(starmap(add, zip(head, tail)))\n\n        if len(row0) & 1:\n            row1.append(row0[-1])\n\n        if len(row1) == 1:\n            self._index[:] = row1 + row0\n            self._offset = 1\n            return\n\n        size = 2 ** (int(log(len(row1) - 1, 2)) + 1)\n        row1.extend(repeat(0, size - len(row1)))\n        tree = [row0, row1]\n\n        while len(tree[-1]) > 1:\n            head = iter(tree[-1])\n            tail = iter(head)\n            row = list(starmap(add, zip(head, tail)))\n            tree.append(row)\n\n        reduce(iadd, reversed(tree), self._index)\n        self._offset = size * 2 - 1\n\n    def __delitem__(self, index):\n        """Remove value at `index` from sorted list.\n\n        ``sl.__delitem__(index)`` <==> ``del sl[index]``\n\n        Supports slicing.\n\n        Runtime complexity: `O(log(n))` -- approximate.\n\n        >>> sl = SortedList(\'abcde\')\n        >>> del sl[2]\n        >>> sl\n        SortedList([\'a\', \'b\', \'d\', \'e\'])\n        >>> del sl[:2]\n        >>> sl\n        SortedList([\'d\', \'e\'])\n\n        :param index: integer or slice for indexing\n        :raises IndexError: if index out of range\n\n        """\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n\n            if step == 1 and start < stop:\n                if start == 0 and stop == self._len:\n                    return self._clear()\n                elif self._len <= 8 * (stop - start):\n                    values = self._getitem(slice(None, start))\n                    if stop < self._len:\n                        values += self._getitem(slice(stop, None))\n                    self._clear()\n                    return self._update(values)\n\n            indices = range(start, stop, step)\n\n            # Delete items from greatest index to least so\n            # that the indices remain valid throughout iteration.\n\n            if step > 0:\n                indices = reversed(indices)\n\n            _pos, _delete = self._pos, self._delete\n\n            for index in indices:\n                pos, idx = _pos(index)\n                _delete(pos, idx)\n        else:\n            pos, idx = self._pos(index)\n            self._delete(pos, idx)\n\n    def __getitem__(self, index):\n        """Lookup value at `index` in sorted list.\n\n        ``sl.__getitem__(index)`` <==> ``sl[index]``\n\n        Supports slicing.\n\n        Runtime complexity: `O(log(n))` -- approximate.\n\n        >>> sl = SortedList(\'abcde\')\n        >>> sl[1]\n        \'b\'\n        >>> sl[-1]\n        \'e\'\n        >>> sl[2:5]\n        [\'c\', \'d\', \'e\']\n\n        :param index: integer or slice for indexing\n        :return: value or list of values\n        :raises IndexError: if index out of range\n\n        """\n        _lists = self._lists\n\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n\n            if step == 1 and start < stop:\n                # Whole slice optimization: start to stop slices the whole\n                # sorted list.\n\n                if start == 0 and stop == self._len:\n                    return reduce(iadd, self._lists, [])\n\n                start_pos, start_idx = self._pos(start)\n                start_list = _lists[start_pos]\n                stop_idx = start_idx + stop - start\n\n                # Small slice optimization: start index and stop index are\n                # within the start list.\n\n                if len(start_list) >= stop_idx:\n                    return start_list[start_idx:stop_idx]\n\n                if stop == self._len:\n                    stop_pos = len(_lists) - 1\n                    stop_idx = len(_lists[stop_pos])\n                else:\n                    stop_pos, stop_idx = self._pos(stop)\n\n                prefix = _lists[start_pos][start_idx:]\n                middle = _lists[(start_pos + 1):stop_pos]\n                result = reduce(iadd, middle, prefix)\n                result += _lists[stop_pos][:stop_idx]\n\n                return result\n\n            if step == -1 and start > stop:\n                result = self._getitem(slice(stop + 1, start + 1))\n                result.reverse()\n                return result\n\n            # Return a list because a negative step could\n            # reverse the order of the items and this could\n            # be the desired behavior.\n\n            indices = range(start, stop, step)\n            return list(self._getitem(index) for index in indices)\n        else:\n            if self._len:\n                if index == 0:\n                    return _lists[0][0]\n                elif index == -1:\n                    return _lists[-1][-1]\n            else:\n                raise IndexError(\'list index out of range\')\n\n            if 0 <= index < len(_lists[0]):\n                return _lists[0][index]\n\n            len_last = len(_lists[-1])\n\n            if -len_last < index < 0:\n                return _lists[-1][len_last + index]\n\n            pos, idx = self._pos(index)\n            return _lists[pos][idx]\n\n    _getitem = __getitem__\n\n    def __setitem__(self, index, value):\n        """Raise not-implemented error.\n\n        ``sl.__setitem__(index, value)`` <==> ``sl[index] = value``\n\n        :raises NotImplementedError: use ``del sl[index]`` and\n            ``sl.add(value)`` instead\n\n        """\n        message = \'use ``del sl[index]`` and ``sl.add(value)`` instead\'\n        raise NotImplementedError(message)\n\n    def __iter__(self):\n        """Return an iterator over the sorted list.\n\n        ``sl.__iter__()`` <==> ``iter(sl)``\n\n        Iterating the sorted list while adding or deleting values may raise a\n        :exc:`RuntimeError` or fail to iterate over all values.\n\n        """\n        return chain.from_iterable(self._lists)\n\n    def __reversed__(self):\n        """Return a reverse iterator over the sorted list.\n\n        ``sl.__reversed__()`` <==> ``reversed(sl)``\n\n        Iterating the sorted list while adding or deleting values may raise a\n        :exc:`RuntimeError` or fail to iterate over all values.\n\n        """\n        return chain.from_iterable(map(reversed, reversed(self._lists)))\n\n    def reverse(self):\n        """Raise not-implemented error.\n\n        Sorted list maintains values in ascending sort order. Values may not be\n        reversed in-place.\n\n        Use ``reversed(sl)`` for an iterator over values in descending sort\n        order.\n\n        Implemented to override `MutableSequence.reverse` which provides an\n        erroneous default implementation.\n\n        :raises NotImplementedError: use ``reversed(sl)`` instead\n\n        """\n        raise NotImplementedError(\'use ``reversed(sl)`` instead\')\n\n    def islice(self, start=None, stop=None, reverse=False):\n        """Return an iterator that slices sorted list from `start` to `stop`.\n\n        The `start` and `stop` index are treated inclusive and exclusive,\n        respectively.\n\n        Both `start` and `stop` default to `None` which is automatically\n        inclusive of the beginning and end of the sorted list.\n\n        When `reverse` is `True` the values are yielded from the iterator in\n        reverse order; `reverse` defaults to `False`.\n\n        >>> sl = SortedList(\'abcdefghij\')\n        >>> it = sl.islice(2, 6)\n        >>> list(it)\n        [\'c\', \'d\', \'e\', \'f\']\n\n        :param int start: start index (inclusive)\n        :param int stop: stop index (exclusive)\n        :param bool reverse: yield values in reverse order\n        :return: iterator\n\n        """\n        _len = self._len\n\n        if not _len:\n            return iter(())\n\n        start, stop, _ = slice(start, stop).indices(self._len)\n\n        if start >= stop:\n            return iter(())\n\n        _pos = self._pos\n\n        min_pos, min_idx = _pos(start)\n\n        if stop == _len:\n            max_pos = len(self._lists) - 1\n            max_idx = len(self._lists[-1])\n        else:\n            max_pos, max_idx = _pos(stop)\n\n        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)\n\n    def _islice(self, min_pos, min_idx, max_pos, max_idx, reverse):\n        """Return an iterator that slices sorted list using two index pairs.\n\n        The index pairs are (min_pos, min_idx) and (max_pos, max_idx), the\n        first inclusive and the latter exclusive. See `_pos` for details on how\n        an index is converted to an index pair.\n\n        When `reverse` is `True`, values are yielded from the iterator in\n        reverse order.\n\n        """\n        _lists = self._lists\n\n        if min_pos > max_pos:\n            return iter(())\n\n        if min_pos == max_pos:\n            if reverse:\n                indices = reversed(range(min_idx, max_idx))\n                return map(_lists[min_pos].__getitem__, indices)\n\n            indices = range(min_idx, max_idx)\n            return map(_lists[min_pos].__getitem__, indices)\n\n        next_pos = min_pos + 1\n\n        if next_pos == max_pos:\n            if reverse:\n                min_indices = range(min_idx, len(_lists[min_pos]))\n                max_indices = range(max_idx)\n                return chain(\n                    map(_lists[max_pos].__getitem__, reversed(max_indices)),\n                    map(_lists[min_pos].__getitem__, reversed(min_indices)),\n                )\n\n            min_indices = range(min_idx, len(_lists[min_pos]))\n            max_indices = range(max_idx)\n            return chain(\n                map(_lists[min_pos].__getitem__, min_indices),\n                map(_lists[max_pos].__getitem__, max_indices),\n            )\n\n        if reverse:\n            min_indices = range(min_idx, len(_lists[min_pos]))\n            sublist_indices = range(next_pos, max_pos)\n            sublists = map(_lists.__getitem__, reversed(sublist_indices))\n            max_indices = range(max_idx)\n            return chain(\n                map(_lists[max_pos].__getitem__, reversed(max_indices)),\n                chain.from_iterable(map(reversed, sublists)),\n                map(_lists[min_pos].__getitem__, reversed(min_indices)),\n            )\n\n        min_indices = range(min_idx, len(_lists[min_pos]))\n        sublist_indices = range(next_pos, max_pos)\n        sublists = map(_lists.__getitem__, sublist_indices)\n        max_indices = range(max_idx)\n        return chain(\n            map(_lists[min_pos].__getitem__, min_indices),\n            chain.from_iterable(sublists),\n            map(_lists[max_pos].__getitem__, max_indices),\n        )\n\n    def irange(self, minimum=None, maximum=None, inclusive=(True, True),\n               reverse=False):\n        """Create an iterator of values between `minimum` and `maximum`.\n\n        Both `minimum` and `maximum` default to `None` which is automatically\n        inclusive of the beginning and end of the sorted list.\n\n        The argument `inclusive` is a pair of booleans that indicates whether\n        the minimum and maximum ought to be included in the range,\n        respectively. The default is ``(True, True)`` such that the range is\n        inclusive of both minimum and maximum.\n\n        When `reverse` is `True` the values are yielded from the iterator in\n        reverse order; `reverse` defaults to `False`.\n\n        >>> sl = SortedList(\'abcdefghij\')\n        >>> it = sl.irange(\'c\', \'f\')\n        >>> list(it)\n        [\'c\', \'d\', \'e\', \'f\']\n\n        :param minimum: minimum value to start iterating\n        :param maximum: maximum value to stop iterating\n        :param inclusive: pair of booleans\n        :param bool reverse: yield values in reverse order\n        :return: iterator\n\n        """\n        _maxes = self._maxes\n\n        if not _maxes:\n            return iter(())\n\n        _lists = self._lists\n\n        # Calculate the minimum (pos, idx) pair. By default this location\n        # will be inclusive in our calculation.\n\n        if minimum is None:\n            min_pos = 0\n            min_idx = 0\n        else:\n            if inclusive[0]:\n                min_pos = bisect_left(_maxes, minimum)\n\n                if min_pos == len(_maxes):\n                    return iter(())\n\n                min_idx = bisect_left(_lists[min_pos], minimum)\n            else:\n                min_pos = bisect_right(_maxes, minimum)\n\n                if min_pos == len(_maxes):\n                    return iter(())\n\n                min_idx = bisect_right(_lists[min_pos], minimum)\n\n        # Calculate the maximum (pos, idx) pair. By default this location\n        # will be exclusive in our calculation.\n\n        if maximum is None:\n            max_pos = len(_maxes) - 1\n            max_idx = len(_lists[max_pos])\n        else:\n            if inclusive[1]:\n                max_pos = bisect_right(_maxes, maximum)\n\n                if max_pos == len(_maxes):\n                    max_pos -= 1\n                    max_idx = len(_lists[max_pos])\n                else:\n                    max_idx = bisect_right(_lists[max_pos], maximum)\n            else:\n                max_pos = bisect_left(_maxes, maximum)\n\n                if max_pos == len(_maxes):\n                    max_pos -= 1\n                    max_idx = len(_lists[max_pos])\n                else:\n                    max_idx = bisect_left(_lists[max_pos], maximum)\n\n        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)\n\n    def __len__(self):\n        """Return the size of the sorted list.\n\n        ``sl.__len__()`` <==> ``len(sl)``\n\n        :return: size of sorted list\n\n        """\n        return self._len\n\n    def bisect_left(self, value):\n        """Return an index to insert `value` in the sorted list.\n\n        If the `value` is already present, the insertion point will be before\n        (to the left of) any existing values.\n\n        Similar to the `bisect` module in the standard library.\n\n        Runtime complexity: `O(log(n))` -- approximate.\n\n        >>> sl = SortedList([10, 11, 12, 13, 14])\n        >>> sl.bisect_left(12)\n        2\n\n        :param value: insertion index of value in sorted list\n        :return: index\n\n        """\n        _maxes = self._maxes\n\n        if not _maxes:\n            return 0\n\n        pos = bisect_left(_maxes, value)\n\n        if pos == len(_maxes):\n            return self._len\n\n        idx = bisect_left(self._lists[pos], value)\n        return self._loc(pos, idx)\n\n    def bisect_right(self, value):\n        """Return an index to insert `value` in the sorted list.\n\n        Similar to `bisect_left`, but if `value` is already present, the\n        insertion point will be after (to the right of) any existing values.\n\n        Similar to the `bisect` module in the standard library.\n\n        Runtime complexity: `O(log(n))` -- approximate.\n\n        >>> sl = SortedList([10, 11, 12, 13, 14])\n        >>> sl.bisect_right(12)\n        3\n\n        :param value: insertion index of value in sorted list\n        :return: index\n\n        """\n        _maxes = self._maxes\n\n        if not _maxes:\n            return 0\n\n        pos = bisect_right(_maxes, value)\n\n        if pos == len(_maxes):\n            return self._len\n\n        idx = bisect_right(self._lists[pos], value)\n        return self._loc(pos, idx)\n\n    bisect = bisect_right\n    _bisect_right = bisect_right\n\n    def upper_bound(self, x, equal=False):\n        k = self.bisect_left(x + equal)\n        if k:\n            return self[k - 1]\n        else:\n            sys.stderr.write("upper_bound: no element smaller than {0} in this SortedList\\n".format(x))\n\n    def lower_bound(self, x, equal=False):\n        k = self.bisect_left(x + 1 - equal) + 1\n        if k <= len(self):\n            return self[k - 1]\n        else:\n            sys.stderr.write("lower_bound: no element larger than {0} in this SortedList\\n".format(x))\n\n    def count(self, value):\n        """Return number of occurrences of `value` in the sorted list.\n\n        Runtime complexity: `O(log(n))` -- approximate.\n\n        >>> sl = SortedList([1, 2, 2, 3, 3, 3, 4, 4, 4, 4])\n        >>> sl.count(3)\n        3\n\n        :param value: value to count in sorted list\n        :return: count\n\n        """\n        _maxes = self._maxes\n\n        if not _maxes:\n            return 0\n\n        pos_left = bisect_left(_maxes, value)\n\n        if pos_left == len(_maxes):\n            return 0\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n        pos_right = bisect_right(_maxes, value)\n\n        if pos_right == len(_maxes):\n            return self._len - self._loc(pos_left, idx_left)\n\n        idx_right = bisect_right(_lists[pos_right], value)\n\n        if pos_left == pos_right:\n            return idx_right - idx_left\n\n        right = self._loc(pos_right, idx_right)\n        left = self._loc(pos_left, idx_left)\n        return right - left\n\n    def copy(self):\n        """Return a shallow copy of the sorted list.\n\n        Runtime complexity: `O(n)`\n\n        :return: new sorted list\n\n        """\n        return self.__class__(self)\n\n    __copy__ = copy\n\n    def append(self, value):\n        """Raise not-implemented error.\n\n        Implemented to override `MutableSequence.append` which provides an\n        erroneous default implementation.\n\n        :raises NotImplementedError: use ``sl.add(value)`` instead\n\n        """\n        raise NotImplementedError(\'use ``sl.add(value)`` instead\')\n\n    def extend(self, values):\n        """Raise not-implemented error.\n\n        Implemented to override `MutableSequence.extend` which provides an\n        erroneous default implementation.\n\n        :raises NotImplementedError: use ``sl.update(values)`` instead\n\n        """\n        raise NotImplementedError(\'use ``sl.update(values)`` instead\')\n\n    def insert(self, index, value):\n        """Raise not-implemented error.\n\n        :raises NotImplementedError: use ``sl.add(value)`` instead\n\n        """\n        raise NotImplementedError(\'use ``sl.add(value)`` instead\')\n\n    def pop(self, index=-1):\n        """Remove and return value at `index` in sorted list.\n\n        Raise :exc:`IndexError` if the sorted list is empty or index is out of\n        range.\n\n        Negative indices are supported.\n\n        Runtime complexity: `O(log(n))` -- approximate.\n\n        >>> sl = SortedList(\'abcde\')\n        >>> sl.pop()\n        \'e\'\n        >>> sl.pop(2)\n        \'c\'\n        >>> sl\n        SortedList([\'a\', \'b\', \'d\'])\n\n        :param int index: index of value (default -1)\n        :return: value\n        :raises IndexError: if index is out of range\n\n        """\n        if not self._len:\n            raise IndexError(\'pop index out of range\')\n\n        _lists = self._lists\n\n        if index == 0:\n            val = _lists[0][0]\n            self._delete(0, 0)\n            return val\n\n        if index == -1:\n            pos = len(_lists) - 1\n            loc = len(_lists[pos]) - 1\n            val = _lists[pos][loc]\n            self._delete(pos, loc)\n            return val\n\n        if 0 <= index < len(_lists[0]):\n            val = _lists[0][index]\n            self._delete(0, index)\n            return val\n\n        len_last = len(_lists[-1])\n\n        if -len_last < index < 0:\n            pos = len(_lists) - 1\n            loc = len_last + index\n            val = _lists[pos][loc]\n            self._delete(pos, loc)\n            return val\n\n        pos, idx = self._pos(index)\n        val = _lists[pos][idx]\n        self._delete(pos, idx)\n        return val\n\n    def index(self, value, start=None, stop=None):\n        """Return first index of value in sorted list.\n\n        Raise ValueError if `value` is not present.\n\n        Index must be between `start` and `stop` for the `value` to be\n        considered present. The default value, None, for `start` and `stop`\n        indicate the beginning and end of the sorted list.\n\n        Negative indices are supported.\n\n        Runtime complexity: `O(log(n))` -- approximate.\n\n        >>> sl = SortedList(\'abcde\')\n        >>> sl.index(\'d\')\n        3\n        >>> sl.index(\'z\')\n        Traceback (most recent call last):\n          ...\n        ValueError: \'z\' is not in list\n\n        :param value: value in sorted list\n        :param int start: start index (default None, start of sorted list)\n        :param int stop: stop index (default None, end of sorted list)\n        :return: index of value\n        :raises ValueError: if value is not present\n\n        """\n        _len = self._len\n\n        if not _len:\n            raise ValueError(\'{0!r} is not in list\'.format(value))\n\n        if start is None:\n            start = 0\n        if start < 0:\n            start += _len\n        if start < 0:\n            start = 0\n\n        if stop is None:\n            stop = _len\n        if stop < 0:\n            stop += _len\n        if stop > _len:\n            stop = _len\n\n        if stop <= start:\n            raise ValueError(\'{0!r} is not in list\'.format(value))\n\n        _maxes = self._maxes\n        pos_left = bisect_left(_maxes, value)\n\n        if pos_left == len(_maxes):\n            raise ValueError(\'{0!r} is not in list\'.format(value))\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n\n        if _lists[pos_left][idx_left] != value:\n            raise ValueError(\'{0!r} is not in list\'.format(value))\n\n        stop -= 1\n        left = self._loc(pos_left, idx_left)\n\n        if start <= left:\n            if left <= stop:\n                return left\n        else:\n            right = self._bisect_right(value) - 1\n\n            if start <= right:\n                return start\n\n        raise ValueError(\'{0!r} is not in list\'.format(value))\n\n    def __add__(self, other):\n        """Return new sorted list containing all values in both sequences.\n\n        ``sl.__add__(other)`` <==> ``sl + other``\n\n        Values in `other` do not need to be in sorted order.\n\n        Runtime complexity: `O(n*log(n))`\n\n        >>> sl1 = SortedList(\'bat\')\n        >>> sl2 = SortedList(\'cat\')\n        >>> sl1 + sl2\n        SortedList([\'a\', \'a\', \'b\', \'c\', \'t\', \'t\'])\n\n        :param other: other iterable\n        :return: new sorted list\n\n        """\n        values = reduce(iadd, self._lists, [])\n        values.extend(other)\n        return self.__class__(values)\n\n    __radd__ = __add__\n\n    def __iadd__(self, other):\n        """Update sorted list with values from `other`.\n\n        ``sl.__iadd__(other)`` <==> ``sl += other``\n\n        Values in `other` do not need to be in sorted order.\n\n        Runtime complexity: `O(k*log(n))` -- approximate.\n\n        >>> sl = SortedList(\'bat\')\n        >>> sl += \'cat\'\n        >>> sl\n        SortedList([\'a\', \'a\', \'b\', \'c\', \'t\', \'t\'])\n\n        :param other: other iterable\n        :return: existing sorted list\n\n        """\n        self._update(other)\n        return self\n\n    def __mul__(self, num):\n        """Return new sorted list with `num` shallow copies of values.\n\n        ``sl.__mul__(num)`` <==> ``sl * num``\n\n        Runtime complexity: `O(n*log(n))`\n\n        >>> sl = SortedList(\'abc\')\n        >>> sl * 3\n        SortedList([\'a\', \'a\', \'a\', \'b\', \'b\', \'b\', \'c\', \'c\', \'c\'])\n\n        :param int num: count of shallow copies\n        :return: new sorted list\n\n        """\n        values = reduce(iadd, self._lists, []) * num\n        return self.__class__(values)\n\n    __rmul__ = __mul__\n\n    def __imul__(self, num):\n        """Update the sorted list with `num` shallow copies of values.\n\n        ``sl.__imul__(num)`` <==> ``sl *= num``\n\n        Runtime complexity: `O(n*log(n))`\n\n        >>> sl = SortedList(\'abc\')\n        >>> sl *= 3\n        >>> sl\n        SortedList([\'a\', \'a\', \'a\', \'b\', \'b\', \'b\', \'c\', \'c\', \'c\'])\n\n        :param int num: count of shallow copies\n        :return: existing sorted list\n\n        """\n        values = reduce(iadd, self._lists, []) * num\n        self._clear()\n        self._update(values)\n        return self\n\n    def __make_cmp(seq_op, symbol, doc):\n        "Make comparator method."\n\n        def comparer(self, other):\n            "Compare method for sorted list and sequence."\n            if not isinstance(other, Sequence):\n                return NotImplemented\n\n            self_len = self._len\n            len_other = len(other)\n\n            if self_len != len_other:\n                if seq_op is eq:\n                    return False\n                if seq_op is ne:\n                    return True\n\n            for alpha, beta in zip(self, other):\n                if alpha != beta:\n                    return seq_op(alpha, beta)\n\n            return seq_op(self_len, len_other)\n\n        seq_op_name = seq_op.__name__\n        comparer.__name__ = \'__{0}__\'.format(seq_op_name)\n        doc_str = """Return true if and only if sorted list is {0} `other`.\n\n        ``sl.__{1}__(other)`` <==> ``sl {2} other``\n\n        Comparisons use lexicographical order as with sequences.\n\n        Runtime complexity: `O(n)`\n\n        :param other: `other` sequence\n        :return: true if sorted list is {0} `other`\n\n        """\n        comparer.__doc__ = dedent(doc_str.format(doc, seq_op_name, symbol))\n        return comparer\n\n    __eq__ = __make_cmp(eq, \'==\', \'equal to\')\n    __ne__ = __make_cmp(ne, \'!=\', \'not equal to\')\n    __lt__ = __make_cmp(lt, \'<\', \'less than\')\n    __gt__ = __make_cmp(gt, \'>\', \'greater than\')\n    __le__ = __make_cmp(le, \'<=\', \'less than or equal to\')\n    __ge__ = __make_cmp(ge, \'>=\', \'greater than or equal to\')\n    __make_cmp = staticmethod(__make_cmp)\n\n    def __reduce__(self):\n        values = reduce(iadd, self._lists, [])\n        return (type(self), (values,))\n\n    @recursive_repr()\n    def __repr__(self):\n        """Return string representation of sorted list.\n\n        ``sl.__repr__()`` <==> ``repr(sl)``\n\n        :return: string representation\n\n        """\n        return \'{0}({1!r})\'.format(type(self).__name__, list(self))\n\n    def _check(self):\n        """Check invariants of sorted list.\n\n        Runtime complexity: `O(n)`\n\n        """\n        try:\n            assert self._load >= 4\n            assert len(self._maxes) == len(self._lists)\n            assert self._len == sum(len(sublist) for sublist in self._lists)\n\n            # Check all sublists are sorted.\n\n            for sublist in self._lists:\n                for pos in range(1, len(sublist)):\n                    assert sublist[pos - 1] <= sublist[pos]\n\n            # Check beginning/end of sublists are sorted.\n\n            for pos in range(1, len(self._lists)):\n                assert self._lists[pos - 1][-1] <= self._lists[pos][0]\n\n            # Check _maxes index is the last value of each sublist.\n\n            for pos in range(len(self._maxes)):\n                assert self._maxes[pos] == self._lists[pos][-1]\n\n            # Check sublist lengths are less than double load-factor.\n\n            double = self._load << 1\n            assert all(len(sublist) <= double for sublist in self._lists)\n\n            # Check sublist lengths are greater than half load-factor for all\n            # but the last sublist.\n\n            half = self._load >> 1\n            for pos in range(0, len(self._lists) - 1):\n                assert len(self._lists[pos]) >= half\n\n            if self._index:\n                assert self._len == self._index[0]\n                assert len(self._index) == self._offset + len(self._lists)\n\n                # Check index leaf nodes equal length of sublists.\n\n                for pos in range(len(self._lists)):\n                    leaf = self._index[self._offset + pos]\n                    assert leaf == len(self._lists[pos])\n\n                # Check index branch nodes are the sum of their children.\n\n                for pos in range(self._offset):\n                    child = (pos << 1) + 1\n                    if child >= len(self._index):\n                        assert self._index[pos] == 0\n                    elif child + 1 == len(self._index):\n                        assert self._index[pos] == self._index[child]\n                    else:\n                        child_sum = self._index[child] + self._index[child + 1]\n                        assert child_sum == self._index[pos]\n        except:\n            traceback.print_exc(file=sys.stdout)\n            print(\'len\', self._len)\n            print(\'load\', self._load)\n            print(\'offset\', self._offset)\n            print(\'len_index\', len(self._index))\n            print(\'index\', self._index)\n            print(\'len_maxes\', len(self._maxes))\n            print(\'maxes\', self._maxes)\n            print(\'len_lists\', len(self._lists))\n            print(\'lists\', self._lists)\n            raise\n\n\ndef identity(value):\n    """Identity function."""\n    return value\n\n\nclass OnlineSortedKeyList(OnlineSortedList):\n    """Sorted-key list is a subtype of sorted list.\n\n    The sorted-key list maintains values in comparison order based on the\n    result of a key function applied to every value.\n\n    All the same methods that are available in :class:`SortedList` are also\n    available in :class:`SortedKeyList`.\n\n    Additional methods provided:\n\n    * :attr:`SortedKeyList.key`\n    * :func:`SortedKeyList.bisect_key_left`\n    * :func:`SortedKeyList.bisect_key_right`\n    * :func:`SortedKeyList.irange_key`\n\n    Some examples below use:\n\n    >>> from operator import neg\n    >>> neg\n    <built-in function neg>\n    >>> neg(1)\n    -1\n\n    """\n\n    def __init__(self, iterable=None, key=identity):\n        """Initialize sorted-key list instance.\n\n        Optional `iterable` argument provides an initial iterable of values to\n        initialize the sorted-key list.\n\n        Optional `key` argument defines a callable that, like the `key`\n        argument to Python\'s `sorted` function, extracts a comparison key from\n        each value. The default is the identity function.\n\n        Runtime complexity: `O(n*log(n))`\n\n        >>> from operator import neg\n        >>> skl = SortedKeyList(key=neg)\n        >>> skl\n        SortedKeyList([], key=<built-in function neg>)\n        >>> skl = SortedKeyList([3, 1, 2], key=neg)\n        >>> skl\n        SortedKeyList([3, 2, 1], key=<built-in function neg>)\n\n        :param iterable: initial values (optional)\n        :param key: function used to extract comparison key (optional)\n\n        """\n        super().__init__()\n        self._key = key\n        self._len = 0\n        self._load = self.DEFAULT_LOAD_FACTOR\n        self._lists = []\n        self._keys = []\n        self._maxes = []\n        self._index = []\n        self._offset = 0\n\n        if iterable is not None:\n            self._update(iterable)\n\n    def __new__(cls, iterable=None, key=identity):\n        return object.__new__(cls)\n\n    @property\n    def key(self):\n        "Function used to extract comparison key from values."\n        return self._key\n\n    def clear(self):\n        """Remove all values from sorted-key list.\n\n        Runtime complexity: `O(n)`\n\n        """\n        self._len = 0\n        del self._lists[:]\n        del self._keys[:]\n        del self._maxes[:]\n        del self._index[:]\n\n    _clear = clear\n\n    def add(self, value):\n        """Add `value` to sorted-key list.\n\n        Runtime complexity: `O(log(n))` -- approximate.\n\n        >>> from operator import neg\n        >>> skl = SortedKeyList(key=neg)\n        >>> skl.add(3)\n        >>> skl.add(1)\n        >>> skl.add(2)\n        >>> skl\n        SortedKeyList([3, 2, 1], key=<built-in function neg>)\n\n        :param value: value to add to sorted-key list\n\n        """\n        _lists = self._lists\n        _keys = self._keys\n        _maxes = self._maxes\n\n        key = self._key(value)\n\n        if _maxes:\n            pos = bisect_right(_maxes, key)\n\n            if pos == len(_maxes):\n                pos -= 1\n                _lists[pos].append(value)\n                _keys[pos].append(key)\n                _maxes[pos] = key\n            else:\n                idx = bisect_right(_keys[pos], key)\n                _lists[pos].insert(idx, value)\n                _keys[pos].insert(idx, key)\n\n            self._expand(pos)\n        else:\n            _lists.append([value])\n            _keys.append([key])\n            _maxes.append(key)\n\n        self._len += 1\n\n    def _expand(self, pos):\n        """Split sublists with length greater than double the load-factor.\n\n        Updates the index when the sublist length is less than double the load\n        level. This requires incrementing the nodes in a traversal from the\n        leaf node to the root. For an example traversal see\n        ``SortedList._loc``.\n\n        """\n        _lists = self._lists\n        _keys = self._keys\n        _index = self._index\n\n        if len(_keys[pos]) > (self._load << 1):\n            _maxes = self._maxes\n            _load = self._load\n\n            _lists_pos = _lists[pos]\n            _keys_pos = _keys[pos]\n            half = _lists_pos[_load:]\n            half_keys = _keys_pos[_load:]\n            del _lists_pos[_load:]\n            del _keys_pos[_load:]\n            _maxes[pos] = _keys_pos[-1]\n\n            _lists.insert(pos + 1, half)\n            _keys.insert(pos + 1, half_keys)\n            _maxes.insert(pos + 1, half_keys[-1])\n\n            del _index[:]\n        else:\n            if _index:\n                child = self._offset + pos\n                while child:\n                    _index[child] += 1\n                    child = (child - 1) >> 1\n                _index[0] += 1\n\n    def update(self, iterable):\n        """Update sorted-key list by adding all values from `iterable`.\n\n        Runtime complexity: `O(k*log(n))` -- approximate.\n\n        >>> from operator import neg\n        >>> skl = SortedKeyList(key=neg)\n        >>> skl.update([3, 1, 2])\n        >>> skl\n        SortedKeyList([3, 2, 1], key=<built-in function neg>)\n\n        :param iterable: iterable of values to add\n\n        """\n        _lists = self._lists\n        _keys = self._keys\n        _maxes = self._maxes\n        values = sorted(iterable, key=self._key)\n\n        if _maxes:\n            if len(values) * 4 >= self._len:\n                _lists.append(values)\n                values = reduce(iadd, _lists, [])\n                values.sort(key=self._key)\n                self._clear()\n            else:\n                _add = self.add\n                for val in values:\n                    _add(val)\n                return\n\n        _load = self._load\n        _lists.extend(values[pos:(pos + _load)]\n                      for pos in range(0, len(values), _load))\n        _keys.extend(list(map(self._key, _list)) for _list in _lists)\n        _maxes.extend(sublist[-1] for sublist in _keys)\n        self._len = len(values)\n        del self._index[:]\n\n    _update = update\n\n    def __contains__(self, value):\n        """Return true if `value` is an element of the sorted-key list.\n\n        ``skl.__contains__(value)`` <==> ``value in skl``\n\n        Runtime complexity: `O(log(n))`\n\n        >>> from operator import neg\n        >>> skl = SortedKeyList([1, 2, 3, 4, 5], key=neg)\n        >>> 3 in skl\n        True\n\n        :param value: search for value in sorted-key list\n        :return: true if `value` in sorted-key list\n\n        """\n        _maxes = self._maxes\n\n        if not _maxes:\n            return False\n\n        key = self._key(value)\n        pos = bisect_left(_maxes, key)\n\n        if pos == len(_maxes):\n            return False\n\n        _lists = self._lists\n        _keys = self._keys\n\n        idx = bisect_left(_keys[pos], key)\n\n        len_keys = len(_keys)\n        len_sublist = len(_keys[pos])\n\n        while True:\n            if _keys[pos][idx] != key:\n                return False\n            if _lists[pos][idx] == value:\n                return True\n            idx += 1\n            if idx == len_sublist:\n                pos += 1\n                if pos == len_keys:\n                    return False\n                len_sublist = len(_keys[pos])\n                idx = 0\n\n    def discard(self, value):\n        """Remove `value` from sorted-key list if it is a member.\n\n        If `value` is not a member, do nothing.\n\n        Runtime complexity: `O(log(n))` -- approximate.\n\n        >>> from operator import neg\n        >>> skl = SortedKeyList([5, 4, 3, 2, 1], key=neg)\n        >>> skl.discard(1)\n        >>> skl.discard(0)\n        >>> skl == [5, 4, 3, 2]\n        True\n\n        :param value: `value` to discard from sorted-key list\n\n        """\n        _maxes = self._maxes\n\n        if not _maxes:\n            return\n\n        key = self._key(value)\n        pos = bisect_left(_maxes, key)\n\n        if pos == len(_maxes):\n            return\n\n        _lists = self._lists\n        _keys = self._keys\n        idx = bisect_left(_keys[pos], key)\n        len_keys = len(_keys)\n        len_sublist = len(_keys[pos])\n\n        while True:\n            if _keys[pos][idx] != key:\n                return\n            if _lists[pos][idx] == value:\n                self._delete(pos, idx)\n                return\n            idx += 1\n            if idx == len_sublist:\n                pos += 1\n                if pos == len_keys:\n                    return\n                len_sublist = len(_keys[pos])\n                idx = 0\n\n    def remove(self, value):\n        """Remove `value` from sorted-key list; `value` must be a member.\n\n        If `value` is not a member, raise ValueError.\n\n        Runtime complexity: `O(log(n))` -- approximate.\n\n        >>> from operator import neg\n        >>> skl = SortedKeyList([1, 2, 3, 4, 5], key=neg)\n        >>> skl.remove(5)\n        >>> skl == [4, 3, 2, 1]\n        True\n        >>> skl.remove(0)\n        Traceback (most recent call last):\n          ...\n        ValueError: 0 not in list\n\n        :param value: `value` to remove from sorted-key list\n        :raises ValueError: if `value` is not in sorted-key list\n\n        """\n        _maxes = self._maxes\n\n        if not _maxes:\n            raise ValueError(\'{0!r} not in list\'.format(value))\n\n        key = self._key(value)\n        pos = bisect_left(_maxes, key)\n\n        if pos == len(_maxes):\n            raise ValueError(\'{0!r} not in list\'.format(value))\n\n        _lists = self._lists\n        _keys = self._keys\n        idx = bisect_left(_keys[pos], key)\n        len_keys = len(_keys)\n        len_sublist = len(_keys[pos])\n\n        while True:\n            if _keys[pos][idx] != key:\n                raise ValueError(\'{0!r} not in list\'.format(value))\n            if _lists[pos][idx] == value:\n                self._delete(pos, idx)\n                return\n            idx += 1\n            if idx == len_sublist:\n                pos += 1\n                if pos == len_keys:\n                    raise ValueError(\'{0!r} not in list\'.format(value))\n                len_sublist = len(_keys[pos])\n                idx = 0\n\n    def _delete(self, pos, idx):\n        """Delete value at the given `(pos, idx)`.\n\n        Combines lists that are less than half the load level.\n\n        Updates the index when the sublist length is more than half the load\n        level. This requires decrementing the nodes in a traversal from the\n        leaf node to the root. For an example traversal see\n        ``SortedList._loc``.\n\n        :param int pos: lists index\n        :param int idx: sublist index\n\n        """\n        _lists = self._lists\n        _keys = self._keys\n        _maxes = self._maxes\n        _index = self._index\n        keys_pos = _keys[pos]\n        lists_pos = _lists[pos]\n\n        del keys_pos[idx]\n        del lists_pos[idx]\n        self._len -= 1\n\n        len_keys_pos = len(keys_pos)\n\n        if len_keys_pos > (self._load >> 1):\n            _maxes[pos] = keys_pos[-1]\n\n            if _index:\n                child = self._offset + pos\n                while child > 0:\n                    _index[child] -= 1\n                    child = (child - 1) >> 1\n                _index[0] -= 1\n        elif len(_keys) > 1:\n            if not pos:\n                pos += 1\n\n            prev = pos - 1\n            _keys[prev].extend(_keys[pos])\n            _lists[prev].extend(_lists[pos])\n            _maxes[prev] = _keys[prev][-1]\n\n            del _lists[pos]\n            del _keys[pos]\n            del _maxes[pos]\n            del _index[:]\n\n            self._expand(prev)\n        elif len_keys_pos:\n            _maxes[pos] = keys_pos[-1]\n        else:\n            del _lists[pos]\n            del _keys[pos]\n            del _maxes[pos]\n            del _index[:]\n\n    def irange(self, minimum=None, maximum=None, inclusive=(True, True),\n               reverse=False):\n        """Create an iterator of values between `minimum` and `maximum`.\n\n        Both `minimum` and `maximum` default to `None` which is automatically\n        inclusive of the beginning and end of the sorted-key list.\n\n        The argument `inclusive` is a pair of booleans that indicates whether\n        the minimum and maximum ought to be included in the range,\n        respectively. The default is ``(True, True)`` such that the range is\n        inclusive of both minimum and maximum.\n\n        When `reverse` is `True` the values are yielded from the iterator in\n        reverse order; `reverse` defaults to `False`.\n\n        >>> from operator import neg\n        >>> skl = SortedKeyList([11, 12, 13, 14, 15], key=neg)\n        >>> it = skl.irange(14.5, 11.5)\n        >>> list(it)\n        [14, 13, 12]\n\n        :param minimum: minimum value to start iterating\n        :param maximum: maximum value to stop iterating\n        :param inclusive: pair of booleans\n        :param bool reverse: yield values in reverse order\n        :return: iterator\n\n        """\n        min_key = self._key(minimum) if minimum is not None else None\n        max_key = self._key(maximum) if maximum is not None else None\n        return self._irange_key(\n            min_key=min_key, max_key=max_key,\n            inclusive=inclusive, reverse=reverse,\n        )\n\n    def irange_key(self, min_key=None, max_key=None, inclusive=(True, True),\n                   reverse=False):\n        """Create an iterator of values between `min_key` and `max_key`.\n\n        Both `min_key` and `max_key` default to `None` which is automatically\n        inclusive of the beginning and end of the sorted-key list.\n\n        The argument `inclusive` is a pair of booleans that indicates whether\n        the minimum and maximum ought to be included in the range,\n        respectively. The default is ``(True, True)`` such that the range is\n        inclusive of both minimum and maximum.\n\n        When `reverse` is `True` the values are yielded from the iterator in\n        reverse order; `reverse` defaults to `False`.\n\n        >>> from operator import neg\n        >>> skl = SortedKeyList([11, 12, 13, 14, 15], key=neg)\n        >>> it = skl.irange_key(-14, -12)\n        >>> list(it)\n        [14, 13, 12]\n\n        :param min_key: minimum key to start iterating\n        :param max_key: maximum key to stop iterating\n        :param inclusive: pair of booleans\n        :param bool reverse: yield values in reverse order\n        :return: iterator\n\n        """\n        _maxes = self._maxes\n\n        if not _maxes:\n            return iter(())\n\n        _keys = self._keys\n\n        # Calculate the minimum (pos, idx) pair. By default this location\n        # will be inclusive in our calculation.\n\n        if min_key is None:\n            min_pos = 0\n            min_idx = 0\n        else:\n            if inclusive[0]:\n                min_pos = bisect_left(_maxes, min_key)\n\n                if min_pos == len(_maxes):\n                    return iter(())\n\n                min_idx = bisect_left(_keys[min_pos], min_key)\n            else:\n                min_pos = bisect_right(_maxes, min_key)\n\n                if min_pos == len(_maxes):\n                    return iter(())\n\n                min_idx = bisect_right(_keys[min_pos], min_key)\n\n        # Calculate the maximum (pos, idx) pair. By default this location\n        # will be exclusive in our calculation.\n\n        if max_key is None:\n            max_pos = len(_maxes) - 1\n            max_idx = len(_keys[max_pos])\n        else:\n            if inclusive[1]:\n                max_pos = bisect_right(_maxes, max_key)\n\n                if max_pos == len(_maxes):\n                    max_pos -= 1\n                    max_idx = len(_keys[max_pos])\n                else:\n                    max_idx = bisect_right(_keys[max_pos], max_key)\n            else:\n                max_pos = bisect_left(_maxes, max_key)\n\n                if max_pos == len(_maxes):\n                    max_pos -= 1\n                    max_idx = len(_keys[max_pos])\n                else:\n                    max_idx = bisect_left(_keys[max_pos], max_key)\n\n        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)\n\n    _irange_key = irange_key\n\n    def bisect_left(self, value):\n        """Return an index to insert `value` in the sorted-key list.\n\n        If the `value` is already present, the insertion point will be before\n        (to the left of) any existing values.\n\n        Similar to the `bisect` module in the standard library.\n\n        Runtime complexity: `O(log(n))` -- approximate.\n\n        >>> from operator import neg\n        >>> skl = SortedKeyList([5, 4, 3, 2, 1], key=neg)\n        >>> skl.bisect_left(1)\n        4\n\n        :param value: insertion index of value in sorted-key list\n        :return: index\n\n        """\n        return self._bisect_key_left(self._key(value))\n\n    def bisect_right(self, value):\n        """Return an index to insert `value` in the sorted-key list.\n\n        Similar to `bisect_left`, but if `value` is already present, the\n        insertion point will be after (to the right of) any existing values.\n\n        Similar to the `bisect` module in the standard library.\n\n        Runtime complexity: `O(log(n))` -- approximate.\n\n        >>> from operator import neg\n        >>> skl = SortedList([5, 4, 3, 2, 1], key=neg)\n        >>> skl.bisect_right(1)\n        5\n\n        :param value: insertion index of value in sorted-key list\n        :return: index\n\n        """\n        return self._bisect_key_right(self._key(value))\n\n    bisect = bisect_right\n\n    def bisect_key_left(self, key):\n        """Return an index to insert `key` in the sorted-key list.\n\n        If the `key` is already present, the insertion point will be before (to\n        the left of) any existing keys.\n\n        Similar to the `bisect` module in the standard library.\n\n        Runtime complexity: `O(log(n))` -- approximate.\n\n        >>> from operator import neg\n        >>> skl = SortedKeyList([5, 4, 3, 2, 1], key=neg)\n        >>> skl.bisect_key_left(-1)\n        4\n\n        :param key: insertion index of key in sorted-key list\n        :return: index\n\n        """\n        _maxes = self._maxes\n\n        if not _maxes:\n            return 0\n\n        pos = bisect_left(_maxes, key)\n\n        if pos == len(_maxes):\n            return self._len\n\n        idx = bisect_left(self._keys[pos], key)\n\n        return self._loc(pos, idx)\n\n    _bisect_key_left = bisect_key_left\n\n    def bisect_key_right(self, key):\n        """Return an index to insert `key` in the sorted-key list.\n\n        Similar to `bisect_key_left`, but if `key` is already present, the\n        insertion point will be after (to the right of) any existing keys.\n\n        Similar to the `bisect` module in the standard library.\n\n        Runtime complexity: `O(log(n))` -- approximate.\n\n        >>> from operator import neg\n        >>> skl = SortedList([5, 4, 3, 2, 1], key=neg)\n        >>> skl.bisect_key_right(-1)\n        5\n\n        :param key: insertion index of key in sorted-key list\n        :return: index\n\n        """\n        _maxes = self._maxes\n\n        if not _maxes:\n            return 0\n\n        pos = bisect_right(_maxes, key)\n\n        if pos == len(_maxes):\n            return self._len\n\n        idx = bisect_right(self._keys[pos], key)\n\n        return self._loc(pos, idx)\n\n    bisect_key = bisect_key_right\n    _bisect_key_right = bisect_key_right\n\n    def count(self, value):\n        """Return number of occurrences of `value` in the sorted-key list.\n\n        Runtime complexity: `O(log(n))` -- approximate.\n\n        >>> from operator import neg\n        >>> skl = SortedKeyList([4, 4, 4, 4, 3, 3, 3, 2, 2, 1], key=neg)\n        >>> skl.count(2)\n        2\n\n        :param value: value to count in sorted-key list\n        :return: count\n\n        """\n        _maxes = self._maxes\n\n        if not _maxes:\n            return 0\n\n        key = self._key(value)\n        pos = bisect_left(_maxes, key)\n\n        if pos == len(_maxes):\n            return 0\n\n        _lists = self._lists\n        _keys = self._keys\n        idx = bisect_left(_keys[pos], key)\n        total = 0\n        len_keys = len(_keys)\n        len_sublist = len(_keys[pos])\n\n        while True:\n            if _keys[pos][idx] != key:\n                return total\n            if _lists[pos][idx] == value:\n                total += 1\n            idx += 1\n            if idx == len_sublist:\n                pos += 1\n                if pos == len_keys:\n                    return total\n                len_sublist = len(_keys[pos])\n                idx = 0\n\n    def copy(self):\n        """Return a shallow copy of the sorted-key list.\n\n        Runtime complexity: `O(n)`\n\n        :return: new sorted-key list\n\n        """\n        return self.__class__(self, key=self._key)\n\n    __copy__ = copy\n\n    def index(self, value, start=None, stop=None):\n        """Return first index of value in sorted-key list.\n\n        Raise ValueError if `value` is not present.\n\n        Index must be between `start` and `stop` for the `value` to be\n        considered present. The default value, None, for `start` and `stop`\n        indicate the beginning and end of the sorted-key list.\n\n        Negative indices are supported.\n\n        Runtime complexity: `O(log(n))` -- approximate.\n\n        >>> from operator import neg\n        >>> skl = SortedKeyList([5, 4, 3, 2, 1], key=neg)\n        >>> skl.index(2)\n        3\n        >>> skl.index(0)\n        Traceback (most recent call last):\n          ...\n        ValueError: 0 is not in list\n\n        :param value: value in sorted-key list\n        :param int start: start index (default None, start of sorted-key list)\n        :param int stop: stop index (default None, end of sorted-key list)\n        :return: index of value\n        :raises ValueError: if value is not present\n\n        """\n        _len = self._len\n\n        if not _len:\n            raise ValueError(\'{0!r} is not in list\'.format(value))\n\n        if start is None:\n            start = 0\n        if start < 0:\n            start += _len\n        if start < 0:\n            start = 0\n\n        if stop is None:\n            stop = _len\n        if stop < 0:\n            stop += _len\n        if stop > _len:\n            stop = _len\n\n        if stop <= start:\n            raise ValueError(\'{0!r} is not in list\'.format(value))\n\n        _maxes = self._maxes\n        key = self._key(value)\n        pos = bisect_left(_maxes, key)\n\n        if pos == len(_maxes):\n            raise ValueError(\'{0!r} is not in list\'.format(value))\n\n        stop -= 1\n        _lists = self._lists\n        _keys = self._keys\n        idx = bisect_left(_keys[pos], key)\n        len_keys = len(_keys)\n        len_sublist = len(_keys[pos])\n\n        while True:\n            if _keys[pos][idx] != key:\n                raise ValueError(\'{0!r} is not in list\'.format(value))\n            if _lists[pos][idx] == value:\n                loc = self._loc(pos, idx)\n                if start <= loc <= stop:\n                    return loc\n                elif loc > stop:\n                    break\n            idx += 1\n            if idx == len_sublist:\n                pos += 1\n                if pos == len_keys:\n                    raise ValueError(\'{0!r} is not in list\'.format(value))\n                len_sublist = len(_keys[pos])\n                idx = 0\n\n        raise ValueError(\'{0!r} is not in list\'.format(value))\n\n    def __add__(self, other):\n        """Return new sorted-key list containing all values in both sequences.\n\n        ``skl.__add__(other)`` <==> ``skl + other``\n\n        Values in `other` do not need to be in sorted-key order.\n\n        Runtime complexity: `O(n*log(n))`\n\n        >>> from operator import neg\n        >>> skl1 = SortedKeyList([5, 4, 3], key=neg)\n        >>> skl2 = SortedKeyList([2, 1, 0], key=neg)\n        >>> skl1 + skl2\n        SortedKeyList([5, 4, 3, 2, 1, 0], key=<built-in function neg>)\n\n        :param other: other iterable\n        :return: new sorted-key list\n\n        """\n        values = reduce(iadd, self._lists, [])\n        values.extend(other)\n        return self.__class__(values, key=self._key)\n\n    __radd__ = __add__\n\n    def __mul__(self, num):\n        """Return new sorted-key list with `num` shallow copies of values.\n\n        ``skl.__mul__(num)`` <==> ``skl * num``\n\n        Runtime complexity: `O(n*log(n))`\n\n        >>> from operator import neg\n        >>> skl = SortedKeyList([3, 2, 1], key=neg)\n        >>> skl * 2\n        SortedKeyList([3, 3, 2, 2, 1, 1], key=<built-in function neg>)\n\n        :param int num: count of shallow copies\n        :return: new sorted-key list\n\n        """\n        values = reduce(iadd, self._lists, []) * num\n        return self.__class__(values, key=self._key)\n\n    def __reduce__(self):\n        values = reduce(iadd, self._lists, [])\n        return (type(self), (values, self.key))\n\n    @recursive_repr()\n    def __repr__(self):\n        """Return string representation of sorted-key list.\n\n        ``skl.__repr__()`` <==> ``repr(skl)``\n\n        :return: string representation\n\n        """\n        type_name = type(self).__name__\n        return \'{0}({1!r}, key={2!r})\'.format(type_name, list(self), self._key)\n\n    def _check(self):\n        """Check invariants of sorted-key list.\n\n        Runtime complexity: `O(n)`\n\n        """\n        try:\n            assert self._load >= 4\n            assert len(self._maxes) == len(self._lists) == len(self._keys)\n            assert self._len == sum(len(sublist) for sublist in self._lists)\n\n            # Check all sublists are sorted.\n\n            for sublist in self._keys:\n                for pos in range(1, len(sublist)):\n                    assert sublist[pos - 1] <= sublist[pos]\n\n            # Check beginning/end of sublists are sorted.\n\n            for pos in range(1, len(self._keys)):\n                assert self._keys[pos - 1][-1] <= self._keys[pos][0]\n\n            # Check _keys matches _key mapped to _lists.\n\n            for val_sublist, key_sublist in zip(self._lists, self._keys):\n                assert len(val_sublist) == len(key_sublist)\n                for val, key in zip(val_sublist, key_sublist):\n                    assert self._key(val) == key\n\n            # Check _maxes index is the last value of each sublist.\n\n            for pos in range(len(self._maxes)):\n                assert self._maxes[pos] == self._keys[pos][-1]\n\n            # Check sublist lengths are less than double load-factor.\n\n            double = self._load << 1\n            assert all(len(sublist) <= double for sublist in self._lists)\n\n            # Check sublist lengths are greater than half load-factor for all\n            # but the last sublist.\n\n            half = self._load >> 1\n            for pos in range(0, len(self._lists) - 1):\n                assert len(self._lists[pos]) >= half\n\n            if self._index:\n                assert self._len == self._index[0]\n                assert len(self._index) == self._offset + len(self._lists)\n\n                # Check index leaf nodes equal length of sublists.\n\n                for pos in range(len(self._lists)):\n                    leaf = self._index[self._offset + pos]\n                    assert leaf == len(self._lists[pos])\n\n                # Check index branch nodes are the sum of their children.\n\n                for pos in range(self._offset):\n                    child = (pos << 1) + 1\n                    if child >= len(self._index):\n                        assert self._index[pos] == 0\n                    elif child + 1 == len(self._index):\n                        assert self._index[pos] == self._index[child]\n                    else:\n                        child_sum = self._index[child] + self._index[child + 1]\n                        assert child_sum == self._index[pos]\n        except:\n            traceback.print_exc(file=sys.stdout)\n            print(\'len\', self._len)\n            print(\'load\', self._load)\n            print(\'offset\', self._offset)\n            print(\'len_index\', len(self._index))\n            print(\'index\', self._index)\n            print(\'len_maxes\', len(self._maxes))\n            print(\'maxes\', self._maxes)\n            print(\'len_keys\', len(self._keys))\n            print(\'keys\', self._keys)\n            print(\'len_lists\', len(self._lists))\n            print(\'lists\', self._lists)\n            raise\n\n\n'),
    'lib.string_search': (False, "import functools\nimport typing\n\n\ndef _sa_naive(s: typing.List[int]) -> typing.List[int]:\n    sa = list(range(len(s)))\n    return sorted(sa, key=lambda i: s[i:])\n\n\ndef _sa_doubling(s: typing.List[int]) -> typing.List[int]:\n    n = len(s)\n    sa = list(range(n))\n    rnk = s.copy()\n    tmp = [0] * n\n    k = 1\n    while k < n:\n        def cmp(x: int, y: int) -> int:\n            if rnk[x] != rnk[y]:\n                return rnk[x] - rnk[y]\n            rx = rnk[x + k] if x + k < n else -1\n            ry = rnk[y + k] if y + k < n else -1\n            return rx - ry\n        sa.sort(key=functools.cmp_to_key(cmp))\n        tmp[sa[0]] = 0\n        for i in range(1, n):\n            tmp[sa[i]] = tmp[sa[i - 1]] + (1 if cmp(sa[i - 1], sa[i]) else 0)\n        tmp, rnk = rnk, tmp\n        k *= 2\n    return sa\n\n\ndef _sa_is(s: typing.List[int], upper: int) -> typing.List[int]:\n    threshold_naive = 10\n    threshold_doubling = 40\n\n    n = len(s)\n\n    if n == 0:\n        return []\n    if n == 1:\n        return [0]\n    if n == 2:\n        if s[0] < s[1]:\n            return [0, 1]\n        else:\n            return [1, 0]\n\n    if n < threshold_naive:\n        return _sa_naive(s)\n    if n < threshold_doubling:\n        return _sa_doubling(s)\n\n    sa = [0] * n\n    ls = [False] * n\n    for i in range(n - 2, -1, -1):\n        if s[i] == s[i + 1]:\n            ls[i] = ls[i + 1]\n        else:\n            ls[i] = s[i] < s[i + 1]\n\n    sum_l = [0] * (upper + 1)\n    sum_s = [0] * (upper + 1)\n    for i in range(n):\n        if not ls[i]:\n            sum_s[s[i]] += 1\n        else:\n            sum_l[s[i] + 1] += 1\n    for i in range(upper + 1):\n        sum_s[i] += sum_l[i]\n        if i < upper:\n            sum_l[i + 1] += sum_s[i]\n\n    def induce(lms: typing.List[int]) -> None:\n        nonlocal sa\n        sa = [-1] * n\n\n        buf = sum_s.copy()\n        for d in lms:\n            if d == n:\n                continue\n            sa[buf[s[d]]] = d\n            buf[s[d]] += 1\n\n        buf = sum_l.copy()\n        sa[buf[s[n - 1]]] = n - 1\n        buf[s[n - 1]] += 1\n        for i in range(n):\n            v = sa[i]\n            if v >= 1 and not ls[v - 1]:\n                sa[buf[s[v - 1]]] = v - 1\n                buf[s[v - 1]] += 1\n\n        buf = sum_l.copy()\n        for i in range(n - 1, -1, -1):\n            v = sa[i]\n            if v >= 1 and ls[v - 1]:\n                buf[s[v - 1] + 1] -= 1\n                sa[buf[s[v - 1] + 1]] = v - 1\n\n    lms_map = [-1] * (n + 1)\n    m = 0\n    for i in range(1, n):\n        if not ls[i - 1] and ls[i]:\n            lms_map[i] = m\n            m += 1\n    lms = []\n    for i in range(1, n):\n        if not ls[i - 1] and ls[i]:\n            lms.append(i)\n\n    induce(lms)\n\n    if m:\n        sorted_lms = []\n        for v in sa:\n            if lms_map[v] != -1:\n                sorted_lms.append(v)\n        rec_s = [0] * m\n        rec_upper = 0\n        rec_s[lms_map[sorted_lms[0]]] = 0\n        for i in range(1, m):\n            left = sorted_lms[i - 1]\n            right = sorted_lms[i]\n            if lms_map[left] + 1 < m:\n                end_l = lms[lms_map[left] + 1]\n            else:\n                end_l = n\n            if lms_map[right] + 1 < m:\n                end_r = lms[lms_map[right] + 1]\n            else:\n                end_r = n\n\n            same = True\n            if end_l - left != end_r - right:\n                same = False\n            else:\n                while left < end_l:\n                    if s[left] != s[right]:\n                        break\n                    left += 1\n                    right += 1\n                if left == n or s[left] != s[right]:\n                    same = False\n\n            if not same:\n                rec_upper += 1\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper\n\n        rec_sa = _sa_is(rec_s, rec_upper)\n\n        for i in range(m):\n            sorted_lms[i] = lms[rec_sa[i]]\n        induce(sorted_lms)\n\n    return sa\n\n\ndef suffix_array(s: typing.Union[str, typing.List[int]],\n                 upper: typing.Optional[int] = None) -> typing.List[int]:\n    '''\n    SA-IS, linear-time suffix array construction\n    Reference:\n    G. Nong, S. Zhang, and W. H. Chan,\n    Two Efficient Algorithms for Linear Time Suffix Array Construction\n    '''\n\n    if isinstance(s, str):\n        return _sa_is([ord(c) for c in s], 255)\n    elif upper is None:\n        n = len(s)\n        idx = list(range(n))\n\n        def cmp(left: int, right: int) -> int:\n            return typing.cast(int, s[left]) - typing.cast(int, s[right])\n\n        idx.sort(key=functools.cmp_to_key(cmp))\n        s2 = [0] * n\n        now = 0\n        for i in range(n):\n            if i and s[idx[i - 1]] != s[idx[i]]:\n                now += 1\n            s2[idx[i]] = now\n        return _sa_is(s2, now)\n    else:\n        assert 0 <= upper\n        for d in s:\n            assert 0 <= d <= upper\n\n        return _sa_is(s, upper)\n\n\ndef lcp_array(s: typing.Union[str, typing.List[int]],\n              sa: typing.List[int]) -> typing.List[int]:\n    '''\n    Longest-Common-Prefix computation\n    Reference:\n    T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n    Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n    Applications\n    '''\n\n    if isinstance(s, str):\n        s = [ord(c) for c in s]\n\n    n = len(s)\n    assert n >= 1\n\n    rnk = [0] * n\n    for i in range(n):\n        rnk[sa[i]] = i\n\n    lcp = [0] * (n - 1)\n    h = 0\n    for i in range(n):\n        if h > 0:\n            h -= 1\n        if rnk[i] == 0:\n            continue\n        j = sa[rnk[i] - 1]\n        while j + h < n and i + h < n:\n            if s[j + h] != s[i + h]:\n                break\n            h += 1\n        lcp[rnk[i] - 1] = h\n\n    return lcp\n\n\ndef z_algorithm(s: typing.Union[str, typing.List[int]]) -> typing.List[int]:\n    '''\n    Z algorithm\n    Reference:\n    D. Gusfield,\n    Algorithms on Strings, Trees, and Sequences: Computer Science and\n    Computational Biology\n    '''\n\n    if isinstance(s, str):\n        s = [ord(c) for c in s]\n\n    n = len(s)\n    if n == 0:\n        return []\n\n    z = [0] * n\n    j = 0\n    for i in range(1, n):\n        z[i] = 0 if j + z[j] <= i else min(j + z[j] - i, z[i - j])\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if j + z[j] < i + z[i]:\n            j = i\n    z[0] = n\n\n    return z"),
    'lib.transform': (False, 'from cmath import rect, pi\nfrom lib.misc import reverse_bits32\nfrom lib.number_theory import totient_factors, primitive_root, modinv, modpow\nfrom typing import List, TypeVar, Callable\n\nM = TypeVar(\'M\')\n\n\ndef fft(a: List[float], inverse=False):\n    one = complex(1.0)\n    n = (len(a) - 1).bit_length()\n    m = 2 ** n\n    a += [complex(0.0)] * (m - len(a))\n    pows = [rect(1.0, (-pi if inverse else pi) / (2 ** (n - 1)))]\n    for _ in range(n - 1):\n        pows.append(pows[-1] ** 2)\n    pows.reverse()\n\n    shift = 32 - n\n    for i in range(m):\n        j = reverse_bits32(i) >> shift\n        if i < j:\n            a[i], a[j] = a[j], a[i]\n\n    for i in range(m):\n        b = 1\n        for w1 in pows:\n            if not i & b:\n                break\n            i ^= b\n            w = one\n            while not i & b:\n                s = a[i]\n                t = a[i | b] * w\n                a[i] = s + t\n                a[i | b] = s - t\n                w *= w1\n                i += 1\n            i ^= b\n            b <<= 1\n    if inverse:\n        c = 1 / m\n        for i in range(m):\n            a[i] *= c\n    return a\n\n\ndef ntt(a: List[int], mod: int, inverse: bool = False):\n    if type(a[0]) is not int:\n        for i, v in enumerate(a):\n            a[i] = int(v)\n    n = (len(a) - 1).bit_length()\n    d2 = 0\n    r = 1\n    phi_factors = tuple(totient_factors(mod))\n    for p in phi_factors:\n        if p == 2:\n            d2 += 1\n        else:\n            r *= p\n    if d2 < n:\n        raise ValueError(f\'Given array is too long: modulo {mod} only support array length up to {2 ** d2}\')\n\n    pr = primitive_root(mod, phi_factors)\n    if inverse:\n        pr = modinv(pr, mod)\n    pows = [modpow(pr, r * 2 ** (d2 - n), mod)]\n    for _ in range(n - 1):\n        pows.append(pows[-1] ** 2 % mod)\n    pows = tuple(reversed(pows))\n\n    m = 2 ** n\n    a.extend(0 for _ in  range(m - len(a)))\n\n    shift = 32 - n\n    for i in range(m):\n        j = reverse_bits32(i) >> shift\n        if i < j:\n            a[i], a[j] = a[j], a[i]\n\n    for i in range(m):\n        b = 1\n        for w1 in pows:\n            if not i & b:\n                break\n            i ^= b\n            w = 1\n            while not i & b:\n                j = i | b\n                s = a[i]\n                t = a[j] * w\n                a[i] = (s + t) % mod\n                a[j] = (s - t) % mod\n                w = (w * w1) % mod\n                i += 1\n            i ^= b\n            b <<= 1\n\n    if inverse:\n        c = modinv(m, mod)\n        for i, v in enumerate(a):\n            a[i] = (v * c) % mod\n    return a\n\n\ndef zeta(data: List[M], operator: Callable[[M, M], M]) -> List[M]:\n    r"""\n    ??????data????????\n\n    ``M`` ?????\n\n    ``ouput[i] = sum(data[j] : i|j == i)``\n\n    ???: ``O(N * log N)``\n\n    ?:\n\n    ``zeta(data, add)``: ???????????\n\n    ``zeta(data, sub)``: ?????????????????\n\n    ??->??->???: ``output[k] = sum(a[i]*b[j] : i|j == k)``\n    """\n    n = len(data)\n    i = 1\n    while i < n:\n        for j in range(n):\n            if j & i != 0:\n                data[j] = operator(data[j], data[j ^ i])\n        i <<= 1\n    return data\n\n\ndef zeta_divisors(data: List[M], operator: Callable[[M, M], M]) -> List[M]:\n    r"""\n    ??????data????????\n\n    ``M`` ?????\n\n    ``ouput[i] = sum(data[j] for j in range(N) if j?i???)``\n\n    ???: ``O(N * log log N)``\n\n    ?:\n\n    ``zeta_divisors(data, add)``: ?????????\n\n    ``mobius_divisors(data, sub)``: ???????????????\n\n    ??->??->???: ``output[k] = sum(a[i]*b[j] : lcm(i,j) == k)``\n    """\n    n = len(data)\n    sieve = [0] * len(data)\n    for p in range(2, n):\n        if not sieve[p]:\n            for a, b in zip(range(1, n), range(p, n, p)):\n                sieve[b] = 1\n                data[b] = operator(data[b], data[a])\n    return data\n\n\ndef mobius_divisors(data: List[M], operator: Callable[[M, M], M]) -> List[M]:\n    r"""\n    ??????data????????\n\n    ``zeta_divisors`` ????\n    """\n    n = len(data)\n    sieve = [0] * len(data)\n    for p in range(2, n):\n        if not sieve[p]:\n            t = (n - 1) // p\n            for a, b in zip(range(t, 0, -1), range(t * p, 0, -p)):\n                sieve[b] = 1\n                data[b] = operator(data[b], data[a])\n    return data\n\n\ndef zeta_multiples(data: List[M], operator: Callable[[M, M], M]) -> List[M]:\n    r"""\n    ??????data????????\n\n    ``M`` ?????\n\n    ``ouput[i] = sum(data[j] for j in range(N) if j?i???)``\n\n    ???: ``O(N * log log N)``\n\n    ?:\n\n    ``zeta_multiple(data, add)``: ?????????\n\n    ``mobius_multiples(data, sub)``: ???????????????\n\n    ??->??->???: ``output[k] = sum(a[i]*b[j] : gcd(i,j) == k)``\n    """\n    n = len(data)\n    sieve = [0] * len(data)\n    for p in range(2, n):\n        if not sieve[p]:\n            t = (n - 1) // p\n            for a, b in zip(range(t, 0, -1), range(t * p, 0, -p)):\n                sieve[b] = 1\n                data[a] = operator(data[a], data[b])\n    return data\n\n\ndef mobius_multiples(data: List[M], operator: Callable[[M, M], M]) -> List[M]:\n    r"""\n    ??????data????????\n\n    ``zeta_multiples`` ????\n    """\n    n = len(data)\n    sieve = [0] * len(data)\n    for p in range(2, n):\n        if not sieve[p]:\n            for a, b in zip(range(1, n), range(p, n, p)):\n                sieve[b] = 1\n                data[a] = operator(data[a], data[b])\n    return data\n'),
    'lib.tree': (False, 'from lib.graph import BaseGraph, Graph\nfrom typing import *\nimport itertools\nimport random\nfrom lib.array2d import Array2d\n\n\nT = TypeVar(\'T\')\n\n\nclass BaseRootedTree(BaseGraph):\n\n    def __init__(self, n_vertices, root_vertex=0):\n        super().__init__(n_vertices)\n        self.root = root_vertex\n\n    def parent(self, v: int) -> int:\n        raise NotImplementedError\n\n    def children(self, v: int) -> Iterable[int]:\n        raise NotImplementedError\n\n    def adj(self, v) -> Iterable[int]:\n        if self.root == v:\n            return self.children(v)\n        return itertools.chain(self.children(v), (self.parent(v),))\n\n    def post_order(self) -> Iterable[int]:\n        """\n        bottom vertices first\n        """\n        return (~v for v in self.prepost_order() if v < 0)\n\n    def pre_order(self) -> Iterable[int]:\n        """\n        top vertices first\n        """\n        stack = [self.root]\n        while stack:\n            v = stack.pop()\n            yield v\n            for u in self.children(v):\n                stack.append(u)\n\n    def prepost_order(self) -> Iterable[int]:\n        """\n        if v >= 0: it\'s pre-order entry.\n\n        otherwise: it\'s post-order entry.\n        """\n        stack = [~self.root, self.root]\n        while stack:\n            v = stack.pop()\n            yield v\n            if v >= 0:\n                for u in self.children(v):\n                    stack.append(~u)\n                    stack.append(u)\n\n    def prepost_indices(self, order=None) -> Tuple[List[int], List[int]]:\n        if order is None:\n            order = self.prepost_order()\n        pre_ind = [0] * self.n_vertices\n        post_ind = [0] * self.n_vertices\n        for i, t in enumerate(order):\n            if t >= 0:\n                pre_ind[t] = i\n            else:\n                post_ind[~t] = i\n        return pre_ind, post_ind\n\n    def depth(self) -> List[int]:\n        depth = [0] * self.n_vertices\n        for v in self.pre_order():\n            d = depth[v]\n            for c in self.children(v):\n                depth[c] = d + 1\n        return depth\n\n    def sort_edge_values(self, wedges: Iterable[Tuple[int, int, T]], default: Optional[T] = None) -> List[T]:\n        memo = [default] * self.n_vertices\n        for u, v, d in wedges:\n            if self.parent(u) == v:\n                memo[u] = d\n            else:\n                memo[v] = d\n        return memo\n\n    def height(self, depth_list: Optional[List[int]] = None) -> int:\n        if depth_list is None:\n            depth_list = self.depth()\n        return max(depth_list) + 1\n\n    def path_to_ancestor(self, v: int, k: int) -> List[int]:\n        """\n        ??v??k???????????.\n\n        :param v: ??\n        :param k: ??????????\n        :return: ??\n        """\n        res = [-1] * (k + 1)\n        for i in range(k + 1):\n            res[i] = v\n            v = self.parent(v)\n            if v < 0:\n                break\n        return res\n\n    def path(self, s: int, t: int, depth_list: Optional[List[int]] = None) -> List[int]:\n        """\n        ??s????t?????????\n\n        :param s: ??\n        :param t: ??\n        :param depth_list: ?????????\u3000(optional)\n        :return: ??\n        """\n        if s == t:\n            return [s]\n        if depth_list:\n            d1 = depth_list[s]\n            d2 = depth_list[t]\n        else:\n            d1 = 0\n            v = s\n            while v >= 0:\n                v = self.parent(v)\n                d1 += 1\n            d2 = 0\n            v = t\n            while v >= 0:\n                v = self.parent(v)\n                d2 += 1\n        p1 = [s]\n        p2 = [t]\n        if d1 > d2:\n            for _ in range(d1 - d2):\n                p1.append(self.parent(p1[-1]))\n        else:\n            for _ in range(d2 - d1):\n                p2.append(self.parent(p2[-1]))\n        while p1[-1] != p2[-1]:\n            p1.append(self.parent(p1[-1]))\n            p2.append(self.parent(p2[-1]))\n        p2.pop()\n        p1.extend(reversed(p2))\n        return p1\n\n    def aggregate_root_path(self, aggregate: Callable[[T, int], T], identity: T,\n                              pre_order: Optional[Iterable[int]] = None) -> List[T]:\n        """\n        ????????????dp??????.\n\n        :param aggregate: (T, V) -> T\n        :param identity: ???\n        :param pre_order: pre_order????\n        :return ?????????????dp?\n        """\n        if pre_order is None:\n            pre_order = self.pre_order()\n\n        dp = [identity] * self.n_vertices\n        for v in pre_order:\n            p = self.parent(v)\n            if p >= 0:\n                dp[v] = aggregate(dp[p], v)\n        return dp\n\n    def aggregate_subtree(self, merge: Callable[[int, Callable[[None], Iterator[T]]], T],\n                          post_order: Optional[Iterable[int]] = None) -> List[T]:\n        """\n        ???????????????dp??????.\n\n        :param merge: (vertex, Iterable(T)) -> T, (T, merge)?????\n        :param post_order: post_order????\n        :return ???????????????????dp?\n        """\n        if post_order is None:\n            post_order = self.post_order()\n\n        dp = [None] * self.n_vertices\n        for v in post_order:\n            dp[v] = merge(v, lambda: (dp[u] for u in self.children(v)))\n        return dp\n\n    def solve_rerooting(self, merge: Callable[[T, T, int], T], identity: T, finalize: Callable[[T, int, int], T],\n                        pre_order: Optional[Iterable[int]] = None) -> List[T]:\n        """\n        ????dp????\n\n        dp[u,v] = finalize(merge(dp[v,k] for k in adj[v] if k != u, v), u, v)\n\n        (v?????u?????????????????)\n\n        :param merge: (T, T, V) -> T, (T, merge)?????\n        :param identity: ???\n        :param finalize: (T, V, V) -> T\n        :param pre_order: pre_order????\n        :return ???????????????dp?\n        """\n\n        if pre_order is None:\n            pre_order = list(self.pre_order())\n        dp1 = [identity] * self.n_vertices\n        dp2 = [identity] * self.n_vertices\n\n        for v in reversed(pre_order):\n            t = identity\n            for u in self.children(v):\n                dp2[u] = t\n                t = merge(t, finalize(dp1[u], v, u), v)\n            t = identity\n            for u in reversed(list(self.children(v))):\n                dp2[u] = merge(t, dp2[u], v)\n                t = merge(t, finalize(dp1[u], v, u), v)\n            dp1[v] = t\n        for v in pre_order:\n            if v == self.root:\n                continue\n            p = self.parent(v)\n            dp2[v] = finalize(merge(dp2[v], dp2[p], v), v, p)\n            dp1[v] = merge(dp1[v], dp2[v], v)\n        return dp1\n\n    def subtree_sizes(self, post_order: Optional[Iterable[int]] = None):\n        def merge(v, values):\n            return sum(values)+1\n        return self.aggregate_subtree(merge, post_order)\n\n    def get_doubling_strategy(self):\n        return DoublingStrategy(self)\n\n\nclass DoublingStrategy:\n    def __init__(self, tree: BaseRootedTree, depth=None, pre_order=None):\n        if pre_order is None:\n            pre_order = tree.pre_order()\n        if depth is None:\n            depth = tree.depth()\n        self.depth = depth\n        self.tree = tree\n        d = (max(depth) + 1).bit_length()\n        dbl = Array2d.full(tree.n_vertices, d, -1)\n        for v in pre_order:\n            u = tree.parent(v)\n            dbl[v, 0] = u\n            for i in range(d - 1):\n                u = dbl[u, i]\n                if u < 0:\n                    break\n                dbl[v, i + 1] = u\n        self.dbl = dbl\n\n    def ancestor_of(self, v: int, k: int) -> int:\n        if k > self.depth[v]:\n            return -1\n        i = 0\n        while k:\n            if k & 1:\n                v = self.dbl[v, i]\n            k //= 2\n            i += 1\n        return v\n\n    def lca(self, u: int, v: int) -> int:\n        lu, lv = self.depth[u], self.depth[v]\n        if lu > lv:\n            u = self.ancestor_of(u, lu - lv)\n        else:\n            v = self.ancestor_of(v, lv - lu)\n        if u == v:\n            return u\n\n        i = self.dbl.m - 1\n        while True:\n            while i >= 0 and self.dbl[u, i] == self.dbl[v, i]:\n                i -= 1\n            if i < 0:\n                return self.dbl[u, 0]\n            u, v = self.dbl[u, i], self.dbl[v, i]\n\n    def dist(self, u: int, v: int) -> int:\n        return self.depth[u] + self.depth[v] - 2 * self.depth[self.lca(u, v)]\n\n\nclass RootedTree(BaseRootedTree):\n\n    def __init__(self, parent: List[int], children: Graph, root_vertex: int):\n        super().__init__(len(parent), root_vertex)\n        self._parent = parent\n        self._children = children\n\n    @classmethod\n    def from_edges(cls, edges, root_vertex=0):\n        n = len(edges) + 1\n        g = Graph.from_undirected_edges(n, edges)\n        parent = [0] * n\n        parent[root_vertex] = -1\n        stack = [root_vertex]\n        while stack:\n            v = stack.pop()\n            p = parent[v]\n            for u in g.adj(v):\n                if u != p:\n                    parent[u] = v\n                    stack.append(u)\n        return cls.from_parent(parent, root_vertex)\n\n    @classmethod\n    def from_parent(cls, parent, root_vertex=0):\n        return cls(parent,\n                   Graph.from_directed_edges(len(parent), ((p, v) for v, p in enumerate(parent) if p >= 0)),\n                   root_vertex)\n\n    @classmethod\n    def random(cls, n_vertices, root_vertex=0):\n        parent = [-1] * n_vertices\n        vertices = list(range(root_vertex)) + list(range(root_vertex + 1, n_vertices))\n        random.shuffle(vertices)\n        vertices.append(root_vertex)\n        for i, v in zip(reversed(range(n_vertices)), vertices[-2::-1]):\n            parent[v] = vertices[random.randrange(i, n_vertices)]\n        return cls.from_parent(parent, root_vertex)\n\n    def parent(self, v):\n        return self._parent[v]\n\n    def children(self, v):\n        return self._children.adj(v)\n\n\nclass BinaryTrie:\n    class Node:\n        def __init__(self):\n            self.zero = None\n            self.one = None\n            self.cnt = 0\n\n    def __init__(self, bits):\n        self.root = self.Node()\n        self.bits = bits\n\n    def add(self, v):\n        n = self.root\n        n.cnt += 1\n        for d in reversed(range(self.bits)):\n            if (v >> d) & 1:\n                if not n.one:\n                    n.one = BinaryTrie.Node()\n                n = n.one\n            else:\n                if not n.zero:\n                    n.zero = BinaryTrie.Node()\n                n = n.zero\n            n.cnt += 1\n        return n\n\n    def remove(self, v):\n        n = self.root\n        n.cnt -= 1\n        for d in reversed(range(self.bits)):\n            if (v >> d) & 1:\n                n = n.one\n            else:\n                n = n.zero\n            n.cnt -= 1\n        return n\n\n    def find_argminxor(self, v):\n        n = self.root\n        r = 0\n        for d in reversed(range(self.bits)):\n            if (v >> d) & 1:\n                if n.one and n.one.cnt > 0:\n                    n = n.one\n                    r |= 1 << d\n                else:\n                    n = n.zero\n            else:\n                if n.zero and n.zero.cnt > 0:\n                    n = n.zero\n                else:\n                    n = n.one\n                    r |= 1 << d\n        return r\n\n    def find_nth(self):\n        raise NotImplementedError\n\n    def __contains__(self, v):\n        n = self.root\n        for d in reversed(range(self.bits)):\n            if (v >> d) & 1:\n                n = n.one\n            else:\n                n = n.zero\n            if not n or n.cnt == 0:\n                return False\n        return True\n\n\nclass Trie(BaseRootedTree):\n\n    def __init__(self, n_alphabets: int):\n        super().__init__(1)\n        self.n_alphabets = n_alphabets\n        self._parent = [-1]\n        self.end = [0]\n        self._children = [[-1]*n_alphabets]\n\n    def add(self, s):\n        v = 0\n        for c in s:\n            u = self._children[v][c]\n            if u < 0:\n                self._parent.append(v)\n                self.end.append(0)\n                self._children[v][c] = self.n_vertices\n                self._children.append([-1]*self.n_alphabets)\n                self.n_vertices += 1\n            v = self._children[v][c]\n        self.end[v] = 1\n        return v\n\n    def parent(self, v: int) -> int:\n        return self._parent[v]\n\n    def children(self, v):\n        return (self._children[v][c] for c in range(self.n_alphabets) if self._children[v][c] >= 0)'),
    'lib._modint': (False, 'from lib.number_theory import modinv, modpow\n\nintadd = int.__add__\nintsub = int.__sub__\nintmul = int.__mul__\n\n\nclass ModInt(int):\n    mod = MOD\n\n    @classmethod\n    def v(cls, v):\n        return ModInt(v % MOD)\n\n    def __neg__(self):\n        return ModInt(intsub(MOD, self) if self != 0 else 0)\n\n    def __add__(self, other):\n        x = intadd(self, other)\n        return ModInt(x if x < MOD else x - MOD)\n\n    def __sub__(self, other):\n        x = intsub(self, other)\n        return ModInt(x if x >= 0 else x + MOD)\n\n    def __rsub__(self, other):\n        x = intsub(other, self)\n        return ModInt(x if x >= 0 else x + MOD)\n\n    def __mul__(self, other):\n        return ModInt(intmul(self, other) % MOD)\n\n    def __truediv__(self, other):\n        return self * ModInt(other).inv\n\n    def __rtruediv__(self, other):\n        return self.inv * other\n\n    __radd__ = __add__\n    __rmul__ = __mul__\n    __floordiv__ = __truediv__\n    __rfloordiv__ = __rtruediv__\n\n    def __pow__(self, other, **kwargs):\n        return ModInt(modpow(int(self), int(other), MOD))\n\n    @property\n    def inv(self):\n        return ModInt(modinv(int(self), MOD))\n\n    @classmethod\n    def sum(cls, iterable):\n        r = 0\n        for v in iterable:\n            r += int(v)\n        return ModInt(r)\n\n    @classmethod\n    def product(cls, iterable):\n        r = ModInt(1)\n        for v in iterable:\n            r *= v\n        return r\n'),
    'lib': (True, ''),
}
_sys.meta_path.insert(2, InlineImporter)

# Entrypoint
from collections import defaultdict
from lib.data_structure import SegmentTree, BinaryIndexedTree
from lib.misc import min2

q = int(input())
queries = [tuple(map(int,input().split())) for _ in range(q)]


i2v = sorted(set(tokens[1] for tokens in queries if tokens[0] < 3))
v2i = {v:i for i,v in enumerate(i2v)}
bit = BinaryIndexedTree(len(i2v))
memo = defaultdict(int)
seg = SegmentTree.all_identity(min2, 2**30, len(i2v))
dup_cnt = 0

for tokens in queries:
    if tokens[0] == 1:
        x = tokens[1]
        if memo[x] == 0:
            i = v2i[x]
            s = bit[:i]
            l = bit.bisect_left(s) if s > 0 else -1
            if 0<=l:
                seg[l] = i2v[l]^x
            r = bit.bisect_right(s)
            if r < len(i2v):
                seg[i] = i2v[r]^x
            bit[i] += 1
        else:
            dup_cnt += 1
        memo[x] += 1
    elif tokens[0] == 2:
        x = tokens[1]
        if memo[x] == 1:
            i = v2i[x]
            bit[i] -= 1
            seg[i] = 2**30
            s = bit[:i]
            l = bit.bisect_left(s) if s > 0 else -1
            r = bit.bisect_right(s)
            if 0<=l:
                if r < len(i2v):
                    seg[l] = i2v[l]^i2v[r]
                else:
                    seg[l] = 2**30
        elif memo[x] == 2:
            dup_cnt -= 1
        memo[x] -= 1
    else:
        print(seg[:] if dup_cnt == 0 else 0)