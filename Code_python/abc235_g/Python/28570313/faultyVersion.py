# InlineImporter
import os as _os
import sys as _sys
from functools import lru_cache as _lru_cache
from importlib.abc import ExecutionLoader, MetaPathFinder
from importlib.machinery import ModuleSpec


class InlineImporter(ExecutionLoader, MetaPathFinder):

    version = None
    inlined_modules = {}
    namespace_packages = False

    @classmethod
    def find_spec(cls, fullname, path=None, target=None):
        """Find a spec for a given module.
        
        Because we only deal with our inlined module, we don't have to care about path or target.
        The import machinery also takes care of fully resolving all names, so we just have to deal with the fullnames.
        """
        if fullname in cls.inlined_modules:
            # We have inlined this module, so return the spec
            ms = ModuleSpec(fullname, cls, origin=cls.get_filename(fullname), is_package=cls.is_package(fullname))
            ms.has_location = True
            if cls.namespace_packages and ms.submodule_search_locations is not None:
                for p in _sys.path:
                    ms.submodule_search_locations.append(_os.path.join(p, _os.path.dirname(ms.origin)))
            return ms

        return None

    @staticmethod
    def _call_with_frames_removed(f, *args, **kwds):
        """remove_importlib_frames in import.c will always remove sequences
        of importlib frames that end with a call to this function

        Use it instead of a normal call in places where including the importlib
        frames introduces unwanted noise into the traceback (e.g. when executing
        module code)
        """
        return f(*args, **kwds)

    @classmethod
    def create_module(cls, spec):
        """Create a module using the default machinery."""
        return None

    @classmethod
    def exec_module(cls, module):
        """Execute the module."""
        code = cls.get_code(module.__name__)
        if code is None:
            raise ImportError("cannot load module {!r} when get_code() returns None".format(module.__name__))
        cls._call_with_frames_removed(exec, code, module.__dict__)

    @classmethod
    @_lru_cache(maxsize=None)
    def get_filename(cls, fullname):
        """Returns the 

        Raises ImportError if the module cannot be found.
        """
        if fullname not in cls.inlined_modules:
            raise ImportError

        mod = cls.inlined_modules[fullname]
        origin = fullname
        if mod[0]:
            origin = ".".join([origin, "__init__"])
        origin = ".".join([origin.replace(".", "/"), "py"])

        return origin

    @classmethod
    @_lru_cache(maxsize=None)
    def is_package(cls, fullname):
        if fullname not in cls.inlined_modules:
            raise ImportError

        return cls.inlined_modules[fullname][0]

    @classmethod
    def get_source(cls, fullname):
        if fullname not in cls.inlined_modules:
            raise ImportError

        return cls.inlined_modules[fullname][1]

    @classmethod
    def get_code(cls, fullname):
        """Method to return the code object for fullname.

        Should return None if not applicable (e.g. built-in module).
        Raise ImportError if the module cannot be found.
        """
        source = cls.get_source(fullname)
        if source is None:
            return None
        try:
            path = cls.get_filename(fullname)
        except ImportError:
            return cls.source_to_code(source)
        else:
            return cls.source_to_code(source, path)


InlineImporter.version = '0.0.4'
InlineImporter.inlined_modules = {
    'lib.array2d': (False, "class Array2dView:\n    def __init__(self, arr, i_indices, j_indices):\n        self.arr = arr\n        self.i_indices = i_indices\n        self.j_indices = j_indices\n    \n    def _get_view(self, i, j):\n        i = self.i_indices[i]\n        j = self.j_indices[j]\n        return Array2dView(self.arr, i, j)\n\n    def get_ind(self, i, j):\n        return self.i_indices[i]+self.j_indices[j]\n    \n    def __getitem__(self, index):\n        i, j = index\n        try:\n            return self.arr[self.get_ind(i,j)]\n        except TypeError:\n            return self._get_view(i, j)\n    \n    def __setitem__(self, index, value):\n        i, j = index\n        try:\n            self.arr[self.get_ind(i,j)] = value\n        except TypeError:\n            x = self._get_view(i, j)\n            for i in x.i_indices:\n                for j in x.j_indices:\n                    self.arr[i+j] = value\n    \n    def __iter__(self):\n        for i in self.i_indices:\n            for j in self.j_indices:\n                yield self.arr[i+j]\n    \n    def __reversed__(self):\n        for i in reversed(self.i_indices):\n            for j in reversed(self.j_indices):\n                yield self.arr[i+j]\n    \n    def __str__(self):\n        m = max(len(str(v)) for v in self)\n        res = ['']*len(self.i_indices)\n        row = ['']*(len(self.j_indices)+2)\n        for ri,i in enumerate(self.i_indices):\n            if ri == 0:\n                row[0] = '['\n            else:\n                row[0] = ' '\n            if ri == len(self.i_indices)-1:\n                row[-1] = ']\\n'\n            for rj,j in enumerate(self.j_indices):\n                row[rj+1] = f'{str(self.arr[i+j]):>{m+1}}'\n            res[ri] = ''.join(row)\n        return '\\n'.join(res)\n    \n    def copy(self):\n        return Array2d(len(self.i_indices), len(self.j_indices), list(self))\n\n\nclass Array2d:\n    def __init__(self, n, m, arr):\n        self.n = n\n        self.m = m\n        self.arr = arr\n    \n    @classmethod\n    def full(cls, n, m, fill_value):\n        return cls(n, m, [fill_value]*(n*m))\n    \n    @classmethod\n    def from_list(cls, lst):\n        n,m = len(lst), len(lst[0])\n        arr = [lst[0]]*(n*m)\n        k = 0\n        for row in lst:\n            for v in row:\n                arr[k] = v\n                k += 1\n        return cls(n, m, arr)\n    \n    def _get_view(self, i, j):\n        i = tuple(range(0, self.n*self.m, self.m))[i]\n        j = tuple(range(self.m))[j]\n        return Array2dView(self.arr, i, j)\n\n    def get_ind(self, i, j):\n        return i*self.m+j\n\n    def __getitem__(self, index):\n        try:\n            return self.arr[self.get_ind(*index)]\n        except TypeError:\n            return self._get_view(*index)\n    \n    def __setitem__(self, index, value):\n        try:\n            self.arr[self.get_ind(*index)] = value\n        except TypeError:\n            x = self._get_view(*index)\n            for i in x.i_indices:\n                for j in x.j_indices:\n                    self.arr[i+j] = value\n    \n    def __iter__(self):\n        return iter(self.arr)\n    \n    def __reversed__(self):\n        return reversed(self.arr)\n    \n    def __str__(self):\n        m = max(len(str(v)) for v in self)\n        res = ['']*self.n\n        row = ['']*(self.m+2)\n        for i in range(self.n):\n            if i == 0:\n                row[0] = '['\n            else:\n                row[0] = ' '\n            if i == self.n-1:\n                row[-1] = ']\\n'\n            for j in range(self.m):\n                row[j+1] = f'{str(self.arr[i*self.m+j]):>{m+1}}'\n            res[i] = ''.join(row)\n        return '\\n'.join(res)\n\n    def __eq__(self, other):\n        return self.arr == other.arr\n\n    def copy(self):\n        return self.__class__(self.n, self.m, self.arr[:])\n\n    @property\n    def t(self):\n        arr = [self.arr[0]]*(len(self.arr))\n        x = 0\n        for i in range(self.n):\n            for j in range(self.m):\n                arr[j*self.n + i] = self.arr[x]\n                x += 1\n        return self.__class__(self.m, self.n, arr)\n"),
    'lib.array3d': (False, 'class Array3d(list):\n    def __init__(self, n, m, p, arr):\n        list.__init__(self, arr)\n        self.n = n\n        self.m = m\n        self.p = p\n        self.mp = m*p\n\n    @classmethod\n    def full(cls, n, m, p, fill_value):\n        return cls(n, m, p, [fill_value] * (n * m * p))\n\n    def get_ind(self, i, j, k):\n        return i * self.mp + j * self.p + k\n\n    def __getitem__(self, index):\n        return list.__getitem__(self, self.get_ind(*index))\n\n    def __setitem__(self, index, value):\n        list.__setitem__(self, self.get_ind(*index), value)\n'),
    'lib.benchmark': (False, '\nfrom time import perf_counter as timer\ndef simple_timeit(func, repeat=1000, warmup=100):\n    for i in range(warmup):\n        func(i)\n    start = timer()\n    for i in range(repeat):\n        func(i)\n    stop = timer()\n    return stop-start\n'),
    'lib.data_structure': (False, 'from itertools import repeat\n\n\nclass DisjointSet:\n    def __init__(self, parent):\n        self.parent = parent\n\n    @classmethod\n    def empty(cls, size):\n        return cls([-1]*size)\n\n    def find(self, x):\n        stack = []\n        while self.parent[x] >= 0:\n            stack.append(x)\n            x = self.parent[x]\n        for y in stack:\n            self.parent[y] = x\n        return x\n\n    def union_reps(self, xr, yr):\n        if xr == yr:\n            return\n        if self.parent[xr] > self.parent[yr]:\n            xr, yr = yr, xr\n        self.parent[xr] += self.parent[yr]\n        self.parent[yr] = xr\n\n    def union(self, x, y):\n        self.union_reps(self.find(x), self.find(y))\n\n    def group_size(self, x):\n        return -self.parent[self.find(x)]\n\n    def is_rep(self, x):\n        return self.parent[x] < 0\n\n\nclass SegmentTree:\n    """\n    ???????????????????????????????????\n    ???????????????????????????(???????????)\n    """\n\n    @classmethod\n    def all_identity(cls, operator, identity, size):\n        return cls(operator, identity, [identity] * (2 << (size - 1).bit_length()))\n\n    @classmethod\n    def from_initial_data(cls, operator, identity, data):\n        size = 1 << (len(data) - 1).bit_length()\n        temp = [identity] * (2 * size)\n        temp[size:size + len(data)] = data\n        data = temp\n\n        for i in reversed(range(size)):\n            data[i] = operator(data[2 * i], data[2 * i + 1])\n        return cls(operator, identity, data)\n\n    # ??????????????????????\n    def __init__(self, operator, identity, data):\n        self.op = operator\n        self.id = identity\n        self.data = data\n        self.size = len(data) // 2\n\n    def reduce(self, l, r):\n        l += self.size\n        r += self.size\n        vl = self.id\n        vr = self.id\n\n        while l < r:\n            if l & 1:\n                vl = self.op(vl, self.data[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                vr = self.op(self.data[r], vr)\n            l >>= 1\n            r >>= 1\n        return self.op(vl, vr)\n\n    def elements(self, l, r):\n        l += self.size\n        r += self.size\n\n        lefts = []\n        rights = []\n\n        while l < r:\n            if l & 1:\n                lefts.append(self.data[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                rights.append(self.data[r])\n            l >>= 1\n            r >>= 1\n        return lefts, rights\n\n    def __getitem__(self, i):\n        if isinstance(i, slice):\n            return self.reduce(\n                0 if i.start is None else i.start,\n                self.size if i.stop is None else i.stop)\n        elif isinstance(i, int):\n            return self.data[i + self.size]\n\n    def __setitem__(self, i, v):\n        i += self.size\n        while i:\n            self.data[i] = v\n            v = self.op(self.data[i ^ 1], v) if i & 1 else self.op(v, self.data[i ^ 1])\n            i >>= 1\n\n    def __iter__(self):\n        return iter(self.data[self.size:])\n\n\nclass LazySegmentTree:\n    """\n    op: ????????reduce?????????\n    apply: ??????\n    comp: ??????\n    \n    range_query: reduce(op, (apply(x,m) for x,m in zip(X,M)))\n    \n    ???????:\n    \n    ??X (??)\n    op[+]: X,X -> X\n    (X, op)?????\n    \n    ??M (???)\n    comp[*]: M,M -> M\n    (M, compose)?????\n    \n    apply[f(x,m,n)]: X,M,Z+ -> X\n    (Z+????)\n    \n    f(x,e_M,n) = x\n    f(x,m*n,p) = f(f(x,m,p),n,p)\n    f(x,m,p)+f(y,m,q) = f(x+y,m,p+q)\n    \n    ??: https://algo-logic.info/segment-tree/#toc_id_3\n    """\n\n    @classmethod\n    def all_identity(cls, op, op_e, comp, comp_e, apply, size):\n        size = 1 << (size - 1).bit_length()\n        return cls(\n            op,\n            op_e,\n            comp,\n            comp_e,\n            apply,\n            [op_e] * (2 * size),\n            [comp_e] * size\n        )\n\n    @classmethod\n    def from_initial_data(cls, op, op_e, comp, comp_e, apply, data):\n        size = 1 << (len(data) - 1).bit_length()\n        temp = [op_e] * (2 * size)\n        temp[size:size + len(data)] = data\n\n        for i in reversed(range(size)):\n            temp[i] = op(temp[2 * i], temp[2 * i + 1])\n        return cls(\n            op,\n            op_e,\n            comp,\n            comp_e,\n            apply,\n            temp,\n            [comp_e] * size\n        )\n\n    # ??????????????????????\n    def __init__(self, op, op_e, comp, comp_e, apply, data, lazy):\n        self.op = op\n        self.op_e = op_e\n        self.comp = comp\n        self.comp_e = comp_e\n        self.apply = apply\n        self.data = data\n        self.lazy = lazy\n        self.size = len(self.data) // 2\n        self.depth = self.size.bit_length() - 1\n        self._l_indices = [0] * self.depth\n        self._r_indices = [0] * self.depth\n\n    def _update_indices(self, i, l):\n        m = i // (i & -i)\n        i >>= 1\n        for k in range(self.depth):\n            l[k] = i if i < m else 0\n            i >>= 1\n\n    def _propagate_top_down(self):\n        data = self.data\n        lazy = self.lazy\n        apply = self.apply\n        comp = self.comp\n        comp_e = self.comp_e\n        k = self.size >> 1\n\n        for i, j in zip(reversed(self._l_indices), reversed(self._r_indices)):\n            if i > 0:\n                temp = lazy[i]\n                if temp != comp_e:\n                    lazy[i] = comp_e\n                    a = i << 1\n                    b = a | 1\n                    data[a] = apply(data[a], temp, k)\n                    data[b] = apply(data[b], temp, k)\n                    if k > 1:\n                        lazy[a] = comp(lazy[a], temp)\n                        lazy[b] = comp(lazy[b], temp)\n            if i < j:\n                temp = lazy[j]\n                if temp != comp_e:\n                    lazy[j] = comp_e\n                    a = j << 1\n                    b = a | 1\n                    data[a] = apply(data[a], temp, k)\n                    data[b] = apply(data[b], temp, k)\n                    if k > 1:\n                        lazy[a] = comp(lazy[a], temp)\n                        lazy[b] = comp(lazy[b], temp)\n            k >>= 1\n\n    def _propagate_bottom_up(self):\n        data = self.data\n        op = self.op\n        for i, j in zip(self._l_indices, self._r_indices):\n            if i < j:\n                data[j] = op(data[j << 1], data[j << 1 | 1])\n            if i > 0:\n                data[i] = op(data[i << 1], data[i << 1 | 1])\n\n    def update_interval(self, l, r, m):\n        lazy = self.lazy\n        data = self.data\n        comp = self.comp\n        apply = self.apply\n\n        l += self.size\n        r += self.size\n        self._update_indices(l, self._l_indices)\n        self._update_indices(r, self._r_indices)\n        self._propagate_top_down()\n        k = 1\n        while l < r:\n            if l & 1:\n                data[l] = apply(data[l], m, k)\n                if k > 1:\n                    lazy[l] = comp(lazy[l], m)\n                l += 1\n            if r & 1:\n                r -= 1\n                data[r] = apply(data[r], m, k)\n                if k > 1:\n                    lazy[r] = comp(lazy[r], m)\n            l >>= 1\n            r >>= 1\n            k <<= 1\n        self._propagate_bottom_up()\n\n    def get_interval(self, l, r):\n        data = self.data\n        op = self.op\n\n        l += self.size\n        r += self.size\n        self._update_indices(l, self._l_indices)\n        self._update_indices(r, self._r_indices)\n        self._propagate_top_down()\n\n        lx = self.op_e\n        rx = self.op_e\n        while l < r:\n            if l & 1:\n                lx = op(lx, data[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                rx = op(data[r], rx)\n            l >>= 1\n            r >>= 1\n        return op(lx, rx)\n\n\nfrom operator import add, sub\nclass BinaryIndexedTree:\n    def __init__(self, size, zero=0, operator=add, inv_operator=sub):\n        self.zero = zero\n        self.op = operator\n        self.inv = inv_operator\n        self.data = [zero] * (size + 1)\n        self.msb = 1 << (size.bit_length() - 1)\n\n    def _add(self, i, w):\n        i += 1\n        while i < len(self.data):\n            self.data[i] = self.op(self.data[i], w)\n            i += i & -i\n\n    def _get_sum(self, i):\n        res = self.zero\n        while i > 0:\n            res = self.op(res, self.data[i])\n            i -= i & -i\n        return res\n\n    def __getitem__(self, i):\n        """\n        [0,i)\n        """\n        if isinstance(i, slice):\n            a = self._get_sum(len(self.data) - 1 if i.stop is None else i.stop)\n            b = self._get_sum(0 if i.start is None else i.start)\n            return self.inv(a, b)\n        else:\n            return self.zero  # fake value\n\n    __setitem__ = _add\n\n    def bisect_left(self, v):\n        """\n        return smallest i s.t v <= sum[:i+1]\n        """\n        i = 0\n        k = self.msb\n        l = len(self.data)\n        while k > 0:\n            i += k\n            if i < l and self.data[i] < v:\n                v -= self.data[i]\n            else:\n                i -= k\n            k >>= 1\n        return i\n\n    def bisect_right(self, v):\n        """\n        return smallest i s.t v < sum[:i+1]\n        """\n        i = 0\n        k = self.msb\n        l = len(self.data)\n        while k > 0:\n            i += k\n            if i < l and self.data[i] <= v:\n                v -= self.data[i]\n            else:\n                i -= k\n            k >>= 1\n        return i\n\n    bisect = bisect_right\n\n'),
    'lib.graph': (False, 'import itertools\nimport heapq as hq\nfrom random import randrange, shuffle\nfrom lib.misc import min2\nfrom lib.array2d import Array2d\nfrom collections import defaultdict\n\nfrom typing import Union, Iterable, Any, Tuple, List, Sequence, TypeVar, Optional, Callable\n\nT = TypeVar(\'T\')\n\nINF = 2 ** 62\n\n\nclass BaseWeightedGraph:\n\n    def __init__(self, n_vertices: int):\n        self.n_vertices = n_vertices\n\n    def wadj(self, v: int) -> Iterable[Tuple[int, Any]]:\n        """\n        Return an iterable of vertices adjacent to v and edge weight\n        """\n        raise NotImplementedError\n\n    def adj(self, v: int) -> Iterable[int]:\n        """\n        Return an iterable of vertices adjacent to v\n        """\n        return (u for u, w in self.wadj(v))\n\n    @property\n    def wedges(self) -> Iterable[Tuple[int, int, Any]]:\n        """\n        Return an iterable of weighted edges (vertex_1, vertex_2, weight)\n        """\n        return ((v, u, w) for v in range(self.n_vertices) for u, w in self.wadj(v))\n\n    @property\n    def edges(self):\n        return ((v, u) for v in range(self.n_vertices) for u in self.adj(v))\n\n    def dist(self, s: int, t: int, inf=INF):\n        return dijkstra(self, s, t, inf)[1]\n\n    def warshall_floyd(self, inf=INF):\n        dist = Array2d.full(self.n_vertices, self.n_vertices, inf)\n        for u, v, w in self.wedges:\n            dist[u, v] = w\n        for i in range(self.n_vertices):\n            dist[i, i] = 0\n        for k in range(self.n_vertices):\n            for i in range(self.n_vertices):\n                for j in range(self.n_vertices):\n                    dist[i, j] = min2(dist[i, j], dist[i, k] + dist[k, j])\n        return dist\n\n\nclass WeightedGraph(BaseWeightedGraph):\n\n    def __init__(self, n_vertices: int, adj: List[int], weight: List[Any], ind: List[int]):\n        super().__init__(n_vertices)\n        self._adj = adj\n        self._weight = weight\n        self._ind = ind\n\n    @classmethod\n    def from_lil_adj(cls, n_vertices: int, adj_list: Iterable[Sequence[Tuple[int, int]]]) -> \'WeightedGraph\':\n        n_edges = sum(len(l) for l in adj_list)\n        adj = [0] * n_edges\n        weight = [0] * n_edges\n        ind = [0] * (n_vertices + 1)\n        i = 0\n        for u, l in enumerate(adj_list):\n            ind[u] = i\n            for v, w in l:\n                adj[i] = v\n                weight[i] = w\n                i += 1\n        ind[n_vertices] = i\n        return cls(n_vertices, adj, weight, ind)\n\n    @classmethod\n    def from_directed_edges(cls, n_vertices: int, edges: Iterable[Tuple[int, int, int]]) -> \'WeightedGraph\':\n        temp = [[] for _ in range(n_vertices)]\n        for u, v, w in edges:\n            temp[u].append((v, w))\n        return cls.from_lil_adj(n_vertices, temp)\n\n    @classmethod\n    def from_undirected_edges(cls, n_vertices: int, edges: Iterable[Tuple[int, int, int]]) -> \'WeightedGraph\':\n        temp = [[] for _ in range(n_vertices)]\n        for u, v, w in edges:\n            temp[u].append((v, w))\n            temp[v].append((u, w))\n        return cls.from_lil_adj(n_vertices, temp)\n\n    def wadj(self, v):\n        i, j = self._ind[v], self._ind[v + 1]\n        return ((self._adj[k], self._weight[k]) for k in range(i, j))\n\n    def to_wgraph(self) -> \'WeightedGraph\':\n        l = [[] for _ in range(self.n_vertices)]\n        for u, v, w in self.wedges:\n            l[u].append((v, w))\n        return WeightedGraph.from_lil_adj(self.n_vertices, l)\n\n    def to_reverse_wgraph(self) -> \'WeightedGraph\':\n        l = [[] for _ in range(self.n_vertices)]\n        for u, v, w in self.wedges:\n            l[v].append((u, w))\n        return WeightedGraph.from_lil_adj(self.n_vertices, l)\n\n\nclass BaseGraph(BaseWeightedGraph):\n\n    def adj(self, v):\n        raise NotImplementedError\n\n    def wadj(self, v):\n        return ((u, 1) for u in self.adj(v))\n\n    def bfs(self, s: Union[int, Iterable[int]], t: int = -1) -> List[int]:\n        """\n        Returns a list of distance. If starts contains more than one vertex, returns the shortest distance from any of them\n        """\n        dist = [-1] * self.n_vertices\n\n        if isinstance(s, int):\n            q = [s]\n            dist[s] = 0\n        else:\n            q = list(s)\n            for v in q:\n                dist[v] = 0\n        for d in range(1, self.n_vertices):\n            nq = []\n            for v in q:\n                for u in self.adj(v):\n                    if dist[u] < 0:\n                        dist[u] = d\n                        nq.append(u)\n                    if u == t:\n                        return dist\n            q = nq\n        return dist\n\n    def dist(self, s: int, t: int, inf: Any = INF):\n        d = self.bfs(s, t)[t]\n        return inf if d == -1 else d\n\n    def to_graph(self) -> \'Graph\':\n        l = [[] for _ in range(self.n_vertices)]\n        for u, v in self.edges:\n            l[u].append(v)\n        return Graph.from_lil_adj(self.n_vertices, l)\n\n    def to_reverse_graph(self) -> \'Graph\':\n        l = [[] for _ in range(self.n_vertices)]\n        for u, v in self.edges:\n            l[v].append(u)\n        return Graph.from_lil_adj(self.n_vertices, l)\n\n\nclass Graph(BaseGraph):\n\n    def __init__(self, n_vertices: int, adj: List[int], ind: List[int]):\n        super().__init__(n_vertices)\n        self._adj = adj\n        self._ind = ind\n\n    @classmethod\n    def from_lil_adj(cls, n_vertices: int, adj_list: Iterable[Sequence[int]]) -> \'Graph\':\n        n_edges = sum(len(l) for l in adj_list)\n        adj = [0] * n_edges\n        ind = [0] * (n_vertices + 1)\n        i = 0\n        for u, l in enumerate(adj_list):\n            ind[u] = i\n            for v in l:\n                adj[i] = v\n                i += 1\n        ind[n_vertices] = i\n        return cls(n_vertices, adj, ind)\n\n    @classmethod\n    def from_directed_edges(cls, n_vertices: int, edges: Iterable[Tuple[int, int]]) -> \'Graph\':\n        temp = [[] for _ in range(n_vertices)]\n        for u, v in edges:\n            temp[u].append(v)\n        return cls.from_lil_adj(n_vertices, temp)\n\n    @classmethod\n    def from_undirected_edges(cls, n_vertices: int, edges: Iterable[Tuple[int, int]]) -> \'Graph\':\n        temp = [[] for _ in range(n_vertices)]\n        for u, v in edges:\n            temp[u].append(v)\n            temp[v].append(u)\n        return cls.from_lil_adj(n_vertices, temp)\n\n    def adj(self, v):\n        return self._adj[self._ind[v]: self._ind[v + 1]]\n\n\nclass BaseRootedTree(BaseGraph):\n\n    def __init__(self, n_vertices, root_vertex=0):\n        super().__init__(n_vertices)\n        self.root = root_vertex\n\n    def parent(self, v: int) -> int:\n        raise NotImplementedError\n\n    def children(self, v: int) -> Iterable[int]:\n        raise NotImplementedError\n\n    def adj(self, v) -> Iterable[int]:\n        if self.root == v:\n            return self.children(v)\n        return itertools.chain(self.children(v), (self.parent(v),))\n\n    def post_order(self) -> Iterable[int]:\n        """\n        bottom vertices first\n        """\n        return (~v for v in self.prepost_order() if v < 0)\n\n    def pre_order(self) -> Iterable[int]:\n        """\n        top vertices first\n        """\n        stack = [self.root]\n        while stack:\n            v = stack.pop()\n            yield v\n            for u in self.children(v):\n                stack.append(u)\n\n    def prepost_order(self) -> Iterable[int]:\n        """\n        if v >= 0: it\'s pre-order entry.\n\n        otherwise: it\'s post-order entry.\n        """\n        stack = [~self.root, self.root]\n        while stack:\n            v = stack.pop()\n            yield v\n            if v >= 0:\n                for u in self.children(v):\n                    stack.append(~u)\n                    stack.append(u)\n\n    def prepost_indices(self) -> Tuple[List[int], List[int]]:\n        pre_ind = [0] * self.n_vertices\n        post_ind = [0] * self.n_vertices\n        for i, t in enumerate(self.prepost_order()):\n            if t >= 0:\n                pre_ind[t] = i\n            else:\n                post_ind[~t] = i\n        return pre_ind, post_ind\n\n    def depth(self) -> List[int]:\n        depth = [0] * self.n_vertices\n        for v in self.pre_order():\n            d = depth[v]\n            for c in self.children(v):\n                depth[c] = d + 1\n        return depth\n\n    def sort_edge_values(self, wedges: Iterable[Tuple[int, int, T]], default: Optional[T] = None) -> List[T]:\n        memo = [default] * self.n_vertices\n        for u, v, d in wedges:\n            if self.parent(u) == v:\n                memo[u] = d\n            else:\n                memo[v] = d\n        return memo\n\n    def height(self, depth=None) -> int:\n        if depth is None:\n            depth = self.depth()\n        return max(depth) + 1\n\n    def path(self, v: int, k: int) -> List[int]:\n        """\n        ??v??k???????????.\n\n        :param v: ??\n        :param k: ??????????\n        :return: ??\n        """\n        res = [-1] * (k + 1)\n        for i in range(k + 1):\n            res[i] = v\n            v = self.parent(v)\n            if v < 0:\n                break\n        return res\n\n    def aggregate_parent_path(self, aggregate: Callable[[T, int], T], identity: T,\n                              pre_order: Optional[Iterable[int]] = None) -> List[T]:\n        """\n        ????????????dp??????.\n\n        :param aggregate: (T, V) -> T\n        :param identity: ???\n        :param pre_order: pre_order????\n        :return ?????????????dp?\n        """\n        if pre_order is None:\n            pre_order = self.pre_order()\n\n        dp = [identity] * self.n_vertices\n        for v in pre_order:\n            p = self.parent(v)\n            if p >= 0:\n                dp[v] = aggregate(dp[p], v)\n        return dp\n\n    def aggregate_subtree(self, merge: Callable[[T, T], T], identity: T, finalize: Callable[[T, int], T],\n                          post_order: Optional[Iterable[int]] = None) -> List[T]:\n        """\n        ???????????????dp??????.\n\n        :param merge: (T, T) -> T, (T, merge)?????\n        :param identity: ???\n        :param finalize: (T, V) -> T\n        :param post_order: post_order????\n        :return ???????????????????dp?\n        """\n        if post_order is None:\n            post_order = self.post_order()\n\n        dp = [identity] * self.n_vertices\n        for v in post_order:\n            t = identity\n            for u in self.children(v):\n                t = merge(t, dp[u])\n            dp[v] = finalize(t, v)\n        return dp\n\n    def solve_rerooting(self, merge: Callable[[T, T], T], identity: T, finalize: Callable[[T, int, int], T],\n                        pre_order: Optional[Iterable[int]] = None) -> List[T]:\n        """\n        ????dp???.\n\n        dp[u,v] = finalize(merge(dp[v,k] for k in adj[v] if k != u), u, v)\n\n        (v?????u?????????????????)\n\n        :param merge: (T,T) -> T, (T, merge)?????\n        :param identity: ???\n        :param finalize: (T, V, V) -> T\n        :param pre_order: pre_order????\n        :return ???????????????dp?\n        """\n\n        if pre_order is None:\n            pre_order = list(self.pre_order())\n        dp1 = [identity] * self.n_vertices\n        dp2 = [identity] * self.n_vertices\n\n        for v in reversed(pre_order):\n            t = identity\n            for u in self.children(v):\n                dp2[u] = t\n                t = merge(t, finalize(dp1[u], v, u))\n            t = identity\n            for u in reversed(list(self.children(v))):\n                dp2[u] = merge(t, dp2[u])\n                t = merge(t, finalize(dp1[u], v, u))\n            dp1[v] = t\n        for v in pre_order:\n            if v == self.root:\n                continue\n            p = self.parent(v)\n            dp2[v] = finalize(merge(dp2[v], dp2[p]), v, p)\n            dp1[v] = merge(dp1[v], dp2[v])\n        return dp1\n\n\nclass DoublingStrategy:\n    def __init__(self, tree: BaseRootedTree, depth=None, pre_order=None):\n        if pre_order is None:\n            pre_order = tree.pre_order()\n        if depth is None:\n            depth = tree.depth()\n        self.depth = depth\n        self.tree = tree\n        d = (max(depth) + 1).bit_length()\n        dbl = Array2d.full(tree.n_vertices, d, -1)\n        for v in pre_order:\n            u = tree.parent(v)\n            dbl[v, 0] = u\n            for i in range(d - 1):\n                u = dbl[u, i]\n                if u < 0:\n                    break\n                dbl[v, i + 1] = u\n        self.dbl = dbl\n\n    def ancestor_of(self, v: int, k: int) -> int:\n        if k > self.depth[v]:\n            return -1\n        i = 0\n        while k:\n            if k & 1:\n                v = self.dbl[v, i]\n            k //= 2\n            i += 1\n        return v\n\n    def lca(self, u: int, v: int) -> int:\n        lu, lv = self.depth[u], self.depth[v]\n        if lu > lv:\n            u = self.ancestor_of(u, lu - lv)\n        else:\n            v = self.ancestor_of(v, lv - lu)\n        if u == v:\n            return u\n\n        i = self.dbl.m - 1\n        while True:\n            while i >= 0 and self.dbl[u, i] == self.dbl[v, i]:\n                i -= 1\n            if i < 0:\n                return self.dbl[u, 0]\n            u, v = self.dbl[u, i], self.dbl[v, i]\n\n    def dist(self, u: int, v: int) -> int:\n        return self.depth[u] + self.depth[v] - 2 * self.depth[self.lca(u, v)]\n\n\nclass RootedTree(BaseRootedTree):\n\n    def __init__(self, parent: List[int], children: Graph, root_vertex: int):\n        super().__init__(len(parent), root_vertex)\n        self._parent = parent\n        self._children = children\n\n    @classmethod\n    def from_edges(cls, edges, root_vertex=0):\n        n = len(edges) + 1\n        g = Graph.from_undirected_edges(n, edges)\n        parent = [0] * n\n        parent[root_vertex] = -1\n        stack = [root_vertex]\n        while stack:\n            v = stack.pop()\n            p = parent[v]\n            for u in g.adj(v):\n                if u != p:\n                    parent[u] = v\n                    stack.append(u)\n        return cls.from_parent(parent, root_vertex)\n\n    @classmethod\n    def from_parent(cls, parent, root_vertex=0):\n        return cls(parent,\n                   Graph.from_directed_edges(len(parent), ((p, v) for v, p in enumerate(parent) if p >= 0)),\n                   root_vertex)\n\n    @classmethod\n    def random(cls, n_vertices, root_vertex=0):\n        parent = [-1] * n_vertices\n        vertices = list(range(root_vertex)) + list(range(root_vertex + 1, n_vertices))\n        shuffle(vertices)\n        vertices.append(root_vertex)\n        for i, v in zip(reversed(range(n_vertices)), vertices[-2::-1]):\n            parent[v] = vertices[randrange(i, n_vertices)]\n        return cls.from_parent(parent, root_vertex)\n\n    def parent(self, v):\n        return self._parent[v]\n\n    def children(self, v):\n        return self._children.adj(v)\n\n\nclass Grid(BaseGraph):\n    def __init__(self, grid):\n        super().__init__(grid.n * grid.m)\n        self.grid = grid\n\n    def adj(self, v):\n        if not self.grid.arr[v]:\n            return\n        i, j = divmod(v, self.grid.m)\n        if i + 1 < self.grid.n and self.grid[i + 1, j]:\n            yield v + self.grid.m\n        if 0 <= i - 1 and self.grid[i - 1, j]:\n            yield v - self.grid.m\n        if j + 1 < self.grid.m and self.grid[i, j + 1]:\n            yield v + 1\n        if 0 <= j - 1 and self.grid[i, j - 1]:\n            yield v - 1\n\n\ndef strongly_connected_components(graph: BaseGraph, rgraph: BaseGraph = None):\n    if rgraph is None:\n        rgraph = graph.to_reverse_graph()\n    n = graph.n_vertices\n    order = []\n    color = [0] * n\n    for v0 in range(n):\n        if color[v0]:\n            continue\n        color[v0] = -1\n        stack = [iter(graph.adj(v0))]\n        path = [v0]\n        while path:\n            for u in stack[-1]:\n                if color[u] == 0:\n                    color[u] = -1\n                    path.append(u)\n                    stack.append(iter(graph.adj(u)))\n                    break\n            else:\n                v = path.pop()\n                order.append(v)\n                stack.pop()\n\n    label = 0\n    for v0 in reversed(order):\n        if color[v0] >= 0:\n            continue\n        color[v0] = label\n        stack = [v0]\n        while stack:\n            v = stack.pop()\n            for u in rgraph.adj(v):\n                if color[u] < 0:\n                    color[u] = label\n                    stack.append(u)\n        label += 1\n    return label, color\n\n\ndef dijkstra(graph: BaseWeightedGraph, s: Union[int, Iterable[int]], t: Union[int, Iterable[int]] = -1,\n             inf: Any = 2 ** 62) -> Tuple[List[int], Any]:\n    """\n    Returns a list of distance. If starts contains more than one vertex, returns the shortest distance from any of them.\n    """\n    K = graph.n_vertices.bit_length()\n    MASK = (1 << K) - 1\n    dist = [inf] * graph.n_vertices\n\n    if isinstance(s, int):\n        q = [s]\n        dist[s] = 0\n    else:\n        q = list(s)\n        for v in q:\n            dist[v] = 0\n    if isinstance(t, int):\n        if t < 0:\n            t = []\n        else:\n            t = [t]\n    else:\n        t = set(t)\n\n    while q:\n        x = hq.heappop(q)\n        d, v = x >> K, x & MASK\n        if v in t:\n            return dist, d\n        if d > dist[v]:\n            continue\n        for u, w in graph.wadj(v):\n            if dist[u] > d + w:\n                dist[u] = d + w\n                hq.heappush(q, ((d + w) << K) | u)\n    return dist, None\n\n\ndef dijkstra_general(graph: BaseWeightedGraph, inf: Any, zero: Any, s: Union[int, Iterable[int]],\n                     t: Union[int, Iterable[int]] = -1) -> Tuple[List[Any], Any]:\n    """\n    Returns a list of distance. If starts contains more than one vertex, returns the shortest distance from any of them.\n    """\n    dist = [inf] * graph.n_vertices\n\n    if isinstance(s, int):\n        q = [(zero, s)]\n        dist[s] = zero\n    else:\n        q = [(zero, v) for v in s]\n        for d, v in q:\n            dist[v] = zero\n    if isinstance(t, int):\n        if t < 0:\n            t = []\n        else:\n            t = [t]\n    else:\n        t = set(t)\n\n    while q:\n        d, v = hq.heappop(q)\n        if v in t:\n            return dist, d\n        if d > dist[v]:\n            continue\n        for u, w in graph.wadj(v):\n            nw = d + w\n            if dist[u] > nw:\n                dist[u] = nw\n                hq.heappush(q, (nw, u))\n    return dist, None\n\n\ndef get_dual_graph(n_vertices: int, wedges: Iterable[Tuple[int, int, int]]) -> Tuple[\n    List[int], List[int], List[int], List[int]]:\n    """\n    ??????????????????\n    (u, v, cap) in wedges???????????(u, v, cap)?(v, u, 0)?????????????????????????\n\n    :param n_vertices: ???\n    :param wedges: ?????\n    :return: (???????, ???index?????)\n    """\n\n    cap = defaultdict(int)\n    for u, v, c in wedges:\n        cap[(u, v)] += c\n        cap[(v, u)] += 0\n\n    temp: List[List[Tuple[int, int]]] = [[] for _ in range(n_vertices)]\n    for (u, v), w in cap.items():\n        temp[u].append((v, w))\n    adj = [0] * len(cap)\n    weight = [0] * len(cap)\n    rev = [0] * len(cap)\n    ind = [0] * (n_vertices + 1)\n\n    i = 0\n    for u, l in enumerate(temp):\n        ind[u] = i\n        for v, w in l:\n            adj[i] = v\n            weight[i] = w\n            if u < v:\n                cap[(v, u)] = i\n            else:\n                j = cap[(u, v)]\n                rev[i] = j\n                rev[j] = i\n            i += 1\n    ind[n_vertices] = i\n\n    return adj, weight, ind, rev\n\n\ndef edmonds_karp(n_vertices: int, edges: Iterable[Tuple[int, int, int]], s: int, t: int):\n    """\n    ?????????O(VE^2)\n\n    :param n_vertices: ???\n    :param edges: (??1, ??2, ??)?Iterable\n    :param s: ??\n    :param t: ??\n    :return: (????, ?????)\n    """\n\n    adj, caps, ind, rev = get_dual_graph(n_vertices, edges)\n\n    m0 = max(caps)\n    bfs_memo = [0] * n_vertices\n    pv = [-1] * n_vertices\n    pe = [-1] * n_vertices\n    bfs_memo[s] = n_vertices + 1\n    offset = 0\n\n    def find_path():\n        nonlocal offset\n        offset += 1\n        q = [s]\n        while q:\n            nq = []\n            for v in q:\n                if v == t:\n                    return True\n                for i in range(ind[v], ind[v + 1]):\n                    if caps[i] == 0:\n                        continue\n                    u = adj[i]\n                    if bfs_memo[u] < offset:\n                        bfs_memo[u] = offset\n                        pv[u] = v\n                        pe[u] = i\n                        nq.append(u)\n            q = nq\n        return False\n\n    res = 0\n    flag = find_path()\n    while flag:\n        v = t\n        m = m0\n        while pv[v] >= 0:\n            e = pe[v]\n            m = min2(m, caps[e])\n            v = pv[v]\n        v = t\n        while pv[v] >= 0:\n            e = pe[v]\n            caps[e] -= m\n            caps[rev[e]] += m\n            v = pv[v]\n        res += m\n        flag = find_path()\n    return res, WeightedGraph(n_vertices, adj, caps, ind), rev\n\n\ndef max_bipartite_matching(graph: BaseWeightedGraph):\n    pass\n'),
    'lib.itertools': (False, 'from itertools import chain, repeat, count, islice\nfrom collections import Counter\n\n\ndef repeat_chain(values, counts):\n    return chain.from_iterable(map(repeat, values, counts))\n\n\ndef unique_combinations_from_value_counts(r, values, counts):\n    n = len(counts)\n    indices = list(islice(repeat_chain(count(), counts), r))\n    if len(indices) < r:\n        return\n    while True:\n        yield tuple(values[i] for i in indices)\n        for i, j in zip(reversed(range(r)), repeat_chain(reversed(range(n)), reversed(counts))):\n            if indices[i] != j:\n                break\n        else:\n            return\n        j = indices[i] + 1\n        for i, j in zip(range(i, r), repeat_chain(count(j), counts[j:])):\n            indices[i] = j\n\n\ndef unique_combinations(r, iterable):\n    return unique_combinations_from_value_counts(r, *zip(*Counter(iterable).items()))\n'),
    'lib.matrix': (False, "from lib.array2d import Array2d\n\n\ndef get_general_matrix(zero, one):\n    class Matrix(Array2d):\n        ZERO = zero\n        ONE = one\n\n        @classmethod\n        def zeros(cls, n, m):\n            return cls.full(n, m, cls.ZERO)\n\n        @classmethod\n        def ones(cls, n, m):\n            return cls.full(n, m, cls.ONE)\n\n        def __add__(self, other):\n            if self.m != other.m or self.n != other.n:\n                raise ValueError(f'Cannot add matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            return Matrix(self.n, self.m, [x + y for x, y in zip(self.arr, other.arr)])\n\n        def __iadd__(self, other):\n            if self.m != other.m or self.n != other.n:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            for i, v in enumerate(other.arr):\n                self.arr[i] += v\n            return self\n\n        def __sub__(self, other):\n            if self.m != other.m or self.n != other.n:\n                raise ValueError(f'Cannot subtract matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            return Matrix(self.n, self.m, [x - y for x, y in zip(self.arr, other.arr)])\n\n        def __isub__(self, other):\n            if self.m != other.m or self.n != other.n:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            for i, v in enumerate(other.arr):\n                self.arr[i] -= v\n            return self\n\n        def __mul__(self, other):\n            if self.m != other.m or self.n != other.n:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            return Matrix(self.n, self.m, [x * y for x, y in zip(self.arr, other.arr)])\n\n        def __imul__(self, other):\n            if self.m != other.m or self.n != other.n:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            for i, v in enumerate(other.arr):\n                self.arr[i] *= v\n            return self\n\n        def __truediv__(self, other):\n            if self.m != other.m or self.n != other.n:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            return Matrix(self.n, self.m, [x / y for x, y in zip(self.arr, other.arr)])\n\n        def __matmul__(self, other):\n            if self.m != other.n:\n                raise ValueError(f'Cannot dot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n\n            res = self.full(self.n, other.m, self.ZERO)\n\n            for i in range(self.n):\n                for j in range(other.m):\n                    c = self.ZERO\n                    for k in range(self.m):\n                        c += self[i, k] * other[k, j]\n                    res[i, j] = c\n            return res\n\n        def __imatmul__(self, other):\n            if self.m != other.n:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            if self is other or self.m != other.m:\n                return self @ other\n\n            row = [self.ZERO] * self.m\n            for i in range(self.n):\n                t = i * self.m\n                for j in range(self.m):\n                    row[j] = self.arr[j + t]\n                for j in range(other.m):\n                    c = self.ZERO\n                    for k in range(self.m):\n                        c += row[k] * other[k, j]\n                    self[i, j] = c\n            return self\n\n        def __pow__(self, power, modulo=None):\n            if self.n != self.m:\n                raise ValueError('pow is supported only for square matrix')\n            k = self.n\n            res = Matrix.full(k, k, self.ZERO)\n            for i in range(k):\n                res[i, i] = self.ONE\n\n            m = self\n            while power > 0:\n                if power & 1:\n                    res @= m\n                m @= m\n                power >>= 1\n            return res\n\n    return Matrix\n\n\nIMatrix = get_general_matrix(0, 1)\nFMatrix = get_general_matrix(0.0, 1.0)\n\n\ndef accumulate(mat):\n    res = mat.zeros(mat.n + 1, mat.m + 1)\n    for i in range(mat.n):\n        k = mat.ZERO\n        for j in range(mat.m):\n            k += mat[i, j]\n            res[i + 1, j + 1] = k\n    for j in range(1, mat.m + 1):\n        k = mat.ZERO\n        for i in range(1, mat.n + 1):\n            k += res[i, j]\n            res[i, j] = k\n    return res\n\n\ndef accumulate_prod(mat):\n    res = mat.ones(mat.n + 1, mat.m + 1)\n    for i in range(mat.n):\n        k = mat.ONE\n        for j in range(mat.m):\n            k *= mat[i, j]\n            res[i + 1, j + 1] = k\n    for j in range(1, mat.m + 1):\n        k = mat.ONE\n        for i in range(1, mat.n):\n            k *= res[i, j]\n            res[i, j] = k\n    return res\n"),
    'lib.misc': (False, 'from typing import List, Any, Callable, Sequence, Union, Tuple, TypeVar\n\nV = TypeVar(\'V\')\n\nimport sys\nfrom functools import reduce\nfrom itertools import accumulate\nfrom lib.data_structure import BinaryIndexedTree, DisjointSet\nimport bisect\n\n\ndef general_bisect(ng: int, ok: int, judge: Callable[[int], V]) -> int:\n    """\n    ???????????????????O(log L)??????\n\n    :param ng: judge(ng)==False????\n    :param ok: judge(ok)==True????\n    :param judge: ??????????\n    :return: judge(x)==True???????????\n    """\n    while abs(ng - ok) > 1:\n        m = (ng + ok) // 2\n        if judge(m):\n            ok = m\n        else:\n            ng = m\n    return ok\n\n\ndef fibonacci_search(left: int, right: int, func: Union[Callable[[int], V], Sequence], inf: V = 2 ** 60) -> Tuple[\n    V, int]:\n    """\n    ??????????????????????????????O(log L)??????\n    ???(left, right)?????????\n\n    :param left: ?????????????\n    :param right: ?????????????\n    :param func: ??????\n    :param inf: func???\n    :return: (func????, ????????func???)\n    """\n    try:\n        func = func.__getitem__\n    except AttributeError:\n        pass\n    f1, f2 = 1, 1\n    while f1 + f2 < right - left:\n        f1, f2 = f1 + f2, f1\n    l = left\n    m1 = func(l + f2)\n    m2 = func(l + f1)\n    while f1 > 2:\n        f1, f2 = f2, f1 - f2\n        if m1 > m2:\n            l += f1\n            m1 = m2\n            m2 = func(l + f1) if l + f1 < right else inf\n        else:\n            m2 = m1\n            m1 = func(l + f2)\n    if m1 < m2:\n        return m1, l + 1\n    else:\n        return m2, l + 2\n\n\ndef max2(x: V, y: V) -> V:\n    return x if x > y else y\n\n\ndef min2(x: V, y: V) -> V:\n    return x if x < y else y\n\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\n\n\ndef rerooting(rooted_tree, merge, identity, finalize):\n    """\n    merge: (T,T) -> T, (T, merge)?????\n    identity: ???\n    finalize: (T, V, V) -> T\n\n    ????????dp?????\n    dp[u,v] = finalize(merge(dp[v,k] for k in adj[v] if k != u), u, v)\n    ???(u,v)?? u->v\n    """\n    N = rooted_tree.n_vertices\n    parent = rooted_tree.parent\n    children = rooted_tree.children\n    order = rooted_tree.dfs_order\n\n    # from leaf to parent\n    dp_down = [None] * N\n    for v in reversed(order):\n        dp_down[v] = finalize(reduce(merge,\n                                     (dp_down[c] for c in children[v]),\n                                     identity), parent[v], v)\n\n    # from parent to leaf\n    dp_up = [None] * N\n    dp_up[0] = identity\n    for v in order:\n        if len(children[v]) == 0:\n            continue\n        temp = (dp_up[v],) + tuple(dp_down[u] for u in children[v]) + (identity,)\n        left = accumulate(temp[:-2], merge)\n        right = tuple(accumulate(reversed(temp[2:]), merge))\n        for u, l, r in zip(children[v], left, reversed(right)):\n            dp_up[u] = finalize(merge(l, r), u, v)\n\n    res = [None] * N\n    for v, l in enumerate(children):\n        res[v] = reduce(merge,\n                        (dp_down[u] for u in children[v]),\n                        identity)\n        res[v] = merge(res[v], dp_up[v])\n    return res, dp_up, dp_down\n\n\ndef rerooting_fast(rooted_tree, merge, identity, finalize):\n    """\n    merge: (T,T) -> T, (T, merge)?????\n    identity: ???\n    finalize: (T, V, V) -> T\n\n    ????????dp?????\n    dp[u,v] = finalize(merge(dp[v,k] for k in adj[v] if k != u), u, v)\n    ???(u,v)??\n    dp[u,v]: v?????u?????????????????\n    """\n    dp1 = [identity] * rooted_tree.n_vertices\n    dp2 = [identity] * rooted_tree.n_vertices\n\n    for v in rooted_tree.post_order:\n        t = identity\n        for u in rooted_tree.children(v):\n            dp2[u] = t\n            t = merge(t, finalize(dp1[u], v, u))\n        t = identity\n        for u in reversed(rooted_tree.children(v)):\n            dp2[u] = merge(t, dp2[u])\n            t = merge(t, finalize(dp1[u], v, u))\n        dp1[v] = t\n    for v in rooted_tree.pre_order:\n        p = rooted_tree.parent(v)\n        if p >= 0:\n            dp2[v] = finalize(merge(dp2[v], dp2[p]), v, p)\n            dp1[v] = merge(dp1[v], dp2[v])\n    return dp1\n\n\ndef longest_increasing_sequence(l, inf, strict=True):\n    if not l:\n        return 0\n    dp = [inf] * len(l)\n    if strict:\n        for i, v in enumerate(l):\n            dp[bisect.bisect_left(dp, v)] = v\n    else:\n        for i, v in enumerate(l):\n            dp[bisect.bisect_right(dp, v)] = v\n\n    m = next(n for n in reversed(range(len(l))) if dp[n] < inf) + 1\n    return m\n\n\ndef zeta(data, merge):\n    """\n    ??????data????????\n    M?????\n    data: 2^n -> M\n    output: 2^n -> M\n    merge: M -> M\n \n    ouput[i] = sum(data[j] for j in range(2^n) if i|j == i)\n    """\n    n = len(data)\n    i = 1\n    while i < n:\n        j = i\n        while j < n:\n            data[j] = merge(data[j], data[j & ~i])\n            j = (j + 1) | i\n        i <<= 1\n    return data\n\n\ndef check_bipartiteness(n_vertices, edges):\n    ds = DisjointSet(2 * n_vertices)\n\n    for a, b in edges:\n        ds.union(a, b + n_vertices)\n        ds.union(b, a + n_vertices)\n\n    next_color = 0\n    color = [-1] * (2 * n_vertices)\n    for v in range(n_vertices):\n        ra = ds.find(v)\n        rb = ds.find(v + n_vertices)\n        if ra == rb:\n            return None\n        if color[ra] < 0:\n            color[ra] = next_color\n            color[rb] = next_color + 1\n            next_color += 2\n        color[v] = color[ra]\n        color[v + n_vertices] = color[rb]\n    return color[:n_vertices]\n\n\ndef small_range_duplicate(a: List[int]) -> Tuple[List[int], List[int]]:\n    MASK = (1 << 32) - 1\n    n = len(a)\n    left = [i - 1 for i in range(n + 1)]\n    right = [i + 1 for i in range(n + 1)]\n\n    sorted_ind = sorted((~v << 32) | i for i, v in enumerate(a))\n    t = 0\n    vi = sorted_ind[t]\n    i = vi & MASK\n    v = ~(vi >> 32)\n    while t < n:\n        j = i\n        l = left[i]\n        pi = l\n        pv = v\n        while v == pv and left[i] == pi:\n            pi = i\n            t += 1\n            if t >= n:\n                break\n            vi = sorted_ind[t]\n            i = vi & MASK\n            v = ~(vi >> 32)\n        r = right[pi]\n        right[l] = r\n        while j <= pi:\n            nj = right[j]\n            left[j] = l\n            right[j] = r\n            j = nj\n        left[r] = l\n\n    return left, right\n\n\ndef small_range(a: List[int]) -> Tuple[List[int], List[int]]:\n    N = len(a)\n    MASK = (1 << 32) - 1\n    left = [i - 1 for i in range(N + 1)]\n    right = [i + 1 for i in range(N + 1)]\n    sorted_ind = sorted((~v << 32) | i for i, v in enumerate(a))\n    for v in sorted_ind:\n        i = v & MASK\n        left[right[-i]] = left[-i]\n        right[left[-i]] = right[-i]\n\n    return left, right\n\n\ndef popcnt32(n: int) -> int:\n    n = n - ((n >> 1) & 0x55555555)\n    n = (n & 0x33333333) + ((n >> 2) & 0x33333333)\n    return ((((n + (n >> 4)) & 0x0f0f0f0f) * 0x01010101) >> 24) & 0xff\n\n\ndef popcnt64(n: int) -> int:\n    n = n - ((n >> 1) & 0x5555555555555555)\n    n = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333)\n    n = (n + (n >> 4)) & 0x0f0f0f0f0f0f0f0f\n    return ((((n + (n >> 32)) & 0xffffffff) * 0x01010101) >> 24) & 0xff\n\n\ndef popcnt(n: int) -> int:\n    if n < 1 << 32:\n        return popcnt32(n)\n    elif n < 1 << 64:\n        return popcnt64(n)\n    else:\n        return sum(c == \'1\' for c in bin(n))\n\n\ndef reverse_bits32(x: int):\n    x = ((x & 0x55555555) << 1) | ((x & 0xAAAAAAAA) >> 1)\n    x = ((x & 0x33333333) << 2) | ((x & 0xCCCCCCCC) >> 2)\n    x = ((x & 0x0F0F0F0F) << 4) | ((x & 0xF0F0F0F0) >> 4)\n    x = ((x & 0x00FF00FF) << 8) | ((x & 0xFF00FF00) >> 8)\n    return ((x & 0x0000FFFF) << 16) | ((x & 0xFFFF0000) >> 16)\n\n\ndef count_inversions(l: List[Any]) -> int:\n    """\n    ?????????in-place????????\n\n    :param l: ???\n    :return: ???\n    """\n    bit = BinaryIndexedTree(len(l))\n    res = 0\n    for i, v in enumerate(l):\n        bit[v] += 1\n        res += bit[v + 1:]\n    return res\n\n\nclass BinaryTrie:\n    class Node:\n        def __init__(self):\n            self.zero = None\n            self.one = None\n            self.cnt = 0\n\n    def __init__(self, bits):\n        self.root = self.Node()\n        self.bits = bits\n\n    def add(self, v):\n        n = self.root\n        n.cnt += 1\n        for d in reversed(range(self.bits)):\n            if (v >> d) & 1:\n                if not n.one:\n                    n.one = self.Node()\n                n = n.one\n            else:\n                if not n.zero:\n                    n.zero = self.Node()\n                n = n.zero\n            n.cnt += 1\n\n    def remove(self, v):\n        n = self.root\n        n.cnt -= 1\n        for d in reversed(range(self.bits)):\n            if (v >> d) & 1:\n                n = n.one\n            else:\n                n = n.zero\n            n.cnt -= 1\n\n    def find_argminxor(self, v):\n        n = self.root\n        r = 0\n        for d in reversed(range(self.bits)):\n            if (v >> d) & 1:\n                if n.one and n.one.cnt > 0:\n                    n = n.one\n                    r |= 1 << d\n                else:\n                    n = n.zero\n            else:\n                if n.zero and n.zero.cnt > 0:\n                    n = n.zero\n                else:\n                    n = n.one\n                    r |= 1 << d\n        return r\n\n    def find_nth(self):\n        raise NotImplementedError\n\n\n    def __contains__(self, v):\n        n = self.root\n        for d in reversed(range(self.bits)):\n            if (v >> d) & 1:\n                n = n.one\n            else:\n                n = n.zero\n            if not n or n.cnt == 0:\n                return False\n        return True\n'),
    'lib.modint': (False, "from importlib.util import find_spec, module_from_spec\n\nmodints = {}\n\n\ndef get_modint(mod):\n    try:\n        return modints[mod]\n    except KeyError:\n        spec = find_spec('lib._modint')\n        module = module_from_spec(spec)\n        module.__dict__['MOD'] = mod\n        spec.loader.exec_module(module)\n        modints[mod] = module.ModInt\n        return modints[mod]"),
    'lib.number_theory': (False, 'from collections import Counter, defaultdict\nfrom math import sqrt, ceil, gcd\nfrom itertools import count\nfrom typing import Tuple\n\n\ndef sign(x):\n    return int(x > 0) - int(x < 0)\n\n\ndef egcd(a: int, b: int) -> Tuple[int, int, int]:\n    """\n    ?????????\n\n    :param a: ??\n    :param b: ??\n    :return: (x, y, gcd(a,b)). x, y?ax+by=gcd(a,b)????\n    """\n    s, ps, r, pr = 0, 1, b, a\n    while r != 0:\n        q = pr // r\n        pr, r = r, pr - q * r\n        ps, s = s, ps - q * s\n    t = (pr - ps * a) // b\n    if pr > 0:\n        return ps, t, pr\n    return -ps, -t, -pr\n\n\ndef modinv(x: int, mod: int) -> int:\n    """\n    Z/(mod Z)???x???\n\n    :param x: ??\n    :param mod: ??\n    :return: x * y % mod = 1????y\n    """\n    s, ps, r, pr = 0, 1, mod, x\n    while r != 0:\n        pr, (q, r) = r, divmod(pr, r)\n        ps, s = s, ps - q * s\n    if pr == 1:\n        return ps if ps >= 0 else ps + mod\n    raise ValueError("base is not invertible for the given modulus")\n\n\ndef modpow(x, k, mod):\n    """\n    Z/(mod Z)???x?k?\n\n    :param x: ??\n    :param k: ??\n    :param mod: ??\n    :return: x ** k % mod\n    """\n    if k < 0:\n        x = modinv(x, mod)\n        k = -k\n    r = 1\n    while k != 0:\n        if k & 1:\n            r = (r * x) % mod\n        x = (x * x) % mod\n        k >>= 1\n    return r\n\n\n# ?????\ndef prime_factors(n):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            yield i\n    if n > 1:\n        yield n\n\n\ndef int_product(iterable):\n    x = 1\n    for y in iterable:\n        x *= y\n    return x\n\n\n# ?????O(sqrt(n))????\ndef divisors(n):\n    for i in range(1, ceil(sqrt(n)) + 1):\n        j, r = divmod(n, i)\n        if not r:\n            yield i\n            if i != j:\n                yield j\n\n\n# ?????\ndef generate_primes():\n    D = defaultdict(list)\n\n    q = 2\n    for q in count(2):\n        if q in D:\n            for p in D[q]:\n                D[p + q].append(p)\n            del D[q]\n        else:\n            yield q\n            D[q * q].append(q)\n\n\ndef totient_factors(n):\n    def it():\n        prev = -1\n        for p in prime_factors(n):\n            if p == prev:\n                yield p\n            else:\n                prev = p\n                for q in prime_factors(p - 1):\n                    yield q\n\n    return it()\n\n\ndef primitive_root(mod, phi_factors=None):\n    if phi_factors is None:\n        phi_factors = tuple(totient_factors(mod))\n    phi = int_product(phi_factors)\n    primes = set(phi_factors)\n    for i in range(2, mod):\n        for p in primes:\n            if modpow(i, (phi // p), mod) == 1:\n                break\n        else:\n            return i\n    else:\n        raise ValueError(f\'There is no primitive root for modulo {mod}\')\n\n\ndef lcm(nums):\n    m = 1\n    for n in nums:\n        m *= n // gcd(m, n)\n    return m\n\n\ndef chinese_remainder_theorem(reminders, mods, mods_lcm=-1):\n    """\n    returns x and lcm(reminders) s.t.\n    all(x%m == r for r,m in zip(reminders,mods))\n    """\n    s = 0\n    if mods_lcm < 0:\n        mods_lcm = lcm(mods)\n    for m, r in zip(mods, reminders):\n        p = mods_lcm // m\n        s += r * p * pow(p, -1, m)\n        s %= mods_lcm\n    return s, mods_lcm\n\n\ndef factorials_with_inv(k, mod):\n    """\n    0! ... k! ?????mod????????\n    PyPy??pow????????????\n    """\n    fac = [1] * (k + 1)\n    inv = [1] * (k + 1)\n    t = 1\n    for i in range(1, k + 1):\n        t = (t * i) % mod\n        fac[i] = t\n    t = modinv(t, mod)\n    for i in reversed(range(1, k + 1)):\n        inv[i] = t\n        t = (t * i) % mod\n    return fac, inv\n\n\ndef extended_lucas_theorem(mod):\n    """\n    Returns a function (n,m) -> C(n,m)%mod\n    """\n    factors = tuple((p, q, p ** q) for p, q in Counter(prime_factors(mod)).items())\n    facs = [[0] * k for p, q, k in factors]\n    invs = [[0] * k for p, q, k in factors]\n    for (p, q, k), fac, inv in zip(factors, facs, invs):\n        t = 1\n        for n in range(k):\n            if n % p != 0:\n                t *= n\n                t %= k\n            fac[n] = t\n        t = modinv(t, k)\n        for n in reversed(range(k)):\n            inv[n] = t\n            if n % p != 0:\n                t *= n\n                t %= k\n\n    def helper(n, m):\n        l = n - m\n        if l < 0:\n            return 0\n\n        def reminders():\n            for (p, q, k), fac, inv in zip(factors, facs, invs):\n                a, b, c, e0, eq, i, r = n, m, l, 0, -2, 1, 1\n                while a > 0:\n                    r *= fac[a % k] * inv[b % k] * inv[c % k]\n                    r %= k\n                    a, b, c = a // p, b // p, c // p\n                    if i == q:\n                        eq = e0\n                    e0 += a - b - c\n                    i += 1\n                if eq >= 0:\n                    eq += e0\n                if e0 >= q:\n                    r = 0\n                else:\n                    r *= p ** e0\n                    r %= k\n                    if not (p == 2 and q >= 3) and (eq % 2 == 1):\n                        r = -r\n                yield r\n\n        return chinese_remainder_theorem(reminders(), (m for _, _, m in factors), mod)[0]\n\n    return helper\n\n\ndef lucas_theorem(m, n, mod, comb):\n    cnt = 1\n    while n > 0:\n        m, mr = divmod(m, mod)\n        n, nr = divmod(n, mod)\n        if mr < nr:\n            return 0\n        cnt *= comb[mr][nr]\n        cnt %= mod\n    return cnt\n\n\n# C(n,m) is even iff (~n&m)>0\n\ndef floor_linear_sum(n, m, a, b):\n    """\n    returns sum((a*i+b)//m for i in range(n))\n    """\n    if b < 0:\n        t = (-b - 1) // m + 1\n        b += m * t\n        res = -t * n\n    else:\n        res = 0\n    while True:\n        if a >= m:\n            res += (n - 1) * n * (a // m) // 2\n            a %= m\n        if b >= m:\n            res += n * (b // m)\n            b %= m\n\n        y_max = (a * n + b) // m\n        if y_max == 0:\n            return res\n        nx_max = b - y_max * m\n        res += (n + nx_max // a) * y_max\n        n, m, a, b = y_max, a, m, nx_max % a\n\ndef get_sieve(n):\n    sieve = [0]*(n+1)\n    for i in range(2, len(sieve)):\n        if sieve[i] > 0:\n            continue\n        sieve[i] = i\n        for j in range(i*2, len(sieve), i):\n            if sieve[j] == 0:\n                sieve[j] = i\n    return sieve\n\ndef divisors_from_sieve(n, sieve):\n    res = [1]\n    while n > 1:\n        k = sieve[n]\n        n //= k\n        l = len(res)\n        t = k\n        res.extend(res[i]*t for i in range(l))\n        while n > 1 and sieve[n] == k:\n            t *= k\n            res.extend(res[i]*t for i in range(l))\n            n //= k\n    return res\n\ndef factorize_from_sieve(n, sieve):\n    while n > 1:\n        yield sieve[n]\n        n //= sieve[n]\n\n\n# TODO ?????????'),
    'lib.transform': (False, "from cmath import rect, pi\nfrom lib.misc import reverse_bits32\nfrom lib.number_theory import totient_factors, primitive_root, modinv, modpow\n\n\ndef fft(a, inverse=False):\n    one = complex(1.0)\n    n = (len(a) - 1).bit_length()\n    m = 2 ** n\n    a += [complex(0.0)] * (m - len(a))\n    pows = [rect(1.0, (-pi if inverse else pi) / (2 ** (n - 1)))]\n    for _ in range(n-1):\n        pows.append(pows[-1] ** 2)\n    pows.reverse()\n\n    shift = 32 - n\n    for i in range(m):\n        j = reverse_bits32(i) >> shift\n        if i < j:\n            a[i], a[j] = a[j], a[i]\n\n    for i in range(m):\n        b = 1\n        for w1 in pows:\n            if not i & b:\n                break\n            i ^= b\n            w = one\n            while not i & b:\n                s = a[i]\n                t = a[i | b] * w\n                a[i] = s + t\n                a[i | b] = s - t\n                w *= w1\n                i += 1\n            i ^= b\n            b <<= 1\n    if inverse:\n        c = 1 / m\n        for i in range(m):\n            a[i] *= c\n    return a\n\n\ndef ntt(a, mod, inverse=False):\n    if type(a[0]) is not int:\n        for i,v in enumerate(a):\n            a[i] = int(v)\n    n = (len(a) - 1).bit_length()\n    d2 = 0\n    r = 1\n    phi_factors = tuple(totient_factors(mod))\n    for p in phi_factors:\n        if p == 2:\n            d2 += 1\n        else:\n            r *= p\n    if d2 < n:\n        raise ValueError(f'Given array is too long: modulo {modint.mod} only support array length up to {2 ** d2}')\n\n    pr = primitive_root(mod, phi_factors)\n    if inverse:\n        pr = modinv(pr, mod)\n    pows = [modpow(pr, r * 2 ** (d2 - n), mod)]\n    for _ in range(n - 1):\n        pows.append(pows[-1] ** 2 % mod)\n    pows = tuple(reversed(pows))\n\n    m = 2 ** n\n    a += [0] * (m - len(a))\n\n    shift = 32 - n\n    for i in range(m):\n        j = reverse_bits32(i) >> shift\n        if i < j:\n            a[i], a[j] = a[j], a[i]\n\n    for i in range(m):\n        b = 1\n        for w1 in pows:\n            if not i & b:\n                break\n            i ^= b\n            w = 1\n            while not i & b:\n                j = i | b\n                s = a[i] % mod\n                t = a[j] * w % mod\n                a[i] = s + t\n                a[j] = s - t\n                w = (w * w1) % mod\n                i += 1\n            i ^= b\n            b <<= 1\n\n    if inverse:\n        c = modinv(m, mod)\n        for i, v in enumerate(a):\n            a[i] = (v * c) % mod\n    return a"),
    'lib._modint': (False, 'from lib.number_theory import modinv, modpow\n\nclass ModInt(int):\n    mod = MOD\n\n    def __new__(cls, n=0, f=1):\n        return int.__new__(cls, n % MOD if f else n)\n\n    def __neg__(self):\n        return ModInt(MOD - int(self) if self != 0 else 0, 0)\n\n    def __add__(self, other):\n        x = int(self) + int(other)\n        return ModInt(x if x < MOD else x - MOD, 0)\n\n    def __sub__(self, other):\n        x = int(self) - int(other)\n        return ModInt(x if x >= 0 else x + MOD, 0)\n\n    def __rsub__(self, other):\n        x = int(other) - int(self)\n        return ModInt(x if x >= 0 else x + MOD, 0)\n\n    def __mul__(self, other):\n        return ModInt(int(self) * int(other))\n\n    def __truediv__(self, other):\n        return self * ModInt(other).inv\n\n    def __rtruediv__(self, other):\n        return self.inv * other\n\n    __radd__ = __add__\n    __rmul__ = __mul__\n\n    def __pow__(self, other, **kwargs):\n        return ModInt(modpow(int(self), int(other), MOD), 0)\n\n    @property\n    def inv(self):\n        return ModInt(modinv(int(self), MOD), 0)\n\n    @classmethod\n    def sum(cls, iterable):\n        r = 0\n        for v in iterable:\n            r += int(v)\n        return ModInt(r)\n\n    @classmethod\n    def product(cls, iterable):\n        r = ModInt(1)\n        for v in iterable:\n            r *= v\n        return r'),
    'lib': (True, ''),
}
_sys.meta_path.insert(2, InlineImporter)

# Entrypoint
from lib.number_theory import factorials_with_inv

mod = 998244353

n, a, b, c = map(int, input().split())

fac, inv = factorials_with_inv(n, mod)
comb = lambda n, k: fac[n] * inv[k] % mod * inv[n - k] % mod

res = 1
t = -1 if n%2 == 0 else 1
dp_a = 1
dp_b = 1
dp_c = 1
for k in range(1, n + 1):
    dp_a *= 2
    if k - 1 >= a:
        dp_a -= comb(k - 1, a)
    dp_a %= mod
    dp_b *= 2
    if k - 1 >= b:
        dp_b -= comb(k - 1, b)
    dp_b %= mod
    dp_c *= 2
    if k - 1 >= c:
        dp_c -= comb(k - 1, c)
    dp_c %= mod
    res += t * comb(n, k) * dp_a % mod * dp_b % mod * dp_c % mod
    res %= mod
    t = -t

print(res)
