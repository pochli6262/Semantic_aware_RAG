{
  "task": "abc244_b/Python/45713633",
  "query_summary": "The rotate() method incorrectly sets dx to the position y instead of the direction dy, using self.y instead of self.dy and thus rotating the heading wrongly.",
  "oracle_summary": "The rotate() method incorrectly sets dx to the position y instead of the direction dy, using self.y instead of self.dy and thus rotating the heading wrongly.",
  "retrieved": [
    {
      "summary": "The problem in the buggy code is that it incorrectly updates the y-coordinate when the input is \"D\" by adding 1 instead of subtracting 1.",
      "diff": "--- \n+++ \n@@ -9,7 +9,7 @@\n     elif s==\"U\":\n         y += 1\n     elif s==\"D\":\n-        y += 1\n+        y -= 1\n     \n     return x, y\n "
    },
    {
      "summary": "The buggy code incorrectly computes the value of `X` when the move is \"R\" by using `X *= 2 + 1` instead of the correct formula `X = 2 * X + 1`.",
      "diff": "--- \n+++ \n@@ -20,7 +20,7 @@\n     if s == \"L\":\n         X*=2\n     elif s == \"R\":\n-        X*=2+1\n+        X=2*X+1\n     else:\n         X//=2\n print(X)"
    },
    {
      "summary": "The problem in the buggy code is that it incorrectly checks the condition for determining whether to print 'No' or 'Yes' by using the wrong comparison operator in the last conditional statement, which should use '>' instead of '<'.",
      "diff": "--- \n+++ \n@@ -27,7 +27,7 @@\n     x, y = map(int, input().split())\n     for i in range(N):\n         dx, dy, d, inter = lines[i]\n-        if inter > d * intercept(dx, dy, x, y):\n+        if inter * d > intercept(dx, dy, x, y) * d:\n             print('No')\n             break\n     else: print('Yes')"
    },
    {
      "summary": "The buggy code incorrectly calculates the output by missing an additional application of the function `f` on the result of `f(t) + t`.",
      "diff": "--- \n+++ \n@@ -2,5 +2,4 @@\n \treturn x**2+2*x+3\n \n t = int(input())\n-print((f(f(t)+t)+f(f(t))))\n-\n+print(f(f(f(t)+t)+f(f(t))))"
    },
    {
      "summary": "The buggy code incorrectly appends characters from `S` to `ans` when they match, instead of appending \"0\", which leads to an invalid output.",
      "diff": "--- \n+++ \n@@ -15,7 +15,7 @@\n ans = []\n for s, t in zip(S, T):\n     if s == t:\n-        ans.append(s)\n+        ans.append(\"0\")\n     elif ds > 0 and s == \"1\":\n         ans.append(\"0\")\n         ds -= 1"
    }
  ],
  "useful_diffs_indices": [
    3,
    4
  ],
  "useful_diffs_count": 2
}