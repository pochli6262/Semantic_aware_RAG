{
  "task": "abc300_d/Python/45256387",
  "query_summary": "The likely bug is that the program improperly initializes the variable `n` as a constant value instead of reading its value from input, leading to incorrect results for test cases.",
  "oracle_summary": "The buggy version hardcodes n = 10**12 instead of reading n from input, so it ignores the intended input value.",
  "retrieved": [
    {
      "summary": "The buggy code fails to correctly initialize the variable `res`, which should be set to `max(0, n - 1)` instead of just `n - 1`, potentially leading to negative results for certain input cases.",
      "diff": "--- \n+++ \n@@ -19,7 +19,7 @@\n         d.append(p)\n ans = 0\n for _ in range(2):\n-    res = n - 1\n+    res = max(0, n - 1)\n     frm = 0\n     if _ == 1:\n         cnt = 0"
    },
    {
      "summary": "The bug in the code is that it incorrectly appends the range (n - 1, n - 3) in the first if condition, where it should append (n - 2, n - 2) instead.",
      "diff": "--- \n+++ \n@@ -6,7 +6,7 @@\n     if p[j] != j + 1 and j < n - 2:\n         ind = p.index(j + 1)\n         if ind == n - 1:\n-            ans.append((n - 1, n - 3))\n+            ans.append((n - 2, n - 2))\n             p = p[: n - 3] + [p[n - 1]] + p[n - 3 : n - 1]\n         else:\n             ans.append((ind + 1, j))"
    },
    {
      "summary": "The problem in the buggy code is that the loop should iterate `t` times instead of `n` times, causing incorrect handling of input and potentially leading to incorrect results.",
      "diff": "--- \n+++ \n@@ -2,7 +2,7 @@\n s=[0 for _ in range(n)]\n p={}\n p[0]=n\n-for i in range(n):\n+for i in range(t):\n     a,b=map(int,input().split())\n     a-=1\n     p[s[a]]-=1"
    },
    {
      "summary": "The buggy code contains an off-by-one error in the calculation of `m`, where it should be `m = n//2 + 1` instead of `m = n//2 + (n%2)`, which affects the logic used to determine when to print a result.",
      "diff": "--- \n+++ \n@@ -101,7 +101,7 @@\n         i += 1\n     return lower_divisors + upper_divisors[::-1]\n n = int(input())\n-m = n//2 + (n%2)\n+m = n//2 + 1\n alist = list(map(int,input().split()))\n t = time.time()\n s = set([2,1])"
    },
    {
      "summary": "The buggy code incorrectly initializes the variable `ng` to `len(li) - 1` instead of `len(li)`, which causes the binary search to skip the last potential index and may lead to an out-of-bounds error.",
      "diff": "--- \n+++ \n@@ -1,3 +1,4 @@\n+\n def enum_primes(n):\n     prime_flag = [1] * (n + 1)\n     prime_flag[0] = 0\n@@ -18,7 +19,7 @@\n for i in range(len(li)):\n     p=li[i]\n     ok=i\n-    ng=len(li)-1\n+    ng=len(li)\n     while ng-ok>1:\n         j=(ok+ng)//2\n         q=li[j]\n@@ -30,3 +31,4 @@\n         ans+=ok-i\n \n print(ans)\n+"
    }
  ],
  "useful_diffs_indices": [
    1,
    10
  ],
  "useful_diffs_count": 2
}