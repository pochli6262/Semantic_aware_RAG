{
  "task": "abc301_d/Python/45723653",
  "query_summary": "The code fills '?' bits from the least significant to the most significant (wrong order), so it can miss larger valid numbers and fail to produce the maximal value ≤ N.",
  "oracle_summary": "The bug was caused by iterating over the bit positions in reverse (least significant first) when filling '?'s, breaking the required greedy choice order — it should scan from most significant to least significant.",
  "retrieved": [
    {
      "summary": "The problem in the buggy code is that it incorrectly outputs -1 only when the longest sequence of non-hyphen characters is equal to `n-2`, failing to account for the case where there are no non-hyphen characters at all (represented by `m` being 0).",
      "diff": "--- \n+++ \n@@ -7,6 +7,6 @@\n     m=max(m,x)\n     x=0\n   else: x+=1\n-if m==n-2:\n+if m==n-2 or m==0:\n   print(-1)\n else: print(m)"
    },
    {
      "summary": "The buggy code incorrectly iterates from 1 to (1 << n) - 1, which excludes the case when all input strings are considered, leading to potential undercounting of character occurrences.",
      "diff": "--- \n+++ \n@@ -1,7 +1,7 @@\n n,m=map(int,input().split())\n s=[input() for i in range(n)]\n a=0\n-for i in range(1,(1<<n)-1):\n+for i in range(1,1<<n):\n   c=[0]*26\n   for j in range(n):\n     if (i>>j)&1:"
    },
    {
      "summary": "The problem in the buggy code is that it starts the loop from `2**m` instead of `2**m - 1`, leading it to miss generating combinations corresponding to `m` bits where exactly `n` bits are set to 1.",
      "diff": "--- \n+++ \n@@ -1,6 +1,6 @@\n n, m = map(int, input().split())\n \n-for i in range(2**m, 0, -1):\n+for i in range(2**m-1, 0, -1):\n   co = bin(i)[2:].zfill(m)\n   if co.count(\"1\") == n:\n     print(*[t+1 for t in range(m) if co[t]==\"1\"])"
    },
    {
      "summary": "The buggy code fails to correctly initialize the variable `res`, which should be set to `max(0, n - 1)` instead of just `n - 1`, potentially leading to negative results for certain input cases.",
      "diff": "--- \n+++ \n@@ -19,7 +19,7 @@\n         d.append(p)\n ans = 0\n for _ in range(2):\n-    res = n - 1\n+    res = max(0, n - 1)\n     frm = 0\n     if _ == 1:\n         cnt = 0"
    },
    {
      "summary": "The buggy code uses the wrong range for the loop iterating through the bit representations, which should include 0 but instead starts from 1, potentially missing valid combinations.",
      "diff": "--- \n+++ \n@@ -10,7 +10,7 @@\n     X.append(buf[-1])\n \n ans = 0\n-for bit in range(1, 1<<N):\n+for bit in range(1<<N):\n     flg = True\n     for i in range(M):\n         cnt = 0"
    }
  ],
  "useful_diffs_indices": [
    1,
    3,
    4
  ],
  "useful_diffs_count": 3
}