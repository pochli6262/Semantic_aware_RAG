{
  "task": "abc282_e/Python/45514577",
  "query_summary": "The buggy code sorts edges in ascending order and thus builds a minimum spanning tree, whereas it should sort in descending order (reverse=True) to build the maximum spanning tree and maximize the sum.",
  "oracle_summary": "The buggy code sorts edges in ascending order and thus builds a minimum spanning tree, whereas it should sort in descending order (reverse=True) to build the maximum spanning tree and maximize the sum.",
  "retrieved": [
    {
      "summary": "The buggy code incorrectly prints the result as long as there is at least one vertex in the topological sort, without checking if all vertices have been included; the correct code verifies that all vertices have been processed to ensure a valid topological ordering.",
      "diff": "--- \n+++ \n@@ -24,7 +24,7 @@\n         if in_edges[u] == 0:\n             heapq.heappush(H, u)\n \n-if ans:\n+if ans and len(ans) == N:\n     print(*ans)\n else:\n     print(-1)"
    },
    {
      "summary": "The buggy code fails to update the `pairs` set after adding a new edge, which leads to missing edges in the directed graph, and also does not properly remove nodes from `reversed_graph` when they are processed, causing incorrect behavior in the topological sorting logic.",
      "diff": "--- \n+++ \n@@ -10,6 +10,7 @@\n     pair=(u-1,v-1)\n     if pair in pairs:\n         continue\n+    pairs.add(pair)\n     graph[u-1].append(v-1)\n     reversed_graph[v-1].add(u-1)\n     if v-1 in que:\n@@ -24,6 +25,7 @@\n     now=heapq.heappop(que)\n     answers.append(now+1)\n     for to in graph[now]:\n+        reversed_graph[to].remove(now)\n         if len(reversed_graph[to])==0:\n             heapq.heappush(que,to)\n     "
    },
    {
      "summary": "The buggy code incorrectly adds edges to the graph using original indices instead of the leaders from the Disjoint Set Union (DSU), resulting in incorrect graph connections.",
      "diff": "--- \n+++ \n@@ -30,7 +30,7 @@\n E = defaultdict(list)\n for u, v in UV:\n     G.add_edge(D.leader(u), D.leader(v))\n-    E[u].append(v)\n+    E[D.leader(u)].append(D.leader(v))\n \n memo = [0]*N\n memo[D.leader(0)] = 1"
    },
    {
      "summary": "The buggy code incorrectly appends edges to the graph G for certain nodes; it should check if the subsequent node is the start node before creating an edge, but it fails to handle that case properly, leading to incorrect graph construction.",
      "diff": "--- \n+++ \n@@ -13,6 +13,8 @@\n G=[list() for i in range(N)]\n for i in range(N):\n   if C[i][1]==0:\n+    continue\n+  if C[(i+1)%N][1]==0:\n     G[i].append([(i+2)%N,(C[(i+2)%N][0]-C[i][0])%M])\n   else:\n     G[i].append([(i+1)%N,(C[(i+1)%N][0]-C[i][0])%M])"
    },
    {
      "summary": "The buggy code incorrectly initializes the `ans` list with `-1` instead of `0`, leading to incorrect output for unvisited edges.",
      "diff": "--- \n+++ \n@@ -8,7 +8,7 @@\n     edges[b[i]].append((a[i], i))\n \n # DFS\n-ans = [-1] * m\n+ans = [0] * m\n visited = [0] * n\n for root in range(n):\n     if visited[root]:"
    }
  ],
  "useful_diffs_indices": [],
  "useful_diffs_count": 0
}