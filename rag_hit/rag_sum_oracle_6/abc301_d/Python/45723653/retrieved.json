{
  "task": "abc301_d/Python/45723653",
  "query_summary": "The bug was caused by iterating over the bit positions in reverse (least significant first) when filling '?'s, breaking the required greedy choice order — it should scan from most significant to least significant.",
  "oracle_summary": "The bug was caused by iterating over the bit positions in reverse (least significant first) when filling '?'s, breaking the required greedy choice order — it should scan from most significant to least significant.",
  "retrieved": [
    {
      "summary": "The buggy code uses the wrong range for the loop iterating through the bit representations, which should include 0 but instead starts from 1, potentially missing valid combinations.",
      "diff": "--- \n+++ \n@@ -10,7 +10,7 @@\n     X.append(buf[-1])\n \n ans = 0\n-for bit in range(1, 1<<N):\n+for bit in range(1<<N):\n     flg = True\n     for i in range(M):\n         cnt = 0"
    },
    {
      "summary": "The problem in the buggy code is that it starts the loop from `2**m` instead of `2**m - 1`, leading it to miss generating combinations corresponding to `m` bits where exactly `n` bits are set to 1.",
      "diff": "--- \n+++ \n@@ -1,6 +1,6 @@\n n, m = map(int, input().split())\n \n-for i in range(2**m, 0, -1):\n+for i in range(2**m-1, 0, -1):\n   co = bin(i)[2:].zfill(m)\n   if co.count(\"1\") == n:\n     print(*[t+1 for t in range(m) if co[t]==\"1\"])"
    },
    {
      "summary": "The buggy code incorrectly calculates the index for populating the bits array by using `(j*le+x)` instead of the correct `(j*62+x)`, leading to potential out-of-bounds access when processing edges in the adjacency matrix.",
      "diff": "--- \n+++ \n@@ -19,7 +19,7 @@\n     for j in range(le):\n         num = 0\n         for x in range(62):\n-            if j*le+x < n and e[i][j*le+x]:\n+            if j*62+x < n and e[i][j*62+x]:\n                 num |= 1<<x\n         bi.append(num)\n     bits.append(bi)"
    },
    {
      "summary": "The problem in the buggy code is that it incorrectly outputs -1 only when the longest sequence of non-hyphen characters is equal to `n-2`, failing to account for the case where there are no non-hyphen characters at all (represented by `m` being 0).",
      "diff": "--- \n+++ \n@@ -7,6 +7,6 @@\n     m=max(m,x)\n     x=0\n   else: x+=1\n-if m==n-2:\n+if m==n-2 or m==0:\n   print(-1)\n else: print(m)"
    },
    {
      "summary": "The buggy code incorrectly iterates from 1 to (1 << n) - 1, which excludes the case when all input strings are considered, leading to potential undercounting of character occurrences.",
      "diff": "--- \n+++ \n@@ -1,7 +1,7 @@\n n,m=map(int,input().split())\n s=[input() for i in range(n)]\n a=0\n-for i in range(1,(1<<n)-1):\n+for i in range(1,1<<n):\n   c=[0]*26\n   for j in range(n):\n     if (i>>j)&1:"
    }
  ],
  "useful_diffs_indices": [
    1,
    2,
    5
  ],
  "useful_diffs_count": 3
}