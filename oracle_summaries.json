{
  "abc265_d/Python/46180053": "The bug is that the cumulative sum omits the initial 0 (using cumsum(A) instead of cumsum([0]+A)), causing an off-by-one in prefix sums and missing cases where the segment starts at index 0.",
  "abc265_d/Python/45075464": "The code wrongly rejects w == N by checking w >= N instead of w > N, even though asum has length N+1, causing valid matches that end at the array’s end to be missed.",
  "abc265_d/Python/45966660": "The loop incorrectly iterates over range(N-3) instead of all indices 0..N-1, skipping the last three starting positions and potentially missing valid solutions near the end.",
  "abc244_e/Python/45970204": "It fails to apply the final modulus, printing dp[k][t-1][0] without taking % 998244353, so the output may be unmodded and incorrect.",
  "abc300_e/Python/45250612": "The DP transition for k+1 mistakenly uses assignment (=) instead of accumulation (+=), overwriting previous contributions to dp[i][j][k+1].",
  "abc300_e/Python/45218169": "The prime-factorization loop uses curN /= p (floating-point division) instead of curN //= p (integer division), converting curN to a float and causing precision/logic errors in subsequent checks.",
  "abc282_c/Python/44818334": "The code replaces commas when inside quotes (cnt%2==1) instead of outside quotes, so the parity check should be cnt%2==0.",
  "abc300_b/Python/45110485": "The buggy code skips the (dy, dx) = (0, 0) case, so it never checks whether tableA already equals tableB without any shift.",
  "abc300_b/Python/45723196": "It reads the two dimensions by taking the first and last characters of the input string instead of splitting tokens, causing incorrect parsing for multi-digit numbers or spaces.",
  "abc244_b/Python/45713633": "The rotate() method incorrectly sets dx to the position y instead of the direction dy, using self.y instead of self.dy and thus rotating the heading wrongly.",
  "abc265_c/Python/46154642": "The code mistakenly checks for 'W' instead of 'R' when handling right moves, so cells with 'R' are never recognized and right movement is mishandled.",
  "abc246_a/Python/45745121": "It prints the list object (e.g., “[x, y]”) instead of outputting the two coordinates as space-separated integers, producing the wrong output format.",
  "abc288_d/Python/45491126": "The bug is that the left prefix index is clamped before division (max(0, l−k−1)//K+1), which turns cases with l−k−1<0 into index 1 instead of the correct 0, yielding wrong sums; it should use (l−k−1)//K+1 without clamping.",
  "abc269_a/Python/45960382": "It prints \"takahashi\" in lowercase instead of the correctly capitalized \"Takahashi\".",
  "abc269_a/Python/45960449": "The program calculates (a+b)*(a−d) instead of (a+b)*(c−d), mistakenly using a instead of c in the subtraction.",
  "abc269_a/Python/45960652": "The program outputs \"takahashi\" in lowercase instead of the required \"Takahashi\" with a capital T.",
  "abc286_e/Python/45479724": "On ties in path length during the Floyd–Warshall relaxation, the buggy code picks the minimum accumulated value (using min) instead of the required maximum (using max).",
  "abc261_b/Python/45074177": "It omits the check for A[i][j] == 'L' and A[j][i] == 'W', so valid loss–win pairs are wrongly flagged as incorrect.",
  "abc261_b/Python/46179770": "In the 'L' case, the condition is inverted: it checks kama[ipp][i] == 'W' (flagging a correct mirror as incorrect) instead of enforcing kama[ipp][i] != 'W'.",
  "abc261_b/Python/45115214": "The buggy code omits counting the symmetric draw case ('D' vs 'D'), so valid matrices with draws are wrongly judged incorrect.",
  "abc261_b/Python/45282531": "It fails to enforce that draws are reciprocal, allowing cases like A[i][j]=='D' and A[j][i] != 'D' (or vice versa) to be considered correct.",
  "abc261_b/Python/45054015": "The buggy version misspells the final return value as \"correnct\" instead of \"correct\", causing incorrect output.",
  "abc261_b/Python/45997045": "The buggy code fails to mark as incorrect the case where exactly one of a[i][j] or b[i][j] is 'D' (an asymmetric draw), only checking equality and skipping the 'DD' case.",
  "abc240_d/Python/45435904": "The second condition should be an elif; using two separate ifs makes the else attach to the second if, so when Q is empty the code appends and then immediately treats the same value as a continuation (incrementing/popping the count) instead of skipping the second branch.",
  "abc263_a/Python/45986379": "It only checks K[2] != K[3] when there are two distinct values, missing the symmetric boundary K[1] != K[2], so it wrongly rejects valid cases like [a, a, b, b].",
  "abc263_a/Python/44922329": "The loop uses range(12) (with an extra i+=1), so it only checks values 1–12 and never counts 13, causing an off-by-one error.",
  "abc263_a/Python/45972944": "The buggy version prints \"YES\" (all caps) instead of the required \"Yes,\" causing a case-sensitive output mismatch.",
  "abc263_a/Python/45002191": "It wrongly prints Yes for any input with exactly two distinct numbers, even when neither repeats, instead of requiring that at least one of those numbers appears at least twice.",
  "abc263_a/Python/44884204": "The program only checks for a full house with the triple first and pair last (indices 0–2 and 3–4), missing the symmetric case where the pair comes first and the triple last (indices 0–1 and 2–4).",
  "abc263_a/Python/45528012": "The buggy condition includes an extra OR clause that makes it print “Yes” for just a triple or just a pair, instead of only when the numbers form a full house (three of a kind plus a pair).",
  "abc288_e/Python/41523056": "The bug is that INF is set too small (1e12), so unreachable DP states (value INF) can be smaller than actual feasible costs when they exceed 1e12, leading the final minimum to be incorrect; it should be a much larger value (e.g., 1e20).",
  "abc267_a/Python/45943869": "The final condition misspells \"Friday\" as \"Friay,\" so the program never prints 1 when the input is \"Friday.\"",
  "abc288_b/Python/44592257": "The buggy code reads n strings instead of k, so it sorts and selects from all inputs rather than only the first k strings.",
  "abc288_b/Python/45965822": "It sorts the entire list before slicing instead of slicing the first b elements and then sorting them, thus selecting the globally smallest b strings rather than sorting only the first b inputs.",
  "abc225_d/Python/45240176": "In the type-3 query, the leftward traversal appends 0-based indices to the front list (missing +1), producing mixed 0/1-based output.",
  "abc244_c/Python/45762748": "The inner loop searches only 1..N instead of 1..2N+1, preventing selection of valid numbers above N and causing failure once 1..N are all marked bad.",
  "abc244_c/Python/45056793": "The list ans is initialized with numbers 1..n+1 instead of 1..2n+1, making it too small and missing half the required values.",
  "abc244_c/Python/45666072": "The buggy code prints the set’s pop method object (num_set.pop) instead of calling it (num_set.pop()), so it outputs a function reference and doesn’t remove/print an element from the set.",
  "abc300_c/Python/45723345": "The results array is incorrectly sized as H+1 instead of min(H, W)+1, causing extra outputs (wrong length) when the width is smaller than the height.",
  "abc300_c/Python/45749744": "The results array is sized by n instead of min(n, m), causing the program to output n values (with extra trailing zeros) rather than exactly min(n, m) counts on rectangular grids.",
  "abc265_b/Python/46056659": "The code uses a strict “>” comparison (A[i] > T) instead of “>=”, wrongly allowing progress when the cost equals the remaining time, which should result in “No.”",
  "abc265_b/Python/45487693": "The code incorrectly checks t − s[now−1] < 0 instead of <= 0, allowing the case where time becomes exactly zero to be treated as valid.",
  "abc265_b/Python/46016041": "The code uses a non-strict check (nowT >= p) allowing moves that leave time zero, but it should require strictly more time (nowT > p) to prevent T from reaching zero.",
  "abc265_b/Python/45498956": "The loop wrongly compares t to the loop index i (t > i) instead of to the required cost a[i] (t > a[i]), causing an incorrect feasibility check.",
  "abc265_b/Python/45288123": "The bug is using T < 0 instead of T <= 0 to detect failure after each move, incorrectly allowing the case T == 0 to continue and possibly print \"Yes\" when it should be \"No.\"",
  "abc265_b/Python/45698748": "The final check uses t < 0 instead of t <= 0, wrongly accepting cases where the remaining time is exactly zero as success.",
  "abc265_b/Python/45798886": "The bug is that after subtracting the cost, it treats t == 0 as still alive (t >= 0) instead of failing when time is non-positive, which should require t > 0.",
  "abc282_e/Python/45514577": "The buggy code sorts edges in ascending order and thus builds a minimum spanning tree, whereas it should sort in descending order (reverse=True) to build the maximum spanning tree and maximize the sum.",
  "abc300_d/Python/45256387": "The buggy version hardcodes n = 10**12 instead of reading n from input, so it ignores the intended input value.",
  "abc244_d/Python/45792017": "The buggy program fails to remove spaces from the input strings before comparing/rotation checking, causing incorrect results when the inputs contain spaces.",
  "abc244_d/Python/45508442": "The bug is that A contains concatenated strings like \"RGB\" instead of the space-separated strings (\"R G B\", etc.) that the inputs use, causing the membership checks to fail.",
  "abc244_d/Python/45311340": "Missing parentheses cause Python to parse \"S in A == T in A\" as a chained comparison (S in A and A == T and T in A) instead of comparing the booleans (S in A) == (T in A), yielding incorrect behavior.",
  "abc244_d/Python/46208474": "The buggy code increments the counter on equal elements (S[i] == T[i]) instead of on mismatches (S[i] != T[i]), thus counting matches rather than mismatches.",
  "abc244_d/Python/45666207": "The code incorrectly prints “Yes” when the number of matching positions is odd, instead of only when all three or none match (cnt == 3 or cnt == 0).",
  "abc244_d/Python/44593613": "The recursive base case compares (s0, s1, s2) to s instead of t, so it checks against the original sequence rather than the target sequence.",
  "abc244_d/Python/44600103": "The condition is inverted: it prints “Yes” for an even number of mismatches, whereas it should print “Yes” only when there are zero or an odd number of differences (and “No” for 2).",
  "abc244_d/Python/46207866": "The buggy code treats “Yes” as any even number of mismatches (0 or 2) using cnt%2==0, instead of only when there are exactly 0 or 3 mismatches between corresponding entries.",
  "abc229_f/Python/46038453": "The DP transition for dp[i+1][1][0] wrongly adds B[i−1] when coming from dp[i][0][0], overcounting the cost—it should be dp[i][0][0] (no +B[i−1]).",
  "abc229_a/Python/45477841": "The buggy code only checks the (\".#\", \"#.\") pattern and misses the symmetric case (\"#.\", \".#\"), so it incorrectly prints \"Yes\" when S1==\"#.\" and S2==\".#\".",
  "abc229_a/Python/46233112": "The buggy code fails to consider that the answer should be \"Yes\" when either S1 or S2 has identical first and second characters (S1[0]==S1[1] or S2[0]==S2[1]).",
  "abc229_a/Python/45808992": "The buggy code omits the final else that should print \"Yes\" for all other inputs, so for non-matching cases it produces no output instead of \"Yes.\"",
  "abc229_a/Python/44996770": "The buggy code omits \"== '#'\" for s[1][1] in the condition, using its truthiness instead of comparing to '#', which misclassifies the diagonal case.",
  "abc229_a/Python/45784135": "The buggy code only checks vertical matches of '#' between s1 and s2 at each column, failing to detect horizontal adjacency within a single row (s1[0..1] or s2[0..1]).",
  "abc229_a/Python/45690274": "The buggy code lacks the else branch after the diagonal-check, so when black < 3 and that condition is false it produces no output instead of printing \"Yes.\"",
  "abc229_a/Python/46216070": "The second disjunct omits comparing [s1, s2] to [\".#\", \"#.\"] and instead uses a non-empty list directly, which is always truthy and makes the if condition always true.",
  "abc229_a/Python/44625287": "The condition checks the wrong patterns, using '.#.#' and '#.#.' (alternating) instead of the intended '.##.' and '#..#', leading to incorrect \"No\" cases.",
  "abc242_a/Python/45767519": "The second branch uses X <= C instead of X <= B, erroneously applying the middle-case formula for X values up to C rather than only up to B.",
  "abc242_a/Python/45709103": "The middle-case condition has an off-by-one error: it uses x > a+1 instead of x >= a+1, incorrectly excluding x == a+1 from the c/(b−a) case.",
  "abc242_a/Python/44475619": "In the else branch, it divides D by C instead of C by D, reversing the intended ratio.",
  "abc242_a/Python/45438303": "The middle condition is off by one: it uses X < B instead of X <= B, causing X == B to incorrectly print 0 instead of C/(B−A).",
  "abc242_a/Python/45690151": "The middle-case probability has an off-by-one error: it divides by (b − a + 1) instead of (b − a) for the interval (a, b].",
  "abc242_a/Python/44877017": "When x <= a, the buggy code sets res to 100.0 instead of 1.0, erroneously outputting a percentage rather than a probability.",
  "abc242_a/Python/45439791": "It uses X < A instead of X <= A, so when X equals A it outputs C/(B−A) instead of 1.",
  "abc242_a/Python/45214716": "In the middle case (a < x ≤ b), the code uses an off-by-one denominator c/(b−a+1) instead of the correct c/(b−a).",
  "abc248_f/Python/53199737": "The program incorrectly prints the entire last row of con (including index 0), whereas it should omit the first element and output con[-1][1:] instead.",
  "abc240_e/Python/45982558": "The DFS incorrectly tests visited[v] to detect a leaf instead of checking whether v’s only neighbor (its parent) is visited, causing degree-1 nodes (e.g., the root) to be wrongly labeled as leaves.",
  "abc261_d/Python/45285878": "When computing dp[i][0], the buggy code adds yl[j] (the last inner-loop index) instead of yl[0], incorrectly making dp[i][0] depend on j.",
  "abc261_d/Python/46044177": "The inner DP loop iterates j from 1 to n for every i, updating unreachable states (j > i+1) and using invalid dp[i][j−1]; it should limit j to 1..i+1.",
  "abc261_d/Python/45506869": "The DP table is initialized with -MOD (a finite large negative) instead of -INF, so unreachable states can contribute to transitions and skew the maximum result.",
  "abc286_d/Python/45059364": "The DP iterates n in increasing order, causing newly set states to be reused within the same coin type and thus allowing unlimited uses (ignoring the bound b); it must iterate n in descending order to enforce the bounded count.",
  "abc286_d/Python/45471607": "The DP transition wrongly sets dp[i+1][j] = dp[i][j] or dp[i][j - k*a[i]] instead of dp[i+1][j] = dp[i+1][j] or dp[i][j - k*a[i]], so each k iteration overwrites rather than accumulates, causing valid states to be lost.",
  "abc286_d/Python/45787313": "The DP transition loops j only up to x−1 (range(x)) instead of including x (range(x+1)), so the j = x state is never processed and cannot be propagated (e.g., with k = 0), causing valid solutions to be missed.",
  "abc248_a/Python/45497568": "The initial digit set uses range(1,10) instead of range(0,10), omitting 0 so it’s never considered or reported as a missing digit.",
  "abc248_a/Python/45470045": "The loop starts at 1 instead of 0, so it never checks for a missing digit 0 and fails when 0 is the smallest absent digit.",
  "abc223_a/Python/45815037": "The buggy code lacks a branch for X ≥ 100 that aren’t multiples of 100, so it outputs nothing instead of “No” in those cases.",
  "abc223_a/Python/45714918": "The code incorrectly prints \"Yes\" for x=0 by only checking x%100==0 instead of also excluding zero.",
  "abc223_a/Python/45813374": "The buggy code prints \"Yes\" for any n ≥ 100 but should only print \"Yes\" when n is a multiple of 100, missing the n % 100 == 0 check.",
  "abc298_e/Python/46008577": "The final sum uses the cumulative probability T_dp[i+1][-1] instead of the incremental probability T_dp[i+1][-1]−T_dp[i][-1], thus overcounting cases where Taro had already finished before step i+1.",
  "abc235_c/Python/46176667": "The buggy code includes an unintended debug print (print(D)) that outputs the dictionary before answering queries, corrupting the expected output format.",
  "abc277_a/Python/45949578": "It prints the zero-based index of X in P instead of the required 1-based position (missing the +1 when outputting).",
  "abc277_a/Python/45114990": "It prints the zero-based index of x in the list instead of the required 1-based position (missing +1).",
  "abc298_b/Python/45491531": "The code checks only three rotations (90°, 180°, 270°) and omits the 0°/360° orientation by looping 3 times instead of 4, so it can miss a valid match.",
  "abc298_b/Python/45279577": "The rotation loop runs only three times (range(3)), so one of the four orientations—specifically the original—is never checked, causing potential false negatives.",
  "abc298_b/Python/45996525": "The rotation loop starts at 1 (range(1,4)), so it never checks the 0° rotation of a, potentially missing a valid match; it should iterate i=0..3.",
  "abc298_b/Python/45483068": "The loop runs only three times, so it never checks the 270° rotation (fourth orientation) of A, causing missed matches; it should iterate four times.",
  "abc235_d/Python/44415594": "The buggy code performs the rotation move without verifying that the rotated number keeps the same digit length, so rotations that introduce leading zeros (shortening the number) are incorrectly allowed.",
  "abc235_d/Python/45465231": "The buggy code allows rotating x even when its second digit is 0, causing an invalid rotation that drops leading zeros (reduces the digit count), whereas the correct code forbids rotation by checking str(x)[1] == '0'.",
  "abc235_d/Python/44598432": "The buggy code always applies the rotation, even when it creates a leading zero and reduces the digit count, whereas it should only rotate when the number of digits is preserved (len(str(M)) == len(str(rot(M)))).",
  "abc235_d/Python/46231153": "The code incorrectly allows rotating numbers whose last digit is 0, but the rotation should only be performed when x has at least two digits and x%10 != 0 to avoid creating invalid leading-zero states.",
  "abc308_a/Python/45931202": "The bug is a wrong comparison operator: the code uses \">=\" instead of \">\", incorrectly rejecting sequences with equal adjacent values that should be allowed.",
  "abc308_a/Python/45959405": "The code omitted the required boundary check on the first and last elements (that arr[0] must be ≥100 and arr[-1] must be ≤675), so invalid inputs could still pass.",
  "abc308_a/Python/46170943": "The bug is an off-by-one comparison: the code uses strict >100 and <675 instead of inclusive >=100 and <=675, wrongly excluding valid boundary values.",
  "abc308_a/Python/46165457": "The bug is an off-by-one boundary error: the code wrongly uses inclusive comparisons (>=675 and <=100) instead of the intended exclusive ones (>675 and <100), causing the endpoints 100 and 675 to be misclassified.",
  "abc308_a/Python/46023709": "The bug is a wrong comparison operator: the code uses check_num < S[i] instead of check_num <= S[i], so it incorrectly rejects sequences where elements are equal (non-decreasing with repeats).",
  "abc308_a/Python/46000754": "The code mistakenly uses equality (sorted(S) == S) instead of inequality (sorted(S) != S) when testing sortedness, inverting the intended logic and causing correct sorted inputs to be rejected.",
  "abc308_a/Python/46165135": "The bug is an incorrect comparison operator (using >= instead of >) that wrongly rejects sequences with equal adjacent elements instead of allowing non-decreasing order.",
  "abc308_a/Python/45947529": "The second loop mistakenly uses the variable `i` (from the previous loop) instead of `j`, so it repeatedly checks the wrong index and fails to validate each element `S[j]`.",
  "abc302_a/Python/45902614": "The code uses float division with int(x/y)+1 rather than performing integer ceiling division, causing off-by-one and floating-point rounding errors (e.g., when x is an exact multiple of y).",
  "abc302_a/Python/45467003": "The code incorrectly computes the ceiling of A/B by using 1 + A//B, which overcounts when A is divisible by B instead of using (A + B - 1)//B.",
  "abc302_a/Python/46001200": "Off-by-one error: the code unconditionally adds 1 to A//B instead of using (A-1)//B+1, so it overcounts when A is exactly divisible by B.",
  "abc302_a/Python/45783782": "The bug comes from using float division with int(A/B) in the divisible case (risking precision/rounding errors), instead of using pure integer arithmetic like (A+B-1)//B.",
  "abc304_c/Python/45117916": "The code wrongly checks membership in dict[0] (assuming the root is key 0) instead of using the actual root uf.find(0), causing incorrect lookups or KeyError when node 0's root isn't 0.",
  "abc304_d/Python/45574429": "The final print arguments are swapped: the code outputs (max, min) instead of the required (min, max) by calling print(M, n) instead of print(n, M).",
  "abc304_b/Python/45577481": "The final branch uses the wrong factor (100000 instead of 1000000), so numbers in [1e8, 1e9) are incorrectly rounded to 100,000s instead of 1,000,000s.",
  "abc304_b/Python/45808253": "The bug is a typo in the 5-digit case that sets l[1] = 1 instead of l[1] = 0, so the second-most-significant digit isn't zeroed out.",
  "abc304_b/Python/45336297": "The bug is due to a missing final conditional branch handling numbers up to 10**9-1, so inputs in that range produce no corresponding output.",
  "abc304_b/Python/46153900": "The bug is using round(N, -range(N)) — which rounds to the nearest multiple — instead of truncating with integer division and multiplication, so values get incorrectly rounded rather than floored.",
  "abc304_b/Python/45306152": "An off-by-one error in the loop range (using range(6) instead of range(7)) causes the code to miss the highest magnitude case so some inputs never meet the condition and produce no output.",
  "abc304_b/Python/46194774": "The program is missing the conditional branch that handles numbers in the range 10^8 to 10^9−1, so inputs in that range fall through to the else and produce no output.",
  "abc310_c/Python/45695385": "The bug is that the code checks len(s) == 1 instead of testing if s is a palindrome (s == t), so palindromic strings longer than one character are handled incorrectly.",
  "abc310_c/Python/45952581": "The bug is a logic inversion in the if condition: it increments the counter when S is already in Z (S in Z) instead of when S is new (S not in Z).",
  "abc310_d/Python/53176077": "The program fails to convert the 1-based person indices from input to 0-based (missing the -1), so hate pairs reference the wrong IDs and break the grouping logic.",
  "abc310_d/Python/50903679": "The forbidden-edge check used the raw ordered pair (u,v) from selections instead of normalizing to the stored (min,max) order, so conflicts were missed when the node order was reversed.",
  "abc310_b/Python/46010800": "The bug is an incorrect inner-loop bound: it iterates over j in range(i) instead of range(n), so some required pairwise comparisons (j >= i) are never checked.",
  "abc310_b/Python/45545558": "The bug is an overly permissive dominance check that treats products with equal price and features as dominating because it omits the required strict condition (p[i] > p[j] or len(f[j]) > len(f[i])).",
  "abc310_b/Python/45953433": "The bug is using len((fj | fi)) - len(fj) instead of len((fj | fi)) - len(fi) when checking whether I[i] has any additional languages beyond I[j], causing the condition to be evaluated incorrectly.",
  "abc310_b/Python/45742461": "The bug is a wrong index in the first comparison: the code mistakenly uses s[j][1] (the other item's cost) instead of s[j][0] (the other item's price), so it compares the wrong field.",
  "abc310_b/Python/45952354": "A typo in the inner conditional uses P[i] >= P[i] and (F[i] - F[j]) instead of P[i] >= P[j] and (F[j] - F[i]), so the dominance check compares an element with itself and reverses the feature-difference direction.",
  "abc310_b/Python/46023032": "The bug was that the code failed to mark a pair as problematic when the two products had equal prices but strictly different feature sets (it omitted the Pi == Pj and Fi != Fj check).",
  "abc307_c/Python/46162555": "A typographical error in the bounds check — the condition compares PB[1] to PX[0] instead of PX[1], causing an incorrect early skip/rejection of valid cases.",
  "abc307_d/Python/45471496": "The code fails to restore the previous text buffer after popping a matching \"(\", so when handling a ') 'it loses/doesn't resume the prior accumulated characters (temp), causing incorrect/missing output.",
  "abc307_d/Python/45446603": "The code records the original string index for \"(\" (i) instead of the current position in the built answer (len(ans)), so later deletions use incorrect slice bounds and remove the wrong characters.",
  "abc303_b/Python/45560009": "The bug is using the floating-point division operator (\"/\") instead of integer floor division (\"//\"), causing the final count to be returned as a float instead of an integer.",
  "abc309_b/Python/45722179": "The bug is caused by an unintended duplicate loop that appends the top row twice to rotate_list, corrupting the rotation order and misaligning the reassignment.",
  "abc301_a/Python/45347926": "The bug is that the loop doesn't break when a team first reaches N/2, so counting continues and can overwrite or miscompute the early-win condition.",
  "abc301_a/Python/45503092": "The code mistakenly uses input().split(), making S a list of tokens instead of the intended string, so character counts and the last-character check operate on list elements (tokens) and produce incorrect results.",
  "abc301_a/Python/45433034": "A leftover debug print (print(f'A:{A},T:{T}')) inside the loop produces extraneous output and breaks the program's expected output.",
  "abc301_a/Python/45927126": "The code fails to handle the tie case (equal counts of \"T\" and \"A\") because it lacks the tie-breaker that checks the last character of S to decide the winner.",
  "abc305_a/Python/45768286": "The code uses the wrong formula—printing abs(5 - (n%5)) (an offset) instead of adding the correct offset to the input to produce the nearest multiple of 5, so it yields incorrect results (e.g., returns 5 for numbers already divisible by 5).",
  "abc305_a/Python/45435091": "The program hardcodes n=100 instead of reading the integer from input (n=int(input())), so it doesn't use the intended user-provided value.",
  "abc305_a/Python/46193789": "An off-by-one error: the loop uses range(20) so it omits i=20 (the 100 candidate), causing the nearest-multiple-of-5 search to miss that value.",
  "abc305_a/Python/45542217": "The code uses the wrong formula for rounding up to the next multiple of 5—it computes N+a-1 instead of N+(5-a), producing an incorrect (off-by-2) result when N%5 == 4.",
  "abc305_a/Python/45785540": "The branch handling numbers divisible by 5 prints the literal 0 instead of the input n, causing incorrect output whenever n%5 == 0.",
  "abc305_a/Python/46173794": "Off-by-one logic error: the condition uses n%5>=2 instead of n%5>2, so values with remainder 2 are incorrectly rounded up.",
  "abc307_e/Python/46214607": "The program fails to reduce the result modulo 998244353 before printing, so the computed value (which can be negative or out of range) is not output mod 998244353.",
  "abc307_b/Python/45786032": "The bug is accidental list-bracketing: using [s[i]+s[j]][::-1] reverses a one-element list (producing a list) instead of reversing the concatenated string, causing a type mismatch and the palindrome check to fail.",
  "abc307_b/Python/45983540": "The bug is that the inner loop uses \"break\" when i == j, which prematurely exits the loop instead of \"continue\", causing many j pairs to be skipped and missing valid palindrome concatenations.",
  "abc309_c/Python/45772102": "The code fails to print a result when the `medicines <= K` condition is never met inside the loop, because the final fallback `print(AB[i][0] + 1)` after the loop is missing.",
  "abc309_c/Python/45738581": "The bug is an incorrect comparison: the code uses total < K instead of total <= K, causing it to mishandle the case when total == K.",
  "abc309_c/Python/45895898": "The bug is an off-by-one error: the binary search upper bound was initialized to maxday instead of maxday+1, causing the search to miss the correct day when the answer equals maxday.",
  "abc309_c/Python/46182298": "The binary search uses the wrong comparison (calc(m) < k instead of calc(m) <= k), causing incorrect updates of l/r and an off-by-one error in the final result.",
  "abc309_d/Python/46051654": "The traversal function enqueues the constant node 0 instead of the provided start node s, so distances are computed from the wrong source.",
  "abc303_c/Python/46045444": "The bug is that each item's count is set to m instead of 1 when reading input, so potions are incorrectly treated as having m uses instead of a single use.",
  "abc303_c/Python/45491344": "The bug is a typo: the code uses the equality operator \"==\" instead of the assignment \"=\" when trying to set item[(now[0],now[1])] = 0, so picked-up items are never cleared.",
  "abc303_c/Python/45578518": "A leftover debug statement (`print(items)`) produces extra output and thus corrupts the program's expected output.",
  "abc303_c/Python/46147196": "The bug is an off-by-one error: the loop iterates over S[:-1] (omitting the last move), so the final move and its health/healing checks are never processed.",
  "abc303_d/Python/45489398": "The bug was using an INF value that was too small (1e10) so legitimate DP costs could exceed it and be treated as \"infinite,\" corrupting the DP transitions and final result.",
  "abc303_d/Python/45744343": "The bug is a wrong cost in the DP transition for dp[1][j] when s[j] == \"A\": the code uses z + x instead of the correct z + y, producing an incorrect update.",
  "abc308_b/Python/45960039": "The bug is that the code calls print(p[0]) for unknown items instead of adding p[0] to the running total (s), so the default price is never accumulated and is wrongly printed.",
  "abc302_b/Python/45763953": "Off-by-one error in the \"right-up diagonal\" loop: it uses range(5, h) instead of range(4, h), so diagonals starting at row index 4 are never checked.",
  "abc306_b/Python/45767909": "The loop mistakenly uses A[i] as the exponent (2 ** A[i]) instead of the loop index i (2 ** i), causing incorrect power computations.",
  "abc306_b/Python/45442211": "The bug is an off-by-one error in the loop bound—using range(63) omits the last element (index 63) so the highest-order term isn't included.",
  "abc306_b/Python/45523037": "An off-by-one error: the for loop uses range(63) instead of range(64), so the bit at index 63 is never processed and the highest-value bit is omitted.",
  "abc304_a/Python/45720608": "The code prints the entire [name, value] pair (using print(*ans[...] )) instead of printing only the name (ans[...] [0]).",
  "abc302_c/Python/45476546": "The code mistakenly uses itertools.product(S, repeat=N) instead of itertools.permutations(S), causing it to generate sequences with repeated rows rather than the required permutations of the input.",
  "abc302_c/Python/45989052": "The code uses break instead of terminating the program (exit/return) after printing \"Yes\", so execution continues and the final \"No\" is printed anyway.",
  "abc308_d/Python/54535139": "The bug is that neighbor cells are marked as visited before checking if they match the expected \"snuke\" character, prematurely blocking valid traversal.",
  "abc308_d/Python/54718266": "The final condition mistakenly checks grid[h][w] (a non-empty character, truthy) instead of bool[h][w], so it tests the cell's content rather than whether it was reached.",
  "abc308_c/Python/45973622": "The bug was caused by using floating-point division (/) instead of integer floor division (//), producing inexact values and wrong ordering due to precision/rounding errors.",
  "abc308_c/Python/46192638": "The bug was using floating-point division (/) instead of integer floor division (//), causing precision loss when scaling by 10**100 and producing incorrect ordering.",
  "abc308_c/Python/45936707": "The bug was caused by using floating-point division to compare ratios (a/sum), which introduced precision errors and incorrect ordering instead of using a large-scale integer computation to perform exact comparisons.",
  "abc310_a/Python/46023025": "The bug is a wrong arithmetic expression — the code uses `p - q + min(d)` instead of the correct `q + min(d)`, causing an incorrect subtraction of `q` from `p`.",
  "abc310_a/Python/45951629": "The code computes the wrong expression — it uses `P - Q + D[i]` (mixing P and subtraction) instead of `Q + D[i]`, producing incorrect candidate values.",
  "abc310_a/Python/46010909": "The bug is a faulty arithmetic expression: the code uses p - q + a instead of q + a (it subtracts q from p rather than adding q), producing the wrong result.",
  "abc310_a/Python/45739812": "The bug is a wrong arithmetic expression—a typo using \"P - Q + d\" instead of the correct \"Q + d\"—so the candidate value p is computed incorrectly.",
  "abc310_a/Python/45785883": "The bug was caused by an incorrect arithmetic expression when computing b — the code used \"p - q + a[i]\" instead of the correct \"q + a[i]\".",
  "abc310_f/Python/50729164": "The bug was that the transition for choosing values >10 was omitted — the dp[i+1][bit] += dp[i][bit] * max(0, a[i]-10) * inv term was missing, so contributions from those choices were never added.",
  "abc303_a/Python/46127283": "The bug is a typo in the second conditional: it checks t[i] == \"o\" instead of s[i] == \"o\", so the code tests the wrong variable when handling the '0'/'o' equivalence.",
  "abc309_a/Python/45963671": "The program fails to terminate after detecting b-a != 1 (missing an exit/return), so execution continues and can produce incorrect output.",
  "abc309_a/Python/45980846": "The bug is an extra OR clause that incorrectly checks grid[j][i] and grid[j+1][i] (swapping i and j), causing unintended vertical/transposed pair matches and false positives instead of only checking horizontal adjacent elements.",
  "abc309_a/Python/46003315": "The code used the wrong variables and condition—it compared ax to ay and required by-ay==1 instead of comparing rows (ax==bx) and checking the columns differ by 1 (abs(ay-by)==1).",
  "abc309_a/Python/45763717": "The bug is a wrong conditional: it uses \"abs(a-b) in [1,3]\" (allowing difference 3) instead of \"abs(a-b) == 1\", so pairs with difference 3 are incorrectly accepted.",
  "abc309_a/Python/45775765": "The code is missing a final else branch to handle cases where (A,B) doesn't match any listed pair, so it fails to print \"No\" for unmatched inputs.",
  "abc309_a/Python/45740476": "The bug is a missing/incorrectly placed else for the inner if, so when b == a+1 and a is divisible by 3 the program produces no output instead of printing \"No\".",
  "abc309_a/Python/45974546": "The bug is caused by an incorrect initialization of G — it contains extra pair entries (edges) that shouldn't be present, causing incorrect matches (false positives).",
  "abc309_a/Python/45782370": "The bug is caused by an incorrect hard-coded adjacency dictionary `p` (wrong neighbor tuples), so the program checks the wrong connections.",
  "abc309_a/Python/46005581": "The bug is a simple typo: the second branch prints \"YES\" (wrong case) instead of the required \"Yes\", producing incorrect output.",
  "abc309_a/Python/46161633": "The bug is an incorrect extra condition (A==B-3) in the elif that expands the accepted cases beyond the intended A==B-1, producing wrong outputs.",
  "abc301_b/Python/45970658": "The bug is a leftover debug statement—an unintended print(i) inside the loop—that emits each element and thus produces extraneous output breaking the program's expected output.",
  "abc301_b/Python/46199451": "The program prints the Python list object (with brackets and commas) instead of outputting the sequence of numbers space-separated, because it uses print(ans_list) instead of print(*ans_list).",
  "abc301_b/Python/45340910": "The program prints the list object (print(b)) instead of unpacking its elements (print(*b)), producing Python list syntax rather than the required space-separated numbers.",
  "abc301_e/Python/45949713": "The start coordinates were never updated because of a typo—`s=[i,j]` was used instead of `start=[i,j]`, leaving `start` at its default [0,0] and producing incorrect distances.",
  "abc301_d/Python/45718315": "The bug is that when encountering a fixed '1' the code only adjusts min_val but forgets to add mask to ans and subtract mask from n, so forced '1' bits are not counted or applied.",
  "abc301_d/Python/45747617": "The bug is an incorrect prefix check when s1 is longer than s2: the code wrongly requires the extra leading characters to be all '?' (s1[:le] != '?'*le) instead of only forbidding '1's (i.e., checking s1[:le].count('1') > 0), so valid prefixes with '0' are rejected.",
  "abc301_d/Python/45732372": "The code prints the initial ans prematurely (before checking if it's > n and before maximizing '?' bits), causing incorrect output order and results.",
  "abc301_d/Python/45723653": "The bug was caused by iterating over the bit positions in reverse (least significant first) when filling '?'s, breaking the required greedy choice order — it should scan from most significant to least significant.",
  "abc301_d/Python/45725346": "The bug was caused by an incorrect expression \"(res + 1) << d\" (wrong operator grouping) instead of \"res + (1 << d)\", so the shift is applied to the wrong value and produces an incorrect increment.",
  "abc307_a/Python/45953883": "The bug is simply using print(res) which prints the Python list representation instead of print(*res) to output the elements space-separated as required.",
  "abc307_a/Python/45989937": "The bug is an incorrect index calculation—using s[l + i] instead of s[l + i*7] so the code advances by 1 each iteration instead of jumping by 7 and thus selects wrong elements.",
  "abc307_a/Python/45778588": "The outer loop's range mistakenly uses int(N/7) instead of int(N), so it runs far fewer iterations and fails to process most of the intended groups."
}